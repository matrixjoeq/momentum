<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>基准分析（等权组合）</title>
    <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
    <style>
      body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 24px; }
      .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: end; }
      label { display: block; font-size: 12px; color: #444; margin-bottom: 4px; }
      input, select { padding: 8px; min-width: 180px; }
      button { padding: 8px 12px; cursor: pointer; }
      .muted { color: #666; font-size: 12px; }
      .panel { margin-top: 16px; }
      table { border-collapse: collapse; width: 100%; }
      th, td { border-bottom: 1px solid #ddd; padding: 8px; text-align: left; font-size: 13px; }
      th { background: #f7f7f7; }
      #chart, #rollingReturns, #rollingDD { width: 100%; height: 520px; }
      .two { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      .code-list { max-height: 220px; overflow: auto; border: 1px solid #ddd; padding: 8px; min-width: 320px; }
      .msg { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; }
      .no-print { }
      .tabs { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 12px; }
      .tabBtn { padding: 8px 12px; border: 1px solid #bbb; background: #fff; border-radius: 10px 10px 0 0; cursor: pointer; }
      .tabBtn.active { border-color: #444; font-weight: 600; }
      .tabPanel { display: none; }
      .tabPanel.active { display: block; }

      @media print {
        body { margin: 12mm; }
        .no-print { display: none !important; }
        #metricModal { display: none !important; }
        .panel, table { break-inside: avoid; page-break-inside: avoid; }
        h2, h3 { break-after: avoid; page-break-after: avoid; }
        #chart, #rollingReturns, #rollingDD,
        #ewCalHeatmap, #ewCalRollingChart,
        #rotChart, #rotDDCompare, #rotExcessChart, #rot40dDiffChart, #rotRollingCombo, #rotExcessRollingCombo,
        #rotCalHeatmap, #rotCalRollingChart,
        #corrHeatmap,
        #trendChart, #trendDD,
        #mcEwHist, #mcRotHist, #mcExcessHist,
        #mcEwQQ, #mcRotQQ, #mcExcessQQ,
        #mcRotPeriodHist, #mcExcessPeriodHist {
          height: 420px !important;
        }
      }
    </style>
  </head>
  <body>
    <h2>基准分析：等权持有组合</h2>
    <div class="muted">用于动量轮动研究的基准数据：标的净值、等权组合净值、绩效指标与滚动统计。</div>
    <div class="muted" style="margin-top: 6px;">
      <a href="/">返回候选池</a>
      <span style="margin: 0 6px;">|</span>
      <a href="/research/gold">研究：黄金（ETF/全球/国内）</a>
      <span style="margin: 0 6px;">|</span>
      <a href="/research/nasdaq-vix">研究：纳指ETF × VIX（Cboe）</a>
      <span style="margin: 0 6px;">|</span>
      <a href="/research/gold#step1">研究 Step1：国际金价 × 美债 × DXY</a>
      <span style="margin: 0 6px;">|</span>
      <a href="/research/gold#step2">研究 Step2：国内金价 × CNH × 国债</a>
      <span style="margin: 0 6px;">|</span>
      <a href="/research/gold#step3">研究 Step3：国内金价 × 国际金价</a>
      <span style="margin: 0 6px;">|</span>
      <a href="/research/gold#step4">研究 Step4：黄金ETF × 国内现货金</a>
    </div>

    <div class="panel row no-print">
      <div>
        <label>开始日期</label>
        <input id="start" placeholder="YYYYMMDD" />
      </div>
      <div>
        <label>结束日期</label>
        <input id="end" placeholder="YYYYMMDD" />
      </div>
      <div style="min-width: 420px;">
        <label>回测区间快捷选项（按勾选标的共同区间计算）</label>
        <div class="row" style="gap:8px; align-items:center;">
          <button id="range1y" title="近一年（按共同最大区间）">近一年</button>
          <button id="range3y" title="近三年（按共同最大区间）">近三年</button>
          <button id="range5y" title="近五年（按共同最大区间）">近五年</button>
          <button id="range10y" title="近十年（按共同最大区间）">近十年</button>
          <button id="rangeAll" title="成立以来（按共同最大区间）">成立以来</button>
          <span id="rangeHint" class="muted" style="margin-left:6px;"></span>
        </div>
      </div>
      <div>
        <label>等权再平衡周期</label>
        <select id="rebalance">
          <option value="daily">日度</option>
          <option value="weekly" selected>周度（默认）</option>
          <option value="monthly">月度</option>
          <option value="quarterly">季度</option>
          <option value="yearly">年度</option>
          <option value="none">不平衡（买入持有）</option>
        </select>
      </div>
      <div>
        <label>基准标的（用于信息比率）</label>
        <select id="benchmark"></select>
      </div>
      <div>
        <label>无风险收益率（年化，长期中国0-1年国债）</label>
        <input id="rf" placeholder="如 2.5 或 0.025" value="2.5" />
      </div>
      <button id="run">运行分析</button>
      <button id="exportPdf">导出PDF报告</button>
      <div id="status" class="muted"></div>
    </div>

    <div class="panel no-print">
      <div class="row">
        <div class="code-list" id="codes"></div>
        <div class="muted">
          勾选候选池中的标的组成组合。图例可点击隐藏/显示曲线。
          <div style="margin-top:8px">
            <button id="selAll">全选</button>
            <button id="selNone">取消全选</button>
            <button id="selInvert">反选</button>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="muted" id="dataNote">
        数据口径：交易价格=none（不复权）；动量评分/动量门槛=hfq（后复权，总回报）；趋势/RSI/波动率/震荡过滤= qfq（前复权）。
      </div>
      <div id="chart"></div>
    </div>

    <div class="panel">
      <div class="two" style="grid-template-columns: 1.05fr 1.95fr; align-items:start;">
        <div>
          <h3>等权组合指标</h3>
          <table id="metrics"></table>
        </div>

        <div>
          <h3>周期收益率（等权组合）</h3>

          <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start;">
            <div>
              <div class="muted">周度</div>
              <div class="row" style="gap:8px; margin:6px 0;">
                <select id="weeklySortKey" style="min-width:120px;">
                  <option value="date">日期</option>
                  <option value="return">收益</option>
                </select>
                <select id="weeklySortDir" style="min-width:120px;">
                  <option value="desc">递减</option>
                  <option value="asc">递增</option>
                </select>
                <button id="weeklyPrev">上一页</button>
                <button id="weeklyNext">下一页</button>
                <span class="muted" id="weeklyPage"></span>
              </div>
              <table id="weekly"></table>

              <div style="margin-top:12px">
                <div class="muted">季度</div>
                <div class="row" style="gap:8px; margin:6px 0;">
                  <select id="quarterlySortKey" style="min-width:120px;">
                    <option value="date">日期</option>
                    <option value="return">收益</option>
                  </select>
                  <select id="quarterlySortDir" style="min-width:120px;">
                    <option value="desc">递减</option>
                    <option value="asc">递增</option>
                  </select>
                  <button id="quarterlyPrev">上一页</button>
                  <button id="quarterlyNext">下一页</button>
                  <span class="muted" id="quarterlyPage"></span>
                </div>
                <table id="quarterly"></table>
              </div>
            </div>

            <div>
              <div class="muted">月度</div>
              <div class="row" style="gap:8px; margin:6px 0;">
                <select id="monthlySortKey" style="min-width:120px;">
                  <option value="date">日期</option>
                  <option value="return">收益</option>
                </select>
                <select id="monthlySortDir" style="min-width:120px;">
                  <option value="desc">递减</option>
                  <option value="asc">递增</option>
                </select>
                <button id="monthlyPrev">上一页</button>
                <button id="monthlyNext">下一页</button>
                <span class="muted" id="monthlyPage"></span>
              </div>
              <table id="monthly"></table>

              <div style="margin-top:12px">
                <div class="muted">年度</div>
                <div class="row" style="gap:8px; margin:6px 0;">
                  <select id="yearlySortKey" style="min-width:120px;">
                    <option value="date">日期</option>
                    <option value="return">收益</option>
                  </select>
                  <select id="yearlySortDir" style="min-width:120px;">
                    <option value="desc">递减</option>
                    <option value="asc">递增</option>
                  </select>
                  <button id="yearlyPrev">上一页</button>
                  <button id="yearlyNext">下一页</button>
                  <span class="muted" id="yearlyPage"></span>
                </div>
                <table id="yearly"></table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel two" style="grid-template-columns: 1fr 1fr; align-items:start;">
      <div>
        <h3>收益贡献（等权组合，全区间） <button class="helpBtn" data-metric="ew_return_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
        <table id="ewReturnContrib"></table>
      </div>
      <div>
        <h3>风险贡献（等权组合，全区间） <button class="helpBtn" data-metric="ew_risk_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
        <table id="ewRiskContrib"></table>
      </div>
    </div>

    <div class="panel">
      <h3>相关性矩阵（日收益） <span id="corrRangeTitle" class="muted"></span></h3>
      <div class="muted">口径：hfq（后复权）。横纵坐标为标的编号（见下方映射）。</div>
      <div class="row no-print" style="gap:8px; margin-top:8px;">
        <button id="corrRange1m">近一月</button>
        <button id="corrRange3m">近三月</button>
        <button id="corrRange6m">近六月</button>
        <button id="corrRange1y">近一年</button>
        <button id="corrRange3y">近三年</button>
        <button id="corrRange5y">近五年</button>
        <button id="corrRange10y">近十年</button>
        <button id="corrRangeAll">全回测区间</button>
        <span id="corrRangeHint" class="muted" style="margin-left:6px;"></span>
      </div>
      <div id="corrLegend" class="muted" style="margin-top:6px;"></div>
      <div id="corrHeatmap" style="width:100%; height:520px;"></div>
    </div>

    <div class="panel two" style="grid-template-columns: 1fr 1fr; align-items:start;">
      <div>
        <h3>滚动收益率（等权组合）</h3>
        <div id="rollingReturns"></div>
      </div>
      <div>
        <h3>滚动回撤（等权组合）</h3>
        <div id="rollingDD"></div>
      </div>
    </div>

    <!-- RSI is overlaid on NAV charts (secondary axis) -->

    <div class="panel">
      <h3>傅里叶变换分析（候选标的）</h3>
      <div class="muted">口径：对数收益（Δlog(P)）；输出主导周期、频段能量占比（低/中/高频）与谱熵。默认同时给出全区间与近1年/近半年窗口。</div>
      <div class="row no-print" style="margin-top:8px">
        <div>
          <label>FFT滚动窗口(交易日, 逗号分隔)</label>
          <input id="fftWindows" value="252,126" />
        </div>
        <div>
          <label>滚动FFT指标开关</label>
          <select id="fftRollOn" style="min-width:160px;">
            <option value="true" selected>开启</option>
            <option value="false">关闭</option>
          </select>
        </div>
        <div>
          <label>滚动FFT步长(交易日)</label>
          <input id="fftRollStep" value="5" />
        </div>
      </div>
      <div id="fftSummary" class="muted" style="margin-top:8px;"></div>
      <table id="fftTable"></table>
    </div>

    <div class="panel">
      <h3>滚动FFT指标时间序列（等权 EW）</h3>
      <div class="muted">展示 EW 组合在不同滚动窗口下的谱熵与高频能量占比随时间变化（按步长采样）。如果某些阶段谱熵显著下降/高频占比下降，才可能用于降低换手或提高入场门槛。</div>
      <div id="fftRollEntropy" style="width:100%; height:420px; margin-top:8px;"></div>
      <div id="fftRollHigh" style="width:100%; height:420px; margin-top:8px;"></div>
    </div>

    <div class="panel">
      <h3>各标的收益率与波动率分布统计</h3>
      <div class="muted">统计每个标的在不同周期（日度/周度/月度/季度/年度）下的收益率和波动率分布直方图与分位数。数据口径：hfq（后复权）。</div>
      <div class="row no-print" style="margin-top:8px; align-items:end;">
        <div>
          <label>选择标的</label>
          <select id="distCodeSelect" style="min-width:180px;"></select>
        </div>
        <div>
          <label>统计类型</label>
          <select id="distTypeSelect" style="min-width:180px;">
            <option value="return">收益率</option>
            <option value="volatility">波动率</option>
          </select>
        </div>
        <div>
          <label>周期</label>
          <select id="distPeriodSelect" style="min-width:180px;">
            <option value="daily">日度</option>
            <option value="weekly">周度</option>
            <option value="monthly">月度</option>
            <option value="quarterly">季度</option>
            <option value="yearly">年度</option>
          </select>
        </div>
      </div>
      <div id="distHistogram" style="width:100%; height:420px; margin-top:12px;"></div>
      <table id="distQuantiles" style="margin-top:12px;"></table>
    </div>

    <div class="panel">
      <h3>日历效应研究（等权 EW）</h3>
      <div class="muted">研究不同调仓周期下：调仓锚点（周度=周一~周五；月度=每月1~28号；季度/年度=当期第N个交易日）与成交价口径（开盘/收盘/OC均价）对组合表现的影响。此处参数与轮动策略研究互不影响。</div>
      <div class="row no-print" style="margin-top:8px; align-items:end;">
        <div>
          <label>开始日期（留空=沿用上方）</label>
          <input id="ewCalStart" placeholder="YYYYMMDD" />
        </div>
        <div>
          <label>结束日期（留空=沿用上方）</label>
          <input id="ewCalEnd" placeholder="YYYYMMDD" />
        </div>
        <div>
          <label>价格复权口径</label>
          <select id="ewCalAdjust" style="min-width:160px;">
            <option value="hfq" selected>hfq（后复权）</option>
            <option value="qfq">qfq（前复权）</option>
            <option value="none">none（不复权）</option>
          </select>
        </div>
        <div style="min-width:360px;">
          <label id="ewCalAnchorLabel">调仓锚点</label>
          <div id="ewCalAnchorBox"></div>
        </div>
        <div>
          <label>休市处理</label>
          <select id="ewCalShift" style="min-width:180px;">
            <option value="prev" selected>提前至上一交易日（默认）</option>
            <option value="next">顺延至下一交易日</option>
          </select>
        </div>
        <div style="min-width:260px;">
          <label>成交价口径</label>
          <div class="row" style="gap:10px; align-items:center;">
            <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="ewCalPx" value="open" checked />开盘</label>
            <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="ewCalPx" value="close" checked />收盘</label>
            <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="ewCalPx" value="oc2" checked />OC均价</label>
          </div>
        </div>
        <button id="runEwCalendar">运行（日历效应 EW）</button>
      </div>
      <div id="ewCalHeatmap" style="width:100%; height:360px; margin-top:10px;"></div>
      <table id="ewCalTable" style="margin-top:6px;"></table>
      <div id="ewCalRollingChart" style="width:100%; height:360px; margin-top:12px;"></div>
      <table id="ewCalRollingStats" style="margin-top:6px;"></table>
    </div>

    <div class="panel">
      <h3>蒙特卡洛模拟（等权组合）</h3>
      <div class="row">
        <div>
          <label>模拟次数</label>
          <input id="mcN" value="10000" />
        </div>
        <div>
          <label>区块长度(交易日)</label>
          <input id="mcBlock" value="5" />
        </div>
        <div>
          <label>滚动窗口(交易日，可空)</label>
          <input id="mcWindow" placeholder="如 2520 表示近10年" />
        </div>
        <div>
          <label>随机种子(可空)</label>
          <input id="mcSeed" placeholder="如 42" />
        </div>
        <button id="runMcEw">运行蒙特卡洛（等权）</button>
      </div>
      <table id="mcEwTable"></table>
      <div class="row" style="margin-top:8px">
        <label>直方图指标</label>
        <select id="mcEwMetric" style="min-width:220px;">
          <option value="cumulative_return">累积收益</option>
          <option value="annualized_return">年化收益</option>
          <option value="annualized_volatility">年化波动</option>
          <option value="max_drawdown">最大回撤</option>
          <option value="sharpe_ratio">夏普</option>
        </select>
      </div>
      <div id="mcEwHist" style="width:100%; height:420px;"></div>
      <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
        <div>
          <div class="muted">分布拟合结果（按 BIC 排序）</div>
          <table id="mcEwFitTable"></table>
        </div>
        <div>
          <div class="row" style="gap:8px">
            <label>Q-Q 分布</label>
            <select id="mcEwDist" style="min-width:180px;"></select>
          </div>
          <div id="mcEwQQ" style="width:100%; height:420px;"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h2 style="margin-top: 8px">动量轮动回测</h2>
      <div class="muted">
        动量信号：hfq（后复权，总回报）；技术分析（趋势/RSI/波动率/震荡过滤）：qfq（前复权）；交易价格：none（不复权）。
        轮动净值：none 收益为主，但遇到拆分/分红等公司行为导致 none 价格断点时，用 hfq 的当日收益进行修正以避免净值虚假跳变；等权对比净值：hfq（后复权，总回报，含分红再投资），且等权再平衡频率与轮动调仓频率一致。
      </div>

      <div class="panel no-print" style="margin-top: 10px;">
        <h3 style="margin: 0 0 6px 0;">小程序同款：固定4ETF 周度轮动（周一~周五 + 综合）</h3>
        <div class="muted">
          固定参数：周频 / Top1 / 回看20 / skip=0 / 成本=0 / 无风控 / 成交价=open / 休市=prev；标的固定为 159915/511010/513100/518880。
        </div>
        <div class="row" style="margin-top:8px; gap:8px; align-items:center;">
          <label style="margin:0;">方案：</label>
          <button id="mpRotA_mix">综合</button>
          <button id="mpRotA_0">周一</button>
          <button id="mpRotA_1">周二</button>
          <button id="mpRotA_2">周三</button>
          <button id="mpRotA_3">周四</button>
          <button id="mpRotA_4">周五</button>
          <span class="muted" id="mpRotAnchorHint" style="margin-left:6px;"></span>
        </div>
        <div class="row" style="margin-top:8px; gap:8px; align-items:center;">
          <label style="margin:0;">区间：</label>
          <button class="mpRotRange" data-k="1m">近一月</button>
          <button class="mpRotRange" data-k="3m">近三月</button>
          <button class="mpRotRange" data-k="6m">近半年</button>
          <button class="mpRotRange" data-k="1y">近一年</button>
          <button class="mpRotRange" data-k="3y">近三年</button>
          <button class="mpRotRange" data-k="5y">近五年</button>
          <button class="mpRotRange" data-k="10y">近十年</button>
          <button class="mpRotRange" data-k="all">全区间</button>
          <button id="runMpRot" style="margin-left:10px;">加载到下方轮动图表</button>
          <span class="muted" id="mpRotStatus" style="margin-left:6px;"></span>
        </div>
        <div id="mpRotPlan" class="muted" style="margin-top:8px;"></div>
      </div>

      <div class="panel no-print">
        <div class="tabs" id="rotTabs" role="tablist" aria-label="动量轮动参数">
          <button class="tabBtn active" data-tab="rotTabBase" role="tab" aria-selected="true">基础参数</button>
          <button class="tabBtn" data-tab="rotTabFloor" role="tab" aria-selected="false">动量过滤</button>
          <button class="tabBtn" data-tab="rotTabTrend" role="tab" aria-selected="false">趋势过滤</button>
          <button class="tabBtn" data-tab="rotTabRsi" role="tab" aria-selected="false">RSI过滤</button>
          <button class="tabBtn" data-tab="rotTabVol" role="tab" aria-selected="false">波动率过滤</button>
          <button class="tabBtn" data-tab="rotTabChop" role="tab" aria-selected="false">震荡过滤</button>
          <button class="tabBtn" data-tab="rotTabCorr" role="tab" aria-selected="false">相关性过滤</button>
          <button class="tabBtn" data-tab="rotTabInertia" role="tab" aria-selected="false">钝化</button>
          <button class="tabBtn" data-tab="rotTabRR" role="tab" aria-selected="false">滚动收益率</button>
          <button class="tabBtn" data-tab="rotTabTpSl" role="tab" aria-selected="false">止盈止损</button>
          <button class="tabBtn" data-tab="rotTabTiming" role="tab" aria-selected="false">择时</button>
          <button class="tabBtn" data-tab="rotTabDD" role="tab" aria-selected="false">回撤控制</button>
        </div>

        <div id="rotTabBase" class="tabPanel active" role="tabpanel">
          <div class="row">
            <div>
              <label>调仓频率 <button class="helpBtn" data-metric="param_rot_rebalance" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotRebalance">
                <option value="daily">日度</option>
                <option value="weekly" selected>周度（默认）</option>
                <option value="monthly">月度</option>
                <option value="quarterly">季度</option>
                <option value="yearly">年度</option>
              </select>
            </div>
            <div>
              <label>TopK <button class="helpBtn" data-metric="param_rot_topk" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotTopK" value="1" />
            </div>
            <div>
              <label>打分方式 <button class="helpBtn" data-metric="param_rot_score_method" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotScoreMethod" style="min-width:200px;">
                <option value="raw_mom" selected>纯动量（raw）</option>
                <option value="return_over_vol">收益/波动率</option>
                <option value="sharpe_mom">Sharpe 动量</option>
                <option value="sortino_mom">Sortino 动量</option>
              </select>
            </div>
            <div>
              <label>动量回看(交易日) <button class="helpBtn" data-metric="param_rot_lookback" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotLookback" value="20" />
            </div>
            <div>
              <label>跳过最近(交易日) <button class="helpBtn" data-metric="param_rot_skip" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotSkip" value="0" />
            </div>
            <div>
              <label>交易成本(bps) <button class="helpBtn" data-metric="param_rot_cost" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotCost" value="0" />
            </div>
          </div>
        </div>

        <div id="rotTabFloor" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>动量阈值开关 <button class="helpBtn" data-metric="param_rot_riskoff" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotRiskOff">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">启用</option>
              </select>
            </div>
            <div>
              <label>动量阈值 <button class="helpBtn" data-metric="param_rot_floor" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotFloor" value="0" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">说明：阈值触发后将进入空仓（现金）。</div>
        </div>

        <div id="rotTabTrend" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>趋势过滤开关 <button class="helpBtn" data-metric="param_rot_trend" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotTrendOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>趋势过滤模式</label>
              <select id="rotTrendMode" style="min-width:160px;">
                <option value="each" selected>逐标的</option>
                <option value="universe">全市场(候选均值)</option>
              </select>
            </div>
            <div>
              <label>SMA窗口(交易日)</label>
              <input id="rotTrendSma" value="20" />
            </div>
          </div>
        </div>

        <div id="rotTabRsi" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>RSI过滤开关 <button class="helpBtn" data-metric="param_rot_rsi" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotRsiOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>RSI窗口</label>
              <input id="rotRsiWin" value="20" />
            </div>
            <div>
              <label>超买阈值</label>
              <input id="rotRsiOver" value="70" />
            </div>
            <div>
              <label>超卖阈值</label>
              <input id="rotRsiUnder" value="30" />
            </div>
          </div>
        </div>

        <div id="rotTabVol" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>波动率过滤开关 <button class="helpBtn" data-metric="param_rot_vol" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotVolOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>波动率窗口</label>
              <input id="rotVolWin" value="20" />
            </div>
            <div>
              <label>目标年化波动率</label>
              <input id="rotVolTarget" value="0.20" />
            </div>
            <div>
              <label>最大年化波动率</label>
              <input id="rotVolMax" value="0.60" />
            </div>
          </div>
        </div>

        <div id="rotTabChop" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>震荡过滤开关 <button class="helpBtn" data-metric="param_rot_chop" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotChopOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>模式</label>
              <select id="rotChopMode" style="min-width:160px;">
                <option value="er" selected>ER（Efficiency Ratio）</option>
                <option value="adx">ADX（Average Directional Index）</option>
              </select>
            </div>
            <div id="rotChopErBox">
              <label>ER窗口</label>
              <input id="rotChopWin" value="20" />
            </div>
            <div id="rotChopErThrBox">
              <label>ER阈值</label>
              <input id="rotChopThr" value="0.25" />
            </div>
            <div id="rotChopAdxBox">
              <label>ADX窗口</label>
              <input id="rotChopAdxWin" value="20" />
            </div>
            <div id="rotChopAdxThrBox">
              <label>ADX阈值</label>
              <input id="rotChopAdxThr" value="20" />
            </div>
          </div>
        </div>

        <div id="rotTabCorr" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>相关性过滤开关（hfq）</label>
              <select id="rotCorrOn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>回看窗口(交易日)</label>
              <input id="rotCorrWindow" placeholder="空=同步动量回看" />
            </div>
            <div>
              <label>相关性阈值</label>
              <input id="rotCorrThr" value="0.5" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：若本期计划调入标的与当前持仓标的在回看窗口内的相关性（基于 hfq 收盘价日收益）大于阈值，则本期不调仓（保持原持仓）。
          </div>
        </div>

        <div id="rotTabInertia" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>钝化开关</label>
              <select id="rotInertiaOn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>最短持有期(调仓次数)</label>
              <input id="rotInertiaMinHold" value="0" placeholder="如 2" />
            </div>
            <div>
              <label>单标的切换阈值(动量差)</label>
              <input id="rotInertiaScoreGap" value="0" placeholder="如 0.01" />
            </div>
            <div>
              <label>最小换手阈值</label>
              <input id="rotInertiaMinTurnover" value="0" placeholder="如 0.2" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：用于降低频繁调仓。<br/>
            - 最短持有期：当计划换仓时，若距离上一次“持仓发生变化”的调仓决策不足 N 次，则本期保持原持仓。<br/>
            - 单标的切换阈值：仅对 TopK=1 生效；只有当新标的动量分数比当前持仓至少高出 Δ 时才允许切换。<br/>
            - 最小换手阈值：根据目标权重与当前权重估算换手（0.5×Σ|Δw|）；若换手低于阈值则本期不调仓。
          </div>
        </div>

        <div id="rotTabRR" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>滚动收益率仓位开关</label>
              <select id="rotRROn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>窗口年数 N</label>
              <input id="rotRRYears" value="3" />
            </div>
            <div style="min-width:360px;">
              <label>收益率阈值（最多5档）</label>
              <input id="rotRRThr" value="50,100,150,200,250" />
            </div>
            <div style="min-width:360px;">
              <label>对应仓位（阈值+1 档）</label>
              <input id="rotRRWts" value="100,80,60,40,20,10" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：调仓决策时，根据策略过去 N 年滚动收益率（基于策略净值）决定本期总仓位（现金为剩余仓位）。阈值和仓位支持输入百分比（如 50 表示 50%）。
          </div>
        </div>

        <div id="rotTabTpSl" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>止盈止损模式（qfq）</label>
              <select id="rotTpSlMode" style="min-width:240px;">
                <option value="none" selected>关闭（默认）</option>
                <option value="prev_week_low_stop">上一周期最低止损（止损价=上一调仓周期 qfq 收盘最低；持仓不变则更新为本周期最低）</option>
                <option value="atr_chandelier_fixed">ATR 吊灯止损（固定倍数）</option>
                <option value="atr_chandelier_progressive">ATR 吊灯止损（渐进式倍数）</option>
              </select>
            </div>
            <div>
              <label>ATR窗口(交易日)</label>
              <input id="rotAtrWindow" placeholder="空=同步动量回看" />
            </div>
            <div>
              <label>ATR倍数</label>
              <input id="rotAtrMult" value="2.0" />
            </div>
            <div id="rotAtrStepBox">
              <label>渐进步长(ATR)</label>
              <input id="rotAtrStep" value="0.5" />
            </div>
            <div id="rotAtrMinMultBox">
              <label>最小倍数(ATR)</label>
              <input id="rotAtrMinMult" value="0.5" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：止损价与触发均使用前复权(qfq)收盘价 close。触发后从下一交易日起空仓，直到下一次调仓。支持周/月/季/年等所有调仓周期（“上一周期/本周期”以调仓周期划分）。
          </div>
        </div>

        <div id="rotTabTiming" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>择时开关</label>
              <select id="rotTimingOn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>RSI窗口(交易日)</label>
              <select id="rotTimingRsiWin" style="min-width:160px;">
                <option value="6">6</option>
                <option value="12">12</option>
                <option value="24" selected>24</option>
              </select>
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            规则：当“策略净值 RSI” ≤ 50 时切换为等权持有（EW_REBAL），当 RSI &gt; 50 时重新激活轮动策略。<br/>
            重要：RSI 信号使用 <b>不考虑择时休眠</b> 的“假想净值（shadow NAV）”计算，避免“休眠导致RSI变形”的自我反馈问题；择时只改变实际持仓与净值。
          </div>
        </div>

        <div id="rotTabDD" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>回撤控制开关</label>
              <select id="rotDDOn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>触发回撤阈值 X%</label>
              <input id="rotDDThr" value="10" />
            </div>
            <div>
              <label>减仓比例 Y%</label>
              <input id="rotDDReduce" value="100" />
            </div>
            <div>
              <label>休眠天数(交易日)</label>
              <input id="rotDDSleep" value="20" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：以策略净值的峰值回撤为触发条件。触发后从下一交易日起将仓位按 (1 - Y) 缩放（Y=100% 则空仓），并在休眠期内保持上一日持仓（不再产生新的调仓决策），直至休眠结束后的下一次调仓。
            输入支持百分比（如 10 表示 10%）。
          </div>
        </div>

        <div class="row" style="margin-top:12px">
          <button id="runRotation">运行轮动回测</button>
        </div>
      </div>

      <div class="panel two" style="grid-template-columns: 1fr 1fr;">
        <div>
          <h3>净值曲线（轮动 vs 等权同频再平衡）</h3>
          <div id="rotChart" style="width:100%; height:520px;"></div>
          <h3 style="margin-top:12px">回撤对比（轮动 vs 等权）</h3>
          <div id="rotDDCompare" style="width:100%; height:260px;"></div>
        </div>
        <div>
          <h3>超额净值（轮动 / 等权）</h3>
          <div id="rotExcessChart" style="width:100%; height:520px;"></div>
          <h3 style="margin-top:12px">40日收益差（轮动 - 等权）</h3>
          <div id="rot40dDiffChart" style="width:100%; height:260px;"></div>
        </div>
      </div>

      <!-- RSI is overlaid on NAV/EXCESS charts (secondary axis) -->

      <div class="panel two" style="grid-template-columns: 1fr 1fr;">
        <div>
          <h3>轮动策略滚动收益&回撤（1/3/5年）</h3>
          <div id="rotRollingCombo" style="width:100%; height:520px;"></div>
        </div>
        <div>
          <h3>超额滚动收益&回撤（1/3/5年）</h3>
          <div id="rotExcessRollingCombo" style="width:100%; height:520px;"></div>
        </div>
      </div>

      <div class="panel two" style="grid-template-columns: 1fr 1fr;">
        <div>
          <h3>轮动策略指标</h3>
          <table id="rotMetrics"></table>
        </div>
        <div>
          <h3>轮动策略胜率赔率（按调仓周期）</h3>
          <table id="rotWinPayoff"></table>
        </div>
      </div>

      <div class="panel">
        <h3>轮动策略：各标的持仓周期长度分布（交易日）</h3>
        <div class="muted">统计每个标的在轮动策略中“实际被持有”的每段持仓区间长度（按交易日计数），并给出直方图与分位数。用于研究“持仓节奏/持有期长短”与回撤的关系。</div>
        <div class="row no-print" style="margin-top:8px; align-items:end;">
          <div>
            <label>选择标的</label>
            <select id="rotHoldLenCodeSelect" style="min-width:180px;"></select>
          </div>
        </div>
        <div id="rotHoldLenHist" style="width:100%; height:360px; margin-top:12px;"></div>
        <table id="rotHoldLenQuantiles" style="margin-top:12px;"></table>
      </div>

      <div class="panel">
        <h3>逐标的风控研究（自动搜索）→ 复合风控（等权/轮动）</h3>
        <div class="muted">先对每个标的做 buy&hold 的风控规则与参数搜索，形成“规则库”；再把规则库复合应用到等权组合与轮动策略上，比较风险调整后收益。</div>

        <div class="row no-print" style="margin-top:8px; align-items:end; flex-wrap: wrap; gap: 12px;">
          <div>
            <label>研究标的 <button class="helpBtn" data-metric="param_rc_asset" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <select id="rcAssetCode" style="min-width:180px;"></select>
          </div>
          <div>
            <label>目标函数 <button class="helpBtn" data-metric="param_rc_objective" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <select id="rcObjective" style="min-width:160px;">
              <option value="calmar_ratio" selected>最大化：卡玛</option>
              <option value="sharpe_ratio">最大化：夏普</option>
              <option value="min_mdd">最小化：|最大回撤|（绝对值更小更好）</option>
              <option value="calmar_minus_hit">卡玛 - λ·风险命中率</option>
              <option value="sharpe_minus_hit">夏普 - λ·风险命中率</option>
            </select>
          </div>
          <div>
            <label>风险权重λ <button class="helpBtn" data-metric="param_rc_lambda" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcLambda" value="1.0" style="min-width:90px;" title="用于把“风险事件命中率”纳入目标函数：score = Calmar(or Sharpe) - λ×hit。λ 越大越偏向降低风险事件发生概率。" />
          </div>
          <div>
            <label>风险事件阈值X% <button class="helpBtn" data-metric="param_rc_event_thr" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcEventThr" value="10" style="min-width:120px;" title="可输入单值或逗号集合（用于自动搜索）：例如 5,10,15。定义风险事件：未来H日最大回撤 ≥ X%。" />
          </div>
          <div>
            <label>未来窗口H(日) <button class="helpBtn" data-metric="param_rc_future_h" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcFutureH" value="20" style="min-width:120px;" title="可输入单值或逗号集合（用于自动搜索）：例如 10,20,40。在t时点观察信号后，统计未来H个交易日内的最大回撤。" />
          </div>
          <div>
            <label>K窗口集合(日) <button class="helpBtn" data-metric="param_rc_k_list" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcKList" value="10,20,40,60" style="min-width:140px;" title="信号回看窗口集合（逗号分隔）。例如K=20表示用过去20个交易日计算波动率/下行波动/回撤/收益等信号。用于网格搜索。" />
          </div>
          <div>
            <label>P集合(分位%) <button class="helpBtn" data-metric="param_rc_p_list" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcPList" value="70,80,90" style="min-width:140px;" title="触发阈值分位集合。对波动/下行波动/回撤：使用高分位(例如80%)触发降仓；对收益率信号：使用低分位触发（即会自动用 100-P 作为下尾分位）。" />
          </div>
          <div>
            <label>降仓Y集合(%) <button class="helpBtn" data-metric="param_rc_reduce_list" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcReduceList" value="25,50,75,100" style="min-width:160px;" title="降仓比例集合（逗号分隔）。触发时 exposure = 1 - Y%。例如Y=50表示降为50%仓位；Y=100表示清仓。" />
          </div>
          <div style="min-width:360px;">
            <label>候选信号 <button class="helpBtn" data-metric="param_rc_signals" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <div class="row" style="gap:10px; align-items:center;">
              <label style="display:flex; gap:6px; align-items:center; margin:0;" title="过去K日收益率的标准差（以日收益计算）。默认用高分位触发：波动越高越倾向降仓。"><input type="checkbox" class="rcSig" value="volatility" checked />波动率</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;" title="过去K日负收益的标准差（只看下跌日）。更贴近“下行风险”。默认用高分位触发。"><input type="checkbox" class="rcSig" value="downside_vol" checked />下行波动率</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;" title="过去K日从局部峰值到当前的回撤幅度（取正值）。回撤越大越倾向降仓，默认高分位触发。"><input type="checkbox" class="rcSig" value="drawdown" checked />回撤幅度</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;" title="过去K日收益率（nav_t/nav_{t-K}-1）。该信号使用低分位触发：越差越倾向降仓（会自动用 100-P 作为下尾分位）。"><input type="checkbox" class="rcSig" value="return" />收益率(低分位触发)</label>
            </div>
          </div>
          <div style="min-width:360px;">
            <label>恢复策略 <button class="helpBtn" data-metric="param_rc_recovery" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <div class="row" style="gap:10px; align-items:center;">
              <label style="display:flex; gap:6px; align-items:center; margin:0;" title="默认：不触发就立即恢复到100%。"><input type="checkbox" class="rcRec" value="immediate" checked />立即恢复</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;" title="滞回：触发用P_in，恢复用P_out（更宽松），可减少来回抖动。"><input type="checkbox" class="rcRec" value="hysteresis" checked />滞回恢复</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;" title="冷却期：触发后至少保持降仓N天，再允许恢复。"><input type="checkbox" class="rcRec" value="cooldown" checked />冷却期</label>
            </div>
          </div>
          <div>
            <label>P_out集合(分位%) <button class="helpBtn" data-metric="param_rc_pout_list" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcPOutList" value="50,60,70" style="min-width:140px;" title="仅用于“滞回恢复”。高尾信号：恢复阈值用更低分位（例如触发80%，恢复60%）；收益率低尾信号则相反（恢复用更高分位）。" />
          </div>
          <div>
            <label>冷却N集合(日) <button class="helpBtn" data-metric="param_rc_cooldown_list" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
            <input id="rcCooldownList" value="0,5,10,20" style="min-width:140px;" title="仅用于“冷却期”。触发后至少维持降仓N天（0表示不启用冷却）。" />
          </div>
          <button id="rcSearchOne" title="对当前标的执行网格搜索：遍历信号×K×P×降仓Y，按目标函数排序输出Top结果。">搜索当前标的</button>
          <button id="rcSearchAll" title="对所有候选标的一键搜索，并把每个标的的Top1写入规则库（可再逐个标的微调）。">搜索全部标的</button>
          <button id="rcApplyComposite" title="将规则库复合应用到等权与轮动：等权按权重漂移/周期再平衡模拟，轮动按持仓标的规则动态缩放收益暴露。">应用规则库→复合回测</button>
        </div>

        <div class="muted" style="margin-top:8px;">
          说明：信号阈值采用分位数（P%）。对“波动/下行波动/回撤”使用<b>高分位触发</b>；对“收益率”使用<b>低分位触发</b>（自动用 100-P 的下尾分位）。
          触发后从下一交易日起生效：exposure = 1 - Y%。本页的逐标的搜索基于等权分析返回的<b>全区间</b>单标的 NAV（buy&hold）。
        </div>

        <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:12px; align-items:start;">
          <div>
            <h4 style="margin:0 0 6px 0;">单标的：Top 搜索结果（buy&hold 风控）</h4>
            <div class="row no-print" style="gap:10px; align-items:center; margin:6px 0;">
              <label style="margin:0;">显示条数</label>
              <select id="rcAssetTopLimit" style="min-width:120px;" title="显示全部可能较慢（结果过多时建议先看前几百条）。">
                <option value="12" selected>前 12 条</option>
                <option value="50">前 50 条</option>
                <option value="200">前 200 条</option>
                <option value="all">全部</option>
              </select>
              <span class="muted" id="rcAssetTopCount"></span>
            </div>
            <table id="rcAssetTop"></table>
            <div id="rcAssetChart" style="width:100%; height:320px; margin-top:10px;"></div>
          </div>
          <div>
            <h4 style="margin:0 0 6px 0;">规则库（每个标的 1 条规则）</h4>
            <table id="rcRuleBook"></table>
            <div class="muted" style="margin-top:8px;">提示：先运行等权分析（上方“运行分析”）以获得各标的全区间序列；轮动复合回测需先运行轮动回测。</div>
          </div>
        </div>

        <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:14px;">
          <div>
            <h4 style="margin:0 0 6px 0;">等权：原策略 vs 复合风控</h4>
            <div id="ewRiskChart" style="width:100%; height:320px;"></div>
            <table id="ewRiskMetrics" style="margin-top:8px;"></table>
            <table id="ewRiskSignalTable" style="margin-top:8px;"></table>
          </div>
          <div>
            <h4 style="margin:0 0 6px 0;">轮动：原策略 vs 复合风控（按持仓标的规则）</h4>
            <div id="rotRiskChart" style="width:100%; height:320px;"></div>
            <table id="rotRiskMetrics" style="margin-top:8px;"></table>
            <table id="rotRiskSignalTable" style="margin-top:8px;"></table>
          </div>
        </div>
      </div>

      <div class="panel two" style="grid-template-columns: 1fr 1fr; align-items:start;">
        <div>
          <h3>收益贡献（轮动策略，全区间） <button class="helpBtn" data-metric="rot_return_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
          <table id="rotReturnContrib"></table>
        </div>
        <div>
          <h3>风险贡献（轮动策略，全区间） <button class="helpBtn" data-metric="rot_risk_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
          <table id="rotRiskContrib"></table>
        </div>
      </div>

      <div class="panel">
        <h3>轮动策略周期收益率（策略 none vs 基准 hfq）</h3>
        <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:8px">
          <div>
            <div class="muted">周度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotWeeklySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotWeeklySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotWeeklyPrev">上一页</button>
              <button id="rotWeeklyNext">下一页</button>
              <span class="muted" id="rotWeeklyPage"></span>
            </div>
            <table id="rotWeekly"></table>
          </div>
          <div>
            <div class="muted">月度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotMonthlySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotMonthlySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotMonthlyPrev">上一页</button>
              <button id="rotMonthlyNext">下一页</button>
              <span class="muted" id="rotMonthlyPage"></span>
            </div>
            <table id="rotMonthly"></table>
          </div>
        </div>
        <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:12px">
          <div>
            <div class="muted">季度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotQuarterlySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotQuarterlySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotQuarterlyPrev">上一页</button>
              <button id="rotQuarterlyNext">下一页</button>
              <span class="muted" id="rotQuarterlyPage"></span>
            </div>
            <table id="rotQuarterly"></table>
          </div>
          <div>
            <div class="muted">年度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotYearlySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotYearlySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotYearlyPrev">上一页</button>
              <button id="rotYearlyNext">下一页</button>
              <span class="muted" id="rotYearlyPage"></span>
            </div>
            <table id="rotYearly"></table>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>逐期对比（轮动 vs 等权）</h3>
        <div class="row" style="gap:8px; margin:6px 0;">
          <select id="rotPeriodSortKey" style="min-width:140px;">
            <option value="start">开始日期</option>
            <option value="end">结束日期</option>
            <option value="excess">超额收益</option>
          </select>
          <select id="rotPeriodSortDir" style="min-width:120px;">
            <option value="desc">递减</option>
            <option value="asc">递增</option>
          </select>
          <button id="rotPeriodPrev">上一页</button>
          <button id="rotPeriodNext">下一页</button>
          <span class="muted" id="rotPeriodPage"></span>
        </div>
        <table id="rotPeriods"></table>
      </div>

      <div class="panel">
        <h3>日历效应研究（轮动策略）</h3>
        <div class="muted">在保持轮动参数不变的前提下，批量回测不同调仓周期下的调仓锚点（周度/月度/季度/年度）与成交价口径（开盘/收盘/OC均价）对策略表现的影响。此处参数与等权研究互不影响。</div>
        <div class="row no-print" style="margin-top:8px; align-items:end;">
          <div>
            <label>开始日期（留空=沿用上方）</label>
            <input id="rotCalStart" placeholder="YYYYMMDD" />
          </div>
          <div>
            <label>结束日期（留空=沿用上方）</label>
            <input id="rotCalEnd" placeholder="YYYYMMDD" />
          </div>
          <div style="min-width:360px;">
            <label id="rotCalAnchorLabel">调仓锚点</label>
            <div id="rotCalAnchorBox"></div>
          </div>
        <div>
          <label>休市处理</label>
          <select id="rotCalShift" style="min-width:180px;">
            <option value="prev" selected>提前至上一交易日（默认）</option>
            <option value="next">顺延至下一交易日</option>
          </select>
        </div>
          <div style="min-width:260px;">
            <label>成交价口径</label>
            <div class="row" style="gap:10px; align-items:center;">
              <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="rotCalPx" value="open" checked />开盘</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="rotCalPx" value="close" checked />收盘</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="rotCalPx" value="oc2" checked />OC均价</label>
            </div>
          </div>
          <button id="runRotCalendar">运行（日历效应 轮动）</button>
        </div>
        <div id="rotCalHeatmap" style="width:100%; height:360px; margin-top:10px;"></div>
        <table id="rotCalTable" style="margin-top:6px;"></table>
        <div id="rotCalRollingChart" style="width:100%; height:360px; margin-top:12px;"></div>
        <table id="rotCalRollingStats" style="margin-top:6px;"></table>
      </div>

    <div class="panel">
        <h3>蒙特卡洛模拟（轮动策略）</h3>
        <div class="row">
          <div class="muted">使用与等权相同的模拟次数/区块长度/种子配置。</div>
          <button id="runMcRot">运行蒙特卡洛（轮动）</button>
        </div>
        <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
          <div>
            <div class="muted">策略本身</div>
            <table id="mcRotTable"></table>
            <div class="row" style="margin-top:8px">
              <label>直方图指标</label>
              <select id="mcRotMetric" style="min-width:220px;">
                <option value="cumulative_return">累积收益</option>
                <option value="annualized_return">年化收益</option>
                <option value="annualized_volatility">年化波动</option>
                <option value="max_drawdown">最大回撤</option>
                <option value="sharpe_ratio">夏普</option>
              </select>
            </div>
            <div id="mcRotHist" style="width:100%; height:420px;"></div>
            <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
              <div>
                <div class="muted">分布拟合结果（按 BIC 排序）</div>
                <table id="mcRotFitTable"></table>
              </div>
              <div>
                <div class="row" style="gap:8px">
                  <label>Q-Q 分布</label>
                  <select id="mcRotDist" style="min-width:180px;"></select>
                </div>
                <div id="mcRotQQ" style="width:100%; height:420px;"></div>
              </div>
            </div>
          </div>
          <div>
            <div class="muted">超额（轮动-等权）</div>
            <table id="mcExcessTable"></table>
            <div class="row" style="margin-top:8px">
              <label>直方图指标</label>
              <select id="mcExcessMetric" style="min-width:220px;">
                <option value="cumulative_return">累积收益</option>
                <option value="annualized_return">年化收益</option>
                <option value="annualized_volatility">年化波动</option>
                <option value="max_drawdown">最大回撤</option>
                <option value="sharpe_ratio">夏普</option>
              </select>
            </div>
            <div id="mcExcessHist" style="width:100%; height:420px;"></div>
            <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
              <div>
                <div class="muted">分布拟合结果（按 BIC 排序）</div>
                <table id="mcExcessFitTable"></table>
              </div>
              <div>
                <div class="row" style="gap:8px">
                  <label>Q-Q 分布</label>
                  <select id="mcExcessDist" style="min-width:180px;"></select>
                </div>
                <div id="mcExcessQQ" style="width:100%; height:420px;"></div>
              </div>
            </div>
          </div>
        </div>

        <div style="margin-top: 14px;">
          <div class="muted">
            逐期收益分布（蒙特卡洛模拟结果；按当前回测所选调仓频率聚合为“逐期”，并统计所有模拟路径上的逐期收益分布）
          </div>
        <div class="muted" style="margin-top:10px;">
          轮动策略持仓周期长度分布（Observed：基于当前轮动回测的持仓区间，按交易日计数）
        </div>
        <div class="row no-print" style="margin-top:6px; align-items:end;">
          <div>
            <label>选择标的</label>
            <select id="mcRotHoldLenCodeSelect" style="min-width:180px;"></select>
          </div>
        </div>
        <div id="mcRotHoldLenHist" style="width:100%; height:340px; margin-top:10px;"></div>
        <table id="mcRotHoldLenQuantiles" style="margin-top:10px;"></table>
          <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top: 8px;">
            <div>
              <div class="muted">策略逐期收益率（Period Return）</div>
              <table id="mcRotPeriodStats"></table>
              <div id="mcRotPeriodHist" style="width:100%; height:420px;"></div>
            </div>
            <div>
              <div class="muted">逐期超额收益率（轮动-等权）</div>
              <table id="mcExcessPeriodStats"></table>
              <div id="mcExcessPeriodHist" style="width:100%; height:420px;"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>趋势跟踪策略研究（单标的）</h3>
      <div class="muted">
        独立于等权组合与轮动策略。选择一个候选标的，回测常见趋势策略（长/空=长/现金），并与该标的买入持有对比指标与净值。
      </div>
      <div class="row no-print" style="margin-top:8px; align-items:end;">
        <div>
          <label>标的</label>
          <select id="trendCode" style="min-width:180px;"></select>
        </div>
        <div>
          <label>策略</label>
          <select id="trendStrategy" style="min-width:220px;">
            <option value="ma_filter" selected>均线过滤（收盘 &gt; SMA）</option>
            <option value="ema_filter">EMA过滤（收盘 &gt; EMA）</option>
            <option value="ma_cross">双均线交叉（SMA_fast &gt; SMA_slow）</option>
            <option value="donchian">唐奇安突破（入场/退出）</option>
            <option value="tsmom">时间序列动量（lookback收益&gt;0）</option>
            <option value="linreg_slope">回归斜率趋势（log价斜率&gt;0）</option>
            <option value="bias">乖离率趋势（BIAS 上升跟随：入场/过热止盈/过冷止损）</option>
          </select>
        </div>
        <div id="trendSmaBox">
          <label>SMA窗口</label>
          <input id="trendSmaWin" value="200" />
        </div>
        <div id="trendCrossBox">
          <label>快/慢均线</label>
          <div class="row" style="gap:8px; align-items:end;">
            <input id="trendFastWin" value="50" style="min-width:120px" />
            <input id="trendSlowWin" value="200" style="min-width:120px" />
          </div>
        </div>
        <div id="trendDonchianBox">
          <label>入场/退出窗口</label>
          <div class="row" style="gap:8px; align-items:end;">
            <input id="trendDonEntry" value="20" style="min-width:120px" />
            <input id="trendDonExit" value="10" style="min-width:120px" />
          </div>
        </div>
        <div id="trendMomBox">
          <label>动量回看(交易日)</label>
          <input id="trendMomLb" value="252" />
        </div>
        <div id="trendBiasBox">
          <label>乖离率参数</label>
          <div class="row" style="gap:8px; align-items:end;">
            <input id="trendBiasMA" value="20" style="min-width:90px" placeholder="EMA窗口" title="EMA(C,N)窗口(交易日)，用于 BIAS=(LN(C)-LN(EMA))*100" />
            <input id="trendBiasEntry" value="2" style="min-width:80px" placeholder="入场%" title="入场阈值(%)：BIAS > entry" />
            <input id="trendBiasHot" value="10" style="min-width:80px" placeholder="过热%" title="过热止盈阈值(%)：BIAS >= hot" />
            <input id="trendBiasCold" value="-2" style="min-width:80px" placeholder="过冷%" title="过冷止损阈值(%)：BIAS <= cold" />
            <select id="trendBiasPosMode" style="min-width:120px" title="仓位管理模式">
              <option value="binary" selected>0/1仓位</option>
              <option value="continuous">动态仓位</option>
            </select>
          </div>
        </div>
        <div>
          <label>交易成本(bps)</label>
          <input id="trendCost" value="0" />
        </div>
        <button id="runTrend">运行（趋势跟踪）</button>
      </div>
      <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:10px;">
        <div>
          <div class="muted">净值对比（策略 vs 买入持有）</div>
          <div id="trendChart" style="width:100%; height:420px;"></div>
        </div>
        <div>
          <div class="muted">回撤对比</div>
          <div id="trendDD" style="width:100%; height:420px;"></div>
        </div>
      </div>
      <table id="trendMetrics" style="margin-top:8px;"></table>
    </div>

    <div class="panel msg" id="msg"></div>

    <div id="metricModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45);">
      <div style="max-width:760px; margin:8vh auto; background:#fff; border-radius:10px; padding:16px 16px 12px 16px; box-shadow:0 10px 30px rgba(0,0,0,0.25);">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
          <div>
            <div id="metricModalTitle" style="font-weight:600; font-size:16px;"></div>
            <div id="metricModalSub" class="muted" style="margin-top:4px;"></div>
          </div>
          <button id="metricModalClose" style="padding:6px 10px;">关闭</button>
        </div>
        <div id="metricModalBody" style="margin-top:10px; line-height:1.55;"></div>
      </div>
    </div>

    <script>
      const api = (path, opts) => fetch(`/api${path}`, { headers: { "Content-Type": "application/json" }, ...opts });
      const $ = (id) => document.getElementById(id);
      const esc = (s) => String(s == null ? "" : s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");

      // Surface JS errors on the page (helps debug when charts fail to render due to a runtime exception).
      window.addEventListener("error", (e) => {
        try {
          const msg = `JS错误: ${e.message || e.error || "unknown"}\\n${e.filename || ""}:${e.lineno || ""}:${e.colno || ""}`;
          if ($("msg")) $("msg").textContent = msg;
        } catch { /* ignore */ }
      });
      window.addEventListener("unhandledrejection", (e) => {
        try {
          const msg = `Promise错误: ${String(e.reason || "unknown")}`;
          if ($("msg")) $("msg").textContent = msg;
        } catch { /* ignore */ }
      });

      function fmtPct(x) {
        if (x == null || Number.isNaN(x)) return "-";
        return (x * 100).toFixed(2) + "%";
      }
      function fmtNum(x) {
        if (x == null || Number.isNaN(x)) return "-";
        return Number(x).toFixed(4);
      }

      let pool = [];
      const selected = new Set();
      const ADJUST_USED = "hfq"; // baseline research currently uses hfq only
      const ANN_FACTOR = 252;

      const metricHelp = {
        benchmark_code: {
          title: "基准标的（benchmark_code）",
          sub: "用于信息比率（IR）的对比基准。",
          body: `
            <div><b>含义</b>：把“等权组合”的日收益与基准标的的日收益相减，得到主动收益（active return）。</div>
            <div style="margin-top:8px"><b>口径</b>：当前页面所有收益与指标均使用 <b>${ADJUST_USED}</b>（后复权）价格序列。</div>
          `,
        },
        rebalance: {
          title: "等权再平衡周期（rebalance）",
          sub: "决定等权组合的权重何时重置为等权。",
          body: `
            <div><b>含义</b>：等权组合在每个再平衡点将权重重置为等权（每个标的权重相同）。</div>
            <div style="margin-top:8px"><b>实现</b>：日度=每天重置；周/月/季/年=在对应周期边界重置；不平衡=等权买入持有（不再重置）。</div>
          `,
        },
        risk_free_rate: {
          title: "无风险收益率（risk_free_rate）",
          sub: "用于夏普比率与索诺提比率（年化）。默认 2.5%（长期中国0-1年国债）。",
          body: `
            <div><b>含义</b>：在风险调整收益指标中，从组合收益中扣除无风险收益。</div>
            <div style="margin-top:8px"><b>换算</b>：年化 rf 按日频近似换算为 rf/252。</div>
          `,
        },
        cumulative_return: {
          title: "累积收益率（cumulative_return）",
          sub: "区间内的总收益。",
          body: `
            <div><b>定义</b>：\\(R_{cum} = \\frac{NAV_T}{NAV_0} - 1\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：这里 NAV 为等权组合净值（起点=1）。</div>
          `,
        },
        annualized_return: {
          title: "年化收益率（annualized_return）",
          sub: "把区间收益折算为年化复利。",
          body: `
            <div><b>定义</b>：\\(R_{ann} = (\\frac{NAV_T}{NAV_0})^{\\frac{${ANN_FACTOR}}{N}} - 1\\)，其中 N 为区间交易日数（约）。</div>
            <div style="margin-top:8px"><b>注意</b>：这是基于交易日频率的折算，不等同于自然日年化。</div>
          `,
        },
        annualized_volatility: {
          title: "年化波动率（annualized_volatility）",
          sub: "日收益率标准差的年化。",
          body: `
            <div><b>定义</b>：\\(\\sigma_{ann} = \\sigma_{daily} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：\\(\\sigma_{daily}\\) 为日收益率的样本标准差（ddof=1）。</div>
          `,
        },
        max_drawdown: {
          title: "最大回撤（max_drawdown）",
          sub: "净值从历史峰值到后续低点的最大跌幅。",
          body: `
            <div><b>定义</b>：\\(MDD = \\min_t( \\frac{NAV_t}{\\max_{s\\le t} NAV_s} - 1 )\\)。</div>
            <div style="margin-top:8px"><b>取值</b>：通常为负数，越接近 0 越好。</div>
          `,
        },
        max_drawdown_recovery_days: {
          title: "最大回撤修复时长（max_drawdown_recovery_days）",
          sub: "最大回撤发生后，从峰值开始到再次创出新高的最长天数（用自然日计）。",
          body: `
            <div><b>定义</b>：沿时间轴跟踪“最新峰值日期”，在回撤区间内计算 (当前日期 - 峰值日期) 的最大值。</div>
            <div style="margin-top:8px"><b>说明</b>：这里按日期差（自然日）计算，非交易日数。</div>
          `,
        },
        sharpe_ratio: {
          title: "夏普比率（sharpe_ratio）",
          sub: "单位总波动的超额收益（相对无风险）。",
          body: `
            <div><b>定义（年化）</b>：\\(Sharpe = \\frac{\\mathbb{E}[r - rf/${ANN_FACTOR}]}{\\sigma(r - rf/${ANN_FACTOR})} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：r 为日收益率，rf 为年化无风险收益率。</div>
          `,
        },
        calmar_ratio: {
          title: "卡玛比率（calmar_ratio）",
          sub: "年化收益相对最大回撤（更偏向回撤风险）。",
          body: `
            <div><b>定义</b>：\\(Calmar = \\frac{R_{ann}}{|MDD|}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：当 MDD=0 时该值无意义。</div>
          `,
        },
        sortino_ratio: {
          title: "索诺提比率（sortino_ratio）",
          sub: "只用下行波动衡量风险的超额收益。",
          body: `
            <div><b>定义（年化）</b>：\\(Sortino = \\frac{\\mathbb{E}[r - rf/${ANN_FACTOR}]}{\\sigma(\\min(r - rf/${ANN_FACTOR}, 0))} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：只统计负的（下行）超额收益作为“下行风险”。</div>
          `,
        },
        information_ratio: {
          title: "信息比率（information_ratio）",
          sub: "单位跟踪误差的主动收益（相对基准）。",
          body: `
            <div><b>定义（年化）</b>：\\(IR = \\frac{\\mathbb{E}[r_p - r_b]}{\\sigma(r_p - r_b)} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：\\(r_p\\) 为组合日收益，\\(r_b\\) 为基准标的日收益。</div>
          `,
        },
        ulcer_index: {
          title: "溃疡指标（ulcer_index, UI）",
          sub: "衡量“持有体验”：惩罚回撤的深度与持续时间（只看水下部分）。",
          body: `
            <div><b>步骤</b>：先算回撤 \\(DD_t = \\frac{NAV_t}{\\max_{s\\le t} NAV_s} - 1\\)（≤0）。</div>
            <div style="margin-top:8px"><b>定义</b>：\\(UI = \\sqrt{\\frac{1}{T}\\sum (100\\cdot \\max(0,-DD_t))^2}\\)。</div>
            <div style="margin-top:8px"><b>单位</b>：当前实现返回“百分比点”的 RMS（例如 5.0 表示平均水下幅度约 5% 的 RMS）。</div>
          `,
        },
        ulcer_performance_index: {
          title: "溃疡绩效指标（ulcer_performance_index, UPI）",
          sub: "类似“收益/痛苦”：用超额年化收益除以 Ulcer Index。",
          body: `
            <div><b>定义</b>：\\(UPI = \\frac{R_{ann} - rf}{UI_{dec}}\\)，其中 \\(UI_{dec}=UI/100\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：rf 为年化无风险收益率；UI 越小、收益越高，UPI 越大。</div>
          `,
        },
        holding_weekly_win_rate: {
          title: "周度绝对胜率（holding_weekly_win_rate）",
          sub: "等权组合按周统计：周收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_week>0) / count(r_week)。</div>`,
        },
        holding_weekly_payoff_ratio: {
          title: "周度绝对赔率（holding_weekly_payoff_ratio）",
          sub: "等权组合按周统计：平均盈利周收益 / 平均亏损周收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_weekly_kelly_fraction: {
          title: "周度绝对凯利比（holding_weekly_kelly_fraction）",
          sub: "基于周度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b，其中 p=胜率，b=赔率。</div>`,
        },
        holding_monthly_win_rate: {
          title: "月度绝对胜率（holding_monthly_win_rate）",
          sub: "等权组合按月统计：月收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_month>0) / count(r_month)。</div>`,
        },
        holding_monthly_payoff_ratio: {
          title: "月度绝对赔率（holding_monthly_payoff_ratio）",
          sub: "等权组合按月统计：平均盈利月收益 / 平均亏损月收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_monthly_kelly_fraction: {
          title: "月度绝对凯利比（holding_monthly_kelly_fraction）",
          sub: "基于月度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。</div>`,
        },
        holding_quarterly_win_rate: {
          title: "季度绝对胜率（holding_quarterly_win_rate）",
          sub: "等权组合按季统计：季度收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_q>0) / count(r_q)。</div>`,
        },
        holding_quarterly_payoff_ratio: {
          title: "季度绝对赔率（holding_quarterly_payoff_ratio）",
          sub: "等权组合按季统计：平均盈利季度收益 / 平均亏损季度收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_quarterly_kelly_fraction: {
          title: "季度绝对凯利比（holding_quarterly_kelly_fraction）",
          sub: "基于季度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。</div>`,
        },
        holding_yearly_win_rate: {
          title: "年度绝对胜率（holding_yearly_win_rate）",
          sub: "等权组合按年统计：年度收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_y>0) / count(r_y)。</div>`,
        },
        holding_yearly_payoff_ratio: {
          title: "年度绝对赔率（holding_yearly_payoff_ratio）",
          sub: "等权组合按年统计：平均盈利年度收益 / 平均亏损年度收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_yearly_kelly_fraction: {
          title: "年度绝对凯利比（holding_yearly_kelly_fraction）",
          sub: "基于年度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。</div>`,
        },
        ew_return_contrib: {
          title: "收益贡献（等权组合）",
          sub: "把组合的总收益按标的拆分的归因结果。",
          body: `<div><b>方法</b>：按日用权重×log(1+r) 做收益归因，并按总收益缩放使各标的贡献之和等于组合总收益。</div><div style="margin-top:8px"><b>说明</b>：这是一个“可加”的近似归因方法，便于比较各标的对长期收益的贡献大小。</div>`,
        },
        ew_risk_contrib: {
          title: "风险贡献（等权组合）",
          sub: "把组合波动风险按标的拆分（方差贡献占比）。",
          body: `<div><b>方法</b>：用收益协方差矩阵 Σ 与平均权重 w̄，计算方差贡献：RC_i = w̄_i·(Σw̄)_i / (w̄'Σw̄)。</div>`,
        },
        rot_return_contrib: {
          title: "收益贡献（轮动策略）",
          sub: "把轮动策略的总收益按标的拆分的归因结果。",
          body: `<div><b>方法</b>：同等权组合，按日权重做 log 归因并缩放到总收益。</div><div style="margin-top:8px"><b>注意</b>：该贡献基于持仓收益（不把交易成本按标的拆分）。策略净值展示为扣成本后的结果。</div>`,
        },
        rot_risk_contrib: {
          title: "风险贡献（轮动策略）",
          sub: "轮动策略风险按标的拆分（方差贡献占比）。",
          body: `<div><b>方法</b>：与等权相同，使用全区间收益协方差与平均权重计算方差贡献占比。</div>`,
        },
        param_rot_rebalance: {
          title: "调仓频率（rebalance）",
          sub: "每隔多长时间重新选择 TopK 并调仓。",
          body: `
            <div><b>含义</b>：在日/周/月/季/年周期末根据动量重新排名，下一交易日开始按新持仓运行。</div>
            <div style="margin-top:8px"><b>用途</b>：控制换手与信号稳定性。频率越高换手越大，越低反应越慢。</div>
            <div style="margin-top:8px"><b>范围</b>：daily / weekly / monthly / quarterly / yearly。</div>
            <div style="margin-top:8px"><b>示例</b>：weekly 表示每周调仓；daily 表示每日调仓。</div>
          `,
        },
        param_rot_topk: {
          title: "TopK",
          sub: "每次调仓持有动量排名前 K 的标的（等权）。",
          body: `
            <div><b>含义</b>：K=1 表示单标的轮动；K>1 表示持有多标的等权组合。</div>
            <div style="margin-top:8px"><b>用途</b>：K 越大分散越强、波动更低，但动量暴露更弱。</div>
            <div style="margin-top:8px"><b>范围</b>：整数 ≥ 1，且不应超过可用标的数量。</div>
            <div style="margin-top:8px"><b>示例</b>：TopK=2 在 4 个标的池里会持有前 2 名等权。</div>
          `,
        },
        param_rot_lookback: {
          title: "动量回看（lookback_days）",
          sub: "动量收益计算的回看窗口（交易日）。",
          body: `
            <div><b>含义</b>：动量分数 = 过去回看窗口内的累计收益（可配合 skip_days 跳过最近段）。</div>
            <div style="margin-top:8px"><b>用途</b>：窗口越长更偏“长期趋势”，越短更偏“短期动量”。</div>
            <div style="margin-top:8px"><b>范围</b>：整数 ≥ 1。常用：63(3M)、126(6M)、252(12M)。</div>
            <div style="margin-top:8px"><b>示例</b>：252 表示约 1 年动量。</div>
          `,
        },
        param_rot_skip: {
          title: "跳过最近（skip_days）",
          sub: "计算动量时跳过最近 N 个交易日（常用于 12-1）。",
          body: `
            <div><b>含义</b>：动量分数用 \\(close_{t-skip}/close_{t-skip-lookback} - 1\\)。</div>
            <div style="margin-top:8px"><b>用途</b>：降低短期反转/噪声影响。</div>
            <div style="margin-top:8px"><b>范围</b>：整数 ≥ 0。常用：21（约 1 个月）。</div>
            <div style="margin-top:8px"><b>示例</b>：lookback=252 且 skip=21 即 12-1 动量。</div>
          `,
        },
        param_rot_cost: {
          title: "交易成本（cost_bps）",
          sub: "按换手率估算的成本（bps）。",
          body: `
            <div><b>含义</b>：每日换手率 \\(turnover=\\frac{1}{2}\\sum |w_t-w_{t-1}|\\)，成本=turnover×(bps/10000)，从当日收益中扣减。</div>
            <div style="margin-top:8px"><b>用途</b>：让回测更接近实盘，抑制过度换手策略。</div>
            <div style="margin-top:8px"><b>范围</b>：≥0。常见取值：2~10 bps（视品种/滑点假设）。</div>
            <div style="margin-top:8px"><b>示例</b>：cost_bps=5 表示每 100% 换手扣 0.05%。</div>
          `,
        },
        param_rot_riskoff: {
          title: "动量阈值开关（risk_off）",
          sub: "当动量不达标时不买入风险资产（进入空仓/现金）。",
          body: `
            <div><b>含义</b>：若当期最优动量 ≤ 动量阈值，则本期不买风险资产，进入<b>空仓(现金)</b>。</div>
            <div style="margin-top:8px"><b>用途</b>：当市场/标的动量不足时降低暴露，减少“下行趋势里硬上车”。</div>
            <div style="margin-top:8px"><b>范围</b>：true/false。</div>
            <div style="margin-top:8px"><b>示例</b>：开启 risk_off，floor=0（动量≤0 就空仓）。</div>
          `,
        },
        param_rot_floor: {
          title: "动量阈值（momentum_floor）",
          sub: "动量阈值触发条件（用动量分数判断）。",
          body: `
            <div><b>含义</b>：若最佳动量分数 ≤ 阈值，则本期进入<b>空仓(现金)</b>。</div>
            <div style="margin-top:8px"><b>用途</b>：控制“什么时候认为风险资产不值得持有/不应买入”。</div>
            <div style="margin-top:8px"><b>范围</b>：实数。常用：0（动量为负就避险）。</div>
            <div style="margin-top:8px"><b>重要</b>：需开启“动量阈值开关”。</div>
            <div style="margin-top:8px"><b>示例</b>：floor=0 表示只在动量为正时才持有风险资产。</div>
          `,
        },
        param_rot_score_method: {
          title: "打分方式（score_method）",
          sub: "决定“动量排序”用什么指标：偏向涨得猛 or 涨得稳。",
          body: `
            <div><b>raw_mom</b>：纯动量，score = close(t-skip)/close(t-skip-lookback) - 1。</div>
            <div style="margin-top:8px"><b>return_over_vol</b>：过去收益 / 过去波动率（年化）。偏向“涨得稳”。</div>
            <div style="margin-top:8px"><b>sharpe_mom</b>：看过去窗口内的 Sharpe（用 rf 作为无风险）。</div>
            <div style="margin-top:8px"><b>sortino_mom</b>：看过去窗口内的 Sortino（只惩罚下行波动）。</div>
            <div style="margin-top:8px"><b>说明</b>：这些打分只影响“排序与选标”，不改变成交价格口径/回测结算逻辑。</div>
          `,
        },
        param_rot_trend: {
          title: "趋势过滤（trend_filter）",
          sub: "用趋势条件决定是否允许进入风险资产（事前风控）。",
          body: `
            <div><b>逐标的</b>：对每个候选标的判断 close(qfq) 是否在 SMA(window) 之上；不满足的标的不会被买入。</div>
            <div style="margin-top:8px"><b>全市场(候选均值)</b>：对“候选池均值价格”做同样判断；若不满足，则本期不买风险资产（进入空仓/现金）。</div>
            <div style="margin-top:8px"><b>目的</b>：在下行趋势中减少错误入场，降低大回撤。</div>
          `,
        },
        param_rot_rsi: {
          title: "RSI过滤（rsi_filter）",
          sub: "用超买超卖指标决定是否允许买入（事前风控）。",
          body: `
            <div><b>含义</b>：RSI 是动量强弱指标（0~100）。</div>
            <div style="margin-top:8px"><b>默认</b>：只屏蔽超买（RSI&gt;70），避免追高；超卖是否屏蔽可扩展。</div>
            <div style="margin-top:8px"><b>目的</b>：减少在极端情绪位置买入导致的回撤风险。</div>
          `,
        },
        param_rot_vol: {
          title: "波动率监控（vol_monitor）",
          sub: "用历史波动率决定买入仓位（事前仓位控制）。",
          body: `
            <div><b>逻辑</b>：对每个买入标的计算年化实现波动率 vol；若 vol&gt;target，则仓位按 target/vol 比例缩小（剩余留现金）。</div>
            <div style="margin-top:8px"><b>硬阈值</b>：若 vol&gt;max，则该标的不买；如果全部都不买，则进入空仓/现金。</div>
            <div style="margin-top:8px"><b>目的</b>：在高波动阶段降低暴露，事前控制回撤。</div>
          `,
        },
        param_rot_chop: {
          title: "震荡过滤（chop_filter）",
          sub: "用 ER / ADX 识别震荡/盘整并过滤标的。",
          body: `
            <div><b>定义</b>：ER = |P_t-P_{t-n}| / Σ|ΔP|，接近 0 表示来回震荡，接近 1 表示更单边趋势。</div>
            <div style="margin-top:8px"><b>规则</b>：ER &lt; 阈值 ⇒ 认为震荡 ⇒ 本期不买该标的（从候选里剔除）。</div>
            <div style="margin-top:8px"><b>ADX</b>：趋势强度指标（0~100）。一般 ADX 越低越偏震荡；可用阈值如 20。</div>
            <div style="margin-top:8px"><b>规则</b>：ADX &lt; 阈值 ⇒ 认为震荡 ⇒ 本期不买该标的（从候选里剔除）。</div>
            <div style="margin-top:8px"><b>口径</b>：使用 <b>qfq（前复权）</b> close 序列计算。</div>
          `,
        },
        param_rc_asset: {
          title: "研究标的（逐标的风控）",
          sub: "选择要做 buy&hold 风控参数搜索的标的。",
          body: `
            <div><b>口径</b>：使用上方“运行分析（等权）”返回的全区间 NAV 序列（每个标的单独 buy&hold）。</div>
            <div style="margin-top:8px"><b>用途</b>：先为每个标的找到更适配的风控信号/窗口/阈值/降仓幅度，再把这些规则复合应用到等权组合与轮动策略。</div>
          `,
        },
        param_rc_objective: {
          title: "目标函数（自动搜索排序依据）",
          sub: "决定“最优策略/参数”按什么指标挑选。",
          body: `
            <div><b>最大化：卡玛</b>：优先降低回撤并保持收益（适合“以回撤为核心”的分控研究）。</div>
            <div style="margin-top:8px"><b>最大化：夏普</b>：偏向波动意义上的风险调整收益。</div>
            <div style="margin-top:8px"><b>最小化：最大回撤</b>：只追求回撤最小（可能显著牺牲收益）。</div>
          `,
        },
        param_rc_event_thr: {
          title: "风险事件阈值 X%",
          sub: "定义“未来回撤风险事件”，用于评价信号是否有前瞻性。",
          body: `
            <div><b>定义</b>：在每个时点 t，计算未来 H 个交易日内的最大回撤 \\(MDD_{t..t+H}\\)。若 \\(|MDD| \\ge X\\%\\)，视为“风险事件发生”。</div>
            <div style="margin-top:8px"><b>输出</b>：分位组表中的“事件命中率” = 该分位组里事件发生比例。</div>
            <div style="margin-top:8px"><b>输入</b>：支持百分比写法，例如 10 表示 10%。</div>
          `,
        },
        param_rc_future_h: {
          title: "未来窗口 H（日）",
          sub: "评价信号的前瞻窗口长度。",
          body: `
            <div><b>含义</b>：用来计算“未来 H 日最大回撤”和风险事件命中率。</div>
            <div style="margin-top:8px"><b>建议</b>：与实盘预警响应周期一致（例如想防“1个月内的大回撤”，可用 H≈20）。</div>
          `,
        },
        param_rc_k_list: {
          title: "K窗口集合（日）",
          sub: "信号回看窗口的候选集合（网格搜索用）。",
          body: `
            <div><b>含义</b>：信号在 t 时点只用过去 K 个交易日数据计算，例如波动率=过去K日收益标准差。</div>
            <div style="margin-top:8px"><b>建议</b>：可覆盖短/中/长三档，例如 10/20/60，观察最优参数是否稳定。</div>
          `,
        },
        param_rc_p_list: {
          title: "P集合（分位%）",
          sub: "用历史分位确定触发阈值（网格搜索用）。",
          body: `
            <div><b>高分位触发</b>：对“波动/下行波动/回撤”，当信号 ≥ P 分位阈值时触发降仓。</div>
            <div style="margin-top:8px"><b>低分位触发</b>：对“收益率”信号，使用下尾分位触发（自动用 100-P 分位）。</div>
            <div style="margin-top:8px"><b>示例</b>：P=80：波动信号用 80% 分位触发；收益率信号用 20% 分位触发。</div>
          `,
        },
        param_rc_reduce_list: {
          title: "降仓 Y集合（%）",
          sub: "触发时把仓位缩放到 (1-Y) 的候选集合。",
          body: `
            <div><b>规则</b>：触发后从下一交易日起 exposure = 1 - Y%。</div>
            <div style="margin-top:8px"><b>示例</b>：Y=50 ⇒ 50%仓位；Y=100 ⇒ 清仓。</div>
          `,
        },
        param_rc_signals: {
          title: "候选信号（逐标的风控）",
          sub: "决定“何时认为风险升高，需要降仓”。",
          body: `
            <div><b>波动率</b>：过去K日收益标准差（高分位触发）。</div>
            <div style="margin-top:6px"><b>下行波动率</b>：过去K日负收益标准差（高分位触发，更关注下跌日）。</div>
            <div style="margin-top:6px"><b>回撤幅度</b>：过去K日从局部峰值到当前的回撤（取正值，高分位触发）。</div>
            <div style="margin-top:6px"><b>收益率</b>：过去K日累计收益（低分位触发，越差越降仓）。</div>
            <div style="margin-top:8px"><b>提示</b>：同一标的可能对不同信号敏感度不同（例如商品/成长/债券），因此需要逐标的搜索最优规则。</div>
          `,
        },
        param_rc_lambda: {
          title: "风险权重 λ",
          sub: "把“风险事件命中率”纳入目标函数时的权重。",
          body: `
            <div><b>用途</b>：当目标函数选“卡玛 - λ·风险命中率”或“夏普 - λ·风险命中率”时生效。</div>
            <div style="margin-top:8px"><b>含义</b>：λ 越大，越偏向选择“风险事件命中率更低”的参数组合（可能牺牲收益/卡玛）。</div>
          `,
        },
        param_rc_recovery: {
          title: "恢复策略（触发后何时回到满仓）",
          sub: "决定降仓后何时/如何恢复仓位（避免抖动是关键）。",
          body: `
            <div><b>立即恢复</b>：只要信号不再触发，就在下一交易日恢复到 100%。简单但容易来回切换。</div>
            <div style="margin-top:8px"><b>滞回恢复</b>：触发用 P_in，恢复用更宽松的 P_out（不同阈值），可显著减少抖动。</div>
            <div style="margin-top:8px"><b>冷却期</b>：触发后至少保持降仓 N 天，N 天后再允许恢复（用于过滤短期噪声）。</div>
          `,
        },
        param_rc_pout_list: {
          title: "P_out集合（分位%）",
          sub: "滞回恢复的“恢复阈值”候选集合。",
          body: `
            <div><b>高尾信号</b>（波动/下行波动/回撤）：触发阈值 P_in 较高（如80%），恢复阈值 P_out 应更低（如60%）。</div>
            <div style="margin-top:8px"><b>低尾信号</b>（收益率）：触发用低尾（内部用 100-P_in），恢复则用更高的 P_out（内部用 100-P_out）。</div>
            <div style="margin-top:8px"><b>建议</b>：先用 P_out=50/60/70 三档观察是否稳定。</div>
          `,
        },
        param_rc_cooldown_list: {
          title: "冷却 N集合（日）",
          sub: "冷却期恢复的“最短维持天数”候选集合。",
          body: `
            <div><b>含义</b>：触发后至少维持降仓 N 个交易日，期间即便信号回落也不立即恢复。</div>
            <div style="margin-top:8px"><b>建议</b>：0/5/10/20 四档起步，避免参数空间过大。</div>
          `,
        },
        rot_cum: {
          title: "策略累积收益",
          sub: "轮动策略净值（none）在回测区间的总收益。",
          body: `<div><b>计算</b>：NAV_T/NAV_0 - 1（已扣换手成本）。</div><div style="margin-top:8px"><b>口径</b>：轮动净值使用 none（不复权）。</div>`,
        },
        rot_ann: {
          title: "策略年化收益",
          sub: "把轮动净值区间收益折算为年化复利。",
          body: `<div><b>计算</b>：与基准分析一致，按交易日近似年化。</div>`,
        },
        rot_vol: {
          title: "策略年化波动",
          sub: "轮动策略日收益波动的年化。",
          body: `<div><b>计算</b>：σ_daily×√252。</div>`,
        },
        rot_mdd: {
          title: "策略最大回撤",
          sub: "轮动策略净值从峰值到低点的最大跌幅。",
          body: `<div><b>计算</b>：min(NAV/peak-1)。</div>`,
        },
        rot_sharpe: {
          title: "策略夏普",
          sub: "基于日收益与无风险收益率的风险调整收益（年化）。",
          body: `<div><b>计算</b>：Sharpe = mean(r-rf/252)/std(r-rf/252)×√252。</div>`,
        },
        rot_sortino: {
          title: "策略索诺提",
          sub: "只用下行波动衡量风险的风险调整收益（年化）。",
          body: `<div><b>计算</b>：Sortino = mean(r-rf/252)/std(min(r-rf/252,0))×√252。</div>`,
        },
        rot_ui: {
          title: "策略溃疡指标(UI)",
          sub: "衡量持有体验：惩罚回撤深度与持续时间。",
          body: `<div><b>计算</b>：回撤水下百分比的 RMS（与基准分析一致）。</div>`,
        },
        rot_upi: {
          title: "策略溃疡绩效(UPI)",
          sub: "收益/痛苦：用(年化收益-rf)除以 UI。",
          body: `<div><b>计算</b>：UPI=(R_ann-rf)/(UI/100)。</div>`,
        },
        rot_turnover: {
          title: "平均日换手",
          sub: "反映交易频率与成本敏感度。",
          body: `<div><b>计算</b>：turnover=0.5×Σ|w_t-w_{t-1}| 的日均值。</div>`,
        },
        rot_excess_cum: {
          title: "超额累积收益",
          sub: "轮动(none,net) 相对 等权(hfq,同频再平衡) 的总超额。",
          body: `<div><b>计算</b>：active_ret = r_rot(none,net) - r_ew(hfq,rebal)；EXCESS 为其累积净值。</div>`,
        },
        rot_excess_ann: {
          title: "超额年化收益",
          sub: "超额净值的年化。",
          body: `
            <div><b>推荐口径(几何/CAGR)</b>：把超额看作一个“可复利”的相对财富过程。</div>
            <div style="margin-top:6px"><b>计算</b>：EXCESS = ROTATION / EW_REBAL；annual_excess_geo = CAGR(EXCESS)。</div>
            <div style="margin-top:6px" class="muted">提示：几何口径与长期复合增长一致，适合作为“策略相对基准的复合年化”。</div>
          `,
        },
        rot_excess_ann_arith: {
          title: "超额年化收益(算术)",
          sub: "主动收益序列的年化期望近似（不是复合增长率）。",
          body: `
            <div><b>口径(算术)</b>：把超额定义为“主动收益序列”active_ret = r_rot - r_ew。</div>
            <div style="margin-top:6px"><b>计算</b>：annual_excess_arith = mean(active_ret) × 252。</div>
            <div style="margin-top:6px" class="muted">提示：该值更像“每年平均多赚多少百分点”的统计量，不等价于 EXCESS 净值的 CAGR。</div>
          `,
        },
        rot_ir: {
          title: "超额信息比率(近似)",
          sub: "用主动收益序列的 Sharpe 形式近似信息比率。",
          body: `<div><b>计算</b>：IR ≈ mean(active)/std(active)×√252。</div>`,
        },
        rot_wp_win: {
          title: "胜率",
          sub: "按调仓周期统计，策略超额收益>0 的比例。",
          body: `<div><b>计算</b>：胜率=胜场数/期数；每期超额=期收益(轮动)-期收益(等权)。</div>`,
        },
        rot_wp_payoff: {
          title: "赔率(盈/亏)",
          sub: "平均盈利超额 / 平均亏损超额(绝对值)。",
          body: `<div><b>计算(算术)</b>：payoff=mean(excess|>0)/abs(mean(excess|<0))。</div>`,
        },
        rot_wp_payoff_geo: {
          title: "赔率(盈/亏,几何)",
          sub: "几何平均盈利超额 / 几何平均亏损超额(绝对值)。",
          body: `<div><b>计算(几何)</b>：gm(r)=exp(mean(log(1+r)))-1；payoff_geo=gm(excess|>0)/abs(gm(excess|<0))。</div>`,
        },
        rot_wp_avg_win: {
          title: "平均盈利(超额)",
          sub: "所有胜出期（超额>0）的超额收益均值。",
          body: `<div><b>计算(算术)</b>：mean(excess_return | excess_return>0)。</div>`,
        },
        rot_wp_avg_win_geo: {
          title: "平均盈利(超额,几何)",
          sub: "所有胜出期（超额>0）的超额收益几何均值。",
          body: `<div><b>计算(几何)</b>：gm(excess_return | >0)=exp(mean(log(1+excess_return)))-1。</div>`,
        },
        rot_wp_avg_loss: {
          title: "平均亏损(超额)",
          sub: "所有亏损期（超额<0）的超额收益均值（为负数）。",
          body: `<div><b>计算(算术)</b>：mean(excess_return | excess_return<0)。展示为负值。</div>`,
        },
        rot_wp_avg_loss_geo: {
          title: "平均亏损(超额,几何)",
          sub: "所有亏损期（超额<0）的超额收益几何均值（为负数）。",
          body: `<div><b>计算(几何)</b>：gm(excess_return | <0)=exp(mean(log(1+excess_return)))-1（要求每期收益>-100%）。</div>`,
        },
        rot_wp_kelly: {
          title: "凯利比(近似)",
          sub: "基于胜率 p 与赔率 b 的二项近似最优仓位比例。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。仅作参考，实盘通常会折扣（如 0.5×凯利）。</div>`,
        },
        rot_abs_win: {
          title: "绝对胜率",
          sub: "按调仓周期统计，策略每期收益>0 的比例（不与基准比较）。",
          body: `<div><b>计算</b>：胜率=期收益(轮动)>0 的期数 / 总期数。</div>`,
        },
        rot_abs_payoff: {
          title: "绝对赔率(盈/亏)",
          sub: "策略自身：平均盈利期收益 / 平均亏损期收益(绝对值)。",
          body: `<div><b>计算(算术)</b>：payoff_abs=mean(r|r>0)/abs(mean(r|r<0))。</div>`,
        },
        rot_abs_payoff_geo: {
          title: "绝对赔率(盈/亏,几何)",
          sub: "策略自身：几何平均盈利期收益 / 几何平均亏损期收益(绝对值)。",
          body: `<div><b>计算(几何)</b>：gm(r)=exp(mean(log(1+r)))-1；payoff_abs_geo=gm(r|>0)/abs(gm(r|<0))。</div>`,
        },
        rot_abs_avg_win: {
          title: "绝对平均盈利(算术)",
          sub: "所有盈利期（期收益>0）的收益算术均值。",
          body: `<div><b>计算</b>：mean(r | r>0)。</div>`,
        },
        rot_abs_avg_loss: {
          title: "绝对平均亏损(算术)",
          sub: "所有亏损期（期收益<0）的收益算术均值（为负数）。",
          body: `<div><b>计算</b>：mean(r | r<0)。展示为负值。</div>`,
        },
        rot_abs_avg_win_geo: {
          title: "绝对平均盈利(几何)",
          sub: "所有盈利期（期收益>0）的收益几何均值。",
          body: `<div><b>计算</b>：gm(r | r>0)=exp(mean(log(1+r)))-1。</div>`,
        },
        rot_abs_avg_loss_geo: {
          title: "绝对平均亏损(几何)",
          sub: "所有亏损期（期收益<0）的收益几何均值（为负数）。",
          body: `<div><b>计算</b>：gm(r | r<0)=exp(mean(log(1+r)))-1（要求每期收益>-100%）。</div>`,
        },
        rot_abs_kelly: {
          title: "绝对凯利比(近似)",
          sub: "基于绝对胜率与绝对赔率的二项近似最优仓位比例。",
          body: `<div><b>计算</b>：f*_abs = p_abs - (1-p_abs)/b_abs。</div>`,
        },
        mc_col_metric: {
          title: "指标",
          sub: "蒙特卡洛模拟输出的指标名称。",
          body: `<div><b>说明</b>：每行对应一个绩效指标（如累积收益、年化收益、最大回撤等）。</div>`,
        },
        mc_col_observed: {
          title: "Observed",
          sub: "原始样本（真实历史序列）计算出的指标值。",
          body: `<div><b>说明</b>：用回测区间内的原始日收益序列直接计算得到的“观测值”。</div>`,
        },
        mc_col_mean: {
          title: "Mean",
          sub: "蒙特卡洛模拟得到的指标均值。",
          body: `<div><b>说明</b>：对多次重采样路径分别计算指标后取平均。</div>`,
        },
        mc_col_p05: {
          title: "P05",
          sub: "指标分布的 5% 分位数。",
          body: `<div><b>说明</b>：有约 5% 的模拟结果低于该值（经验分位数）。</div>`,
        },
        mc_col_p50: {
          title: "P50",
          sub: "指标分布的 50% 分位数（中位数）。",
          body: `<div><b>说明</b>：把所有模拟结果从小到大排序后居中的值。</div>`,
        },
        mc_col_p95: {
          title: "P95",
          sub: "指标分布的 95% 分位数。",
          body: `<div><b>说明</b>：有约 95% 的模拟结果低于该值。</div>`,
        },
        mc_col_p_le_0: {
          title: "P(r≤0)",
          sub: "该指标在模拟下“≤0”的比例（经验概率）。",
          body: `<div><b>说明</b>：统计模拟样本里指标 ≤ 0 的占比。例如对累积收益/年化收益，这可近似理解为“亏损概率”。</div>`,
        },
      };

      function renderMcTable(elId, mc) {
        const el = $(elId);
        const header =
          `<tr>
            <th>指标 <button class="helpBtn" data-metric="mc_col_metric" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>Observed <button class="helpBtn" data-metric="mc_col_observed" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>Mean <button class="helpBtn" data-metric="mc_col_mean" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P05 <button class="helpBtn" data-metric="mc_col_p05" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P50 <button class="helpBtn" data-metric="mc_col_p50" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P95 <button class="helpBtn" data-metric="mc_col_p95" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P(r≤0) <button class="helpBtn" data-metric="mc_col_p_le_0" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
          </tr>`;
        if (!mc || !mc.metrics) {
          el.innerHTML = header;
          return;
        }
        const order = ["cumulative_return", "annualized_return", "annualized_volatility", "max_drawdown", "sharpe_ratio"];
        const rows = order.filter(k => mc.metrics[k]).map(k => ({ k, v: mc.metrics[k] }));
        const label = {
          cumulative_return: "累积收益",
          annualized_return: "年化收益",
          annualized_volatility: "年化波动",
          max_drawdown: "最大回撤",
          sharpe_ratio: "夏普",
        };
        const fmt = (k, x) => {
          if (x == null || Number.isNaN(x)) return "-";
          if (k.includes("drawdown")) return fmtPct(Number(x));
          if (k.includes("volatility")) return fmtPct(Number(x));
          if (k.includes("return")) return fmtPct(Number(x));
          return Number(x).toFixed(4);
        };
        el.innerHTML =
          header +
          rows.map(({k, v}) => `<tr><td>${label[k] || k}</td><td>${fmt(k, v.observed)}</td><td>${fmt(k, v.mean)}</td><td>${fmt(k, v.p05)}</td><td>${fmt(k, v.p50)}</td><td>${fmt(k, v.p95)}</td><td>${(v.p_value_le_0==null||Number.isNaN(v.p_value_le_0))? "-" : (Number(v.p_value_le_0)*100).toFixed(2)+"%"}</td></tr>`).join("");
      }

      function plotMcHist(divId, mc, metricKey) {
        const el = $(divId);
        if (!mc || !mc.metrics || !mc.metrics[metricKey] || !mc.metrics[metricKey].hist) {
          el.innerHTML = "<div class='muted'>无直方图数据</div>";
          return;
        }
        const h = mc.metrics[metricKey].hist;
        const edges = h.bin_edges || [];
        const counts = h.counts || [];
        if (edges.length < 2 || counts.length < 1) {
          el.innerHTML = "<div class='muted'>无直方图数据</div>";
          return;
        }
        const x = [];
        for (let i = 0; i < counts.length; i++) x.push((edges[i] + edges[i + 1]) / 2);
        const isPct = metricKey.includes("return") || metricKey.includes("volatility") || metricKey.includes("drawdown");
        const fmtX = isPct ? ".0%" : ".4f";
        Plotly.newPlot(
          divId,
          [{
            x,
            y: counts,
            type: "bar",
            marker: { color: "#4c78a8" },
            hovertemplate: isPct ? "%{x:.2%}<br>count=%{y}<extra></extra>" : "%{x:.4f}<br>count=%{y}<extra></extra>",
          }],
          {
            margin: { t: 20 },
            xaxis: { tickformat: fmtX, title: metricKey },
            yaxis: { title: "count" },
            annotations: [
              {
                xref: "paper",
                yref: "paper",
                x: 0.01,
                y: 0.98,
                showarrow: false,
                text: `under=${h.underflow||0}, over=${h.overflow||0}`,
                font: { size: 12, color: "#666" },
              },
            ],
          },
          { responsive: true }
        );
      }

      function _renderPeriodDistTable(elId, dist) {
        const el = $(elId);
        if (!el) return;
        if (!dist || !dist.simulated) {
          el.innerHTML = "<tr><th>来源</th><th>样本数</th><th>均值</th><th>Std</th><th>P10</th><th>P50</th><th>P90</th><th>正收益占比</th><th>最小</th><th>最大</th></tr>";
          return;
        }
        const f = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtPct(Number(x));
        const n = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : String(x);
        const row = (tag, st) =>
          `<tr><td>${tag}</td><td>${n(st.count)}</td><td>${f(st.mean)}</td><td>${f(st.std)}</td><td>${f(st.p10)}</td><td>${f(st.p50)}</td><td>${f(st.p90)}</td><td>${f(st.pos_ratio)}</td><td>${f(st.min)}</td><td>${f(st.max)}</td></tr>`;
        el.innerHTML =
          "<tr><th>来源</th><th>样本数</th><th>均值</th><th>Std</th><th>P10</th><th>P50</th><th>P90</th><th>正收益占比</th><th>最小</th><th>最大</th></tr>" +
          row("Observed", dist.observed || {}) +
          row("Simulated", dist.simulated || {});
      }

      function _plotPeriodDistHist(divId, dist, title, color) {
        const el = $(divId);
        if (!el) return;
        if (!dist || !dist.hist || !dist.hist.bin_edges || dist.hist.bin_edges.length < 2) {
          el.innerHTML = "<div class='muted'>无直方图数据（请先运行一次蒙特卡洛：轮动）</div>";
          return;
        }
        const h = dist.hist;
        const edges = h.bin_edges || [];
        const counts = h.counts || [];
        const x = [];
        for (let i = 0; i < counts.length; i++) x.push((edges[i] + edges[i + 1]) / 2);
        Plotly.newPlot(
          divId,
          [{
            x,
            y: counts,
            type: "bar",
            marker: { color: color || "#4c78a8" },
            hovertemplate: "%{x:.2%}<br>count=%{y}<extra></extra>",
          }],
          {
            margin: { t: 26 },
            title: { text: title || "", font: { size: 13 } },
            xaxis: { tickformat: ".2%", title: "" },
            yaxis: { title: "count" },
            annotations: [
              {
                xref: "paper",
                yref: "paper",
                x: 0.01,
                y: 0.98,
                showarrow: false,
                text: `under=${h.underflow||0}, over=${h.overflow||0} · freq=${dist.freq||"-"}`,
                font: { size: 12, color: "#666" },
              },
            ],
            shapes: [
              { type: "line", xref: "x", yref: "paper", x0: 0, x1: 0, y0: 0, y1: 1, line: { color: "#999", width: 1, dash: "dot" } },
            ],
          },
          { responsive: true }
        );
      }

      function renderFit(prefix, mc, metricKey) {
        const fitTable = $(`mc${prefix}FitTable`);
        const distSel = $(`mc${prefix}Dist`);
        const qqDiv = `mc${prefix}QQ`;
        if (!fitTable || !distSel) return;
        if (!mc || !mc.metrics || !mc.metrics[metricKey] || !mc.metrics[metricKey].fit) {
          fitTable.innerHTML = "<tr><th>分布</th><th>BIC</th><th>AIC</th><th>KS p</th><th>AD</th></tr>";
          distSel.innerHTML = "";
          $(qqDiv).innerHTML = "<div class='muted'>无拟合数据</div>";
          return;
        }
        const fit = mc.metrics[metricKey].fit;
        const cands = fit.candidates || [];
        const rows = [];
        for (const d of cands) {
          const r = (fit.dists && fit.dists[d]) ? fit.dists[d] : null;
          if (!r || !r.ok) continue;
          rows.push({ d, bic: r.bic, aic: r.aic, ksp: r.ks ? r.ks.p_value : null, ad: r.ad ? r.ad.stat : null });
        }
        rows.sort((a,b) => Number(a.bic) - Number(b.bic));
        fitTable.innerHTML =
          "<tr><th>分布</th><th>BIC</th><th>AIC</th><th>KS p</th><th>AD</th></tr>" +
          rows.map(r => `<tr><td>${r.d}</td><td>${Number(r.bic).toFixed(2)}</td><td>${Number(r.aic).toFixed(2)}</td><td>${r.ksp==null? "-" : Number(r.ksp).toFixed(4)}</td><td>${r.ad==null? "-" : Number(r.ad).toFixed(2)}</td></tr>`).join("");

        // dist selector
        distSel.innerHTML = "";
        for (const r of rows) {
          const opt = document.createElement("option");
          opt.value = r.d;
          opt.textContent = r.d + (r.d === fit.best_by_bic ? "（BIC最优）" : "");
          distSel.appendChild(opt);
        }
        if (fit.best_by_bic) distSel.value = fit.best_by_bic;

        const plotQQ = () => {
          const d = distSel.value;
          const qq = fit.qq && fit.qq[d] ? fit.qq[d] : null;
          const el = $(qqDiv);
          if (!qq || !qq.emp || qq.emp.length === 0) {
            el.innerHTML = "<div class='muted'>无 Q-Q 数据</div>";
            return;
          }
          const x = qq.theory;
          const y = qq.emp;
          const minv = Math.min(...x, ...y);
          const maxv = Math.max(...x, ...y);
          Plotly.newPlot(
            qqDiv,
            [
              { x, y, mode: "markers", type: "scatter", name: "Q-Q", marker: { size: 6, color: "#4c78a8" }, hovertemplate: "theory=%{x:.4f}<br>emp=%{y:.4f}<extra></extra>" },
              { x: [minv, maxv], y: [minv, maxv], mode: "lines", name: "y=x", line: { dash: "dot", color: "#999" }, hoverinfo: "skip" },
            ],
            { margin: { t: 20 }, xaxis: { title: "theoretical quantile" }, yaxis: { title: "empirical quantile" } },
            { responsive: true }
          );
        };
        distSel.onchange = plotQQ;
        plotQQ();
      }

      let lastMcEw = null;
      let lastMcRot = null;
      let lastMcExcess = null;

      // ---------------- Mini-program fixed rotation (weekly5-open) ----------------
      const mpRotState = { anchor: "mix", rangeKey: "all", wideCache: null };
      const MP_RANGE_MAP = {
        "1m": { label: "近一月", days: 21 },
        "3m": { label: "近三月", days: 63 },
        "6m": { label: "近半年", days: 126 },
        "1y": { label: "近一年", days: 252 },
        "3y": { label: "近三年", days: 756 },
        "5y": { label: "近五年", days: 1260 },
        "10y": { label: "近十年", days: 2520 },
        "all": { label: "全区间", days: null },
      };
      function _ymd(dIso) { return String(dIso || "").split("-").join(""); }
      function _todayYmd() {
        const d = new Date();
        return `${d.getFullYear()}${String(d.getMonth()+1).padStart(2,"0")}${String(d.getDate()).padStart(2,"0")}`;
      }
      function _mpRotSetAnchor(a) {
        mpRotState.anchor = String(a);
        const keys = ["mix", "0", "1", "2", "3", "4"];
        for (const k of keys) {
          const el = $(`mpRotA_${k}`);
          if (!el) continue;
          el.style.fontWeight = (k === mpRotState.anchor) ? "700" : "400";
          el.style.borderColor = (k === mpRotState.anchor) ? "#444" : "#bbb";
        }
        $("mpRotAnchorHint").textContent = (mpRotState.anchor === "mix") ? "MIX=周一~周五等权运营组合" : "";
      }
      function _mpRotSetStatus(s) { if ($("mpRotStatus")) $("mpRotStatus").textContent = s || ""; }
      function _pickRange(datesIso, key) {
        const ds = (datesIso || []).slice();
        if (!ds.length) return { startIso: null, endIso: null, label: "-" };
        const cfg = MP_RANGE_MAP[key] || MP_RANGE_MAP.all;
        if (!cfg.days) return { startIso: ds[0], endIso: ds[ds.length - 1], label: cfg.label };
        const i0 = Math.max(0, ds.length - cfg.days);
        return { startIso: ds[i0], endIso: ds[ds.length - 1], label: cfg.label };
      }

      async function runMiniRotationToMain() {
        const btn = $("runMpRot");
        const oldTxt = btn ? btn.textContent : "";
        if (btn) { btn.disabled = true; btn.textContent = "加载中..."; }
        _mpRotSetStatus("加载中...");
        setMsg("");
        try {
          const end0 = _todayYmd();
          const start0 = "20000101";
          const isMix = (mpRotState.anchor === "mix");
          // Stage-1: lite wide range to get date axis for range slicing
          const litePath = isMix ? "/analysis/rotation/weekly5-open-combo-lite" : "/analysis/rotation/weekly5-open-lite";
          const fullPath = isMix ? "/analysis/rotation/weekly5-open-combo" : "/analysis/rotation/weekly5-open";
          const liteReq = isMix
            ? { start: start0, end: end0, asset_rc_rules: (() => {
              const rb = window.__riskRuleBook || {};
              const out = [];
              for (const [code, r] of Object.entries(rb)) {
                if (!r) continue;
                out.push({
                  code,
                  sig_type: r.sigType,
                  k: Number(r.k),
                  p_in: Number(r.p),
                  reduce_pct: Number(r.reduce),
                  recovery_mode: r.recoveryMode || "immediate",
                  p_out: (r.pOut == null ? null : Number(r.pOut)),
                  cooldown_days: Number(r.cooldownDays || 0),
                });
              }
              return out.length ? out : null;
            })() }
            : { start: start0, end: end0, anchor_weekday: Number(mpRotState.anchor), asset_rc_rules: (() => {
              const rb = window.__riskRuleBook || {};
              const out = [];
              for (const [code, r] of Object.entries(rb)) {
                if (!r) continue;
                out.push({
                  code,
                  sig_type: r.sigType,
                  k: Number(r.k),
                  p_in: Number(r.p),
                  reduce_pct: Number(r.reduce),
                  recovery_mode: r.recoveryMode || "immediate",
                  p_out: (r.pOut == null ? null : Number(r.pOut)),
                  cooldown_days: Number(r.cooldownDays || 0),
                });
              }
              return out.length ? out : null;
            })() };
          const respLite = await api(litePath, { method: "POST", body: JSON.stringify(liteReq) });
          const textLite = await respLite.text();
          if (!respLite.ok) return setMsg(textLite);
          const dataLite = JSON.parse(textLite);
          const anchorKey = isMix ? "mix" : String(Number(mpRotState.anchor));
          const oneLite = (dataLite.by_anchor || {})[anchorKey] || {};
          const navLite = oneLite.nav || {};
          const datesIso = (navLite.dates || []);
          const picked = _pickRange(datesIso, mpRotState.rangeKey);
          if (!picked.startIso || !picked.endIso) return setMsg("小程序固定轮动：无可用日期轴（请先同步行情）");
          const s1 = _ymd(picked.startIso);
          const e1 = _ymd(picked.endIso);

          _mpRotSetStatus(`加载 ${picked.label} (${picked.startIso} ~ ${picked.endIso})...`);
          const fullReq = isMix
            ? { start: s1, end: e1, asset_rc_rules: (() => {
              const rb = window.__riskRuleBook || {};
              const out = [];
              for (const [code, r] of Object.entries(rb)) {
                if (!r) continue;
                out.push({
                  code,
                  sig_type: r.sigType,
                  k: Number(r.k),
                  p_in: Number(r.p),
                  reduce_pct: Number(r.reduce),
                  recovery_mode: r.recoveryMode || "immediate",
                  p_out: (r.pOut == null ? null : Number(r.pOut)),
                  cooldown_days: Number(r.cooldownDays || 0),
                });
              }
              return out.length ? out : null;
            })() }
            : { start: s1, end: e1, anchor_weekday: Number(mpRotState.anchor), asset_rc_rules: (() => {
              const rb = window.__riskRuleBook || {};
              const out = [];
              for (const [code, r] of Object.entries(rb)) {
                if (!r) continue;
                out.push({
                  code,
                  sig_type: r.sigType,
                  k: Number(r.k),
                  p_in: Number(r.p),
                  reduce_pct: Number(r.reduce),
                  recovery_mode: r.recoveryMode || "immediate",
                  p_out: (r.pOut == null ? null : Number(r.pOut)),
                  cooldown_days: Number(r.cooldownDays || 0),
                });
              }
              return out.length ? out : null;
            })() };
          const respFull = await api(fullPath, { method: "POST", body: JSON.stringify(fullReq) });
          const textFull = await respFull.text();
          if (!respFull.ok) return setMsg(textFull);
          const dataFull = JSON.parse(textFull);
          const one = (dataFull.by_anchor || {})[anchorKey];
          if (!one) return setMsg("小程序固定轮动：后端未返回该方案数据");

          // Render into the existing rotation section (same as runRotation())
          plotRotation(one);
          renderRotationMetrics(one.metrics || {});
          renderWinPayoff(one.win_payoff || {});
          renderRotationHoldingPeriodLengthDistributions(one.holdings || [], (one.nav && one.nav.dates) ? one.nav.dates : []);
          renderContributionTables("rot", one.attribution);
          rotState.rows = one.period_details || [];
          rotState.page = 1;
          renderRotPeriods();
          rotPeriodTableState.weekly.rows = (one.period_returns && one.period_returns.weekly) ? one.period_returns.weekly : [];
          rotPeriodTableState.monthly.rows = (one.period_returns && one.period_returns.monthly) ? one.period_returns.monthly : [];
          rotPeriodTableState.quarterly.rows = (one.period_returns && one.period_returns.quarterly) ? one.period_returns.quarterly : [];
          rotPeriodTableState.yearly.rows = (one.period_returns && one.period_returns.yearly) ? one.period_returns.yearly : [];
          rotPeriodTableState.weekly.page = 1;
          rotPeriodTableState.monthly.page = 1;
          rotPeriodTableState.quarterly.page = 1;
          rotPeriodTableState.yearly.page = 1;
          renderRotPeriodTable("weekly");
          renderRotPeriodTable("monthly");
          renderRotPeriodTable("quarterly");
          renderRotPeriodTable("yearly");

          // Next rebalance plan (mini-program semantics)
          const lastIso = (one.nav && one.nav.dates && one.nav.dates.length) ? one.nav.dates[one.nav.dates.length - 1] : picked.endIso;
          const asof = _ymd(lastIso);
          try {
            const planPath = isMix ? "/analysis/rotation/next-plan-auto" : "/analysis/rotation/next-plan";
            const planReq = isMix ? { asof } : { anchor_weekday: Number(mpRotState.anchor), asof };
            const respPlan = await api(planPath, { method: "POST", body: JSON.stringify(planReq) });
            const textPlan = await respPlan.text();
            if (respPlan.ok) {
              const plan = JSON.parse(textPlan);
              if (plan && plan.rebalance_effective_next_day) {
                $("mpRotPlan").textContent = `下一交易日（${plan.next_trading_day}）为调仓执行日；计划持有：${plan.pick_name || "-"}（${plan.pick_code || "-"}）`;
              } else if (plan) {
                $("mpRotPlan").textContent = `下一交易日（${plan.next_trading_day || "-"}）非调仓执行日`;
              } else {
                $("mpRotPlan").textContent = "";
              }
            } else {
              $("mpRotPlan").textContent = "";
            }
          } catch {
            $("mpRotPlan").textContent = "";
          }

          _mpRotSetStatus("OK");
        } catch (e) {
          console.error(e);
          setMsg(String(e && e.message ? e.message : e));
          _mpRotSetStatus("失败");
        } finally {
          if (btn) { btn.disabled = false; btn.textContent = oldTxt; }
        }
      }
      let lastBaseline = null; // latest baseline analysis payload (for client-side correlation re-slicing)
      let corrRangeKey = "all";

      function openMetricModal(key, metrics) {
        const h = metricHelp[key] || { title: key, sub: "", body: "<div class='muted'>暂无说明。</div>" };
        $("metricModalTitle").textContent = h.title;
        $("metricModalSub").textContent = h.sub || "";
        $("metricModalBody").innerHTML = h.body || "";
        $("metricModal").style.display = "block";
      }

      function closeMetricModal() {
        $("metricModal").style.display = "none";
      }

      function exportPdfReport() {
        // Best-effort resize Plotly charts before printing.
        try {
          const ids = [
            "chart", "rollingReturns", "rollingDD",
            "corrHeatmap",
            "ewCalHeatmap", "ewCalRollingChart",
            "rotCalHeatmap", "rotCalRollingChart",
            "trendChart", "trendDD",
            "rotChart", "rotDDCompare", "rotExcessChart", "rot40dDiffChart",
            "rotRollingCombo", "rotExcessRollingCombo",
            "mcEwHist", "mcEwQQ",
            "mcRotHist", "mcRotQQ",
            "mcExcessHist", "mcExcessQQ",
          ];
          for (const id of ids) {
            const el = $(id);
            if (el && window.Plotly && el.data) {
              try { Plotly.Plots.resize(el); } catch (e) {}
            }
          }
        } catch (e) {}

        const start = ($("start").value || "").trim();
        const end = ($("end").value || "").trim();
        const codes = Array.from(selected).join("-");
        const oldTitle = document.title;
        document.title = `research_${start || "START"}_${end || "END"}_${codes || "codes"}`;
        setTimeout(() => {
          window.print();
          setTimeout(() => { document.title = oldTitle; }, 200);
        }, 150);
      }

      function ymdToNum(s) {
        if (!s || s.length < 8) return null;
        const n = Number(s.slice(0, 8));
        return Number.isFinite(n) ? n : null;
      }

      function numToYmd(n) {
        if (!Number.isFinite(n)) return "";
        return String(Math.trunc(n)).padStart(8, "0");
      }

      function ymdToDate(s) {
        if (!s || s.length < 8) return null;
        const y = Number(s.slice(0, 4));
        const m = Number(s.slice(4, 6));
        const d = Number(s.slice(6, 8));
        if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;
        // Use local time; we only care about YYYYMMDD arithmetic.
        return new Date(y, m - 1, d);
      }

      function isoToDate(s) {
        // Expect "YYYY-MM-DD"
        if (!s) return null;
        const dt = new Date(s);
        return Number.isNaN(dt.getTime()) ? null : dt;
      }

      function _shiftMonths(d, months) {
        const x = new Date(d.getTime());
        x.setMonth(x.getMonth() + months);
        return x;
      }

      function _shiftYears(d, years) {
        const x = new Date(d.getTime());
        x.setFullYear(x.getFullYear() + years);
        return x;
      }

      function _corrRangeSpec(key) {
        const m = {
          "1m": { label: "近一月", threshold: (end) => _shiftMonths(end, -1) },
          "3m": { label: "近三月", threshold: (end) => _shiftMonths(end, -3) },
          "6m": { label: "近六月", threshold: (end) => _shiftMonths(end, -6) },
          "1y": { label: "近一年", threshold: (end) => _shiftYears(end, -1) },
          "3y": { label: "近三年", threshold: (end) => _shiftYears(end, -3) },
          "5y": { label: "近五年", threshold: (end) => _shiftYears(end, -5) },
          "10y": { label: "近十年", threshold: (end) => _shiftYears(end, -10) },
          all: { label: "全回测区间", threshold: null },
        };
        return m[key] || m.all;
      }

      function _findStartIndexByThreshold(dates, thresholdDt) {
        if (!thresholdDt) return 0;
        for (let i = 0; i < dates.length; i++) {
          const d = isoToDate(dates[i]);
          if (d && d >= thresholdDt) return i;
        }
        return dates.length; // not found
      }

      function _corrMatrixFromNav({ dates, codes, seriesByCode }, startIdx) {
        const endIdx = dates.length - 1;
        const n = codes.length;
        if (startIdx >= endIdx) {
          return { ok: false, error: "not enough dates" };
        }
        // build daily returns arrays (aligned by index)
        const rets = codes.map((c) => {
          const nav = (seriesByCode[c] || []).slice(startIdx, endIdx + 1);
          const r = [];
          for (let i = 1; i < nav.length; i++) {
            const a = Number(nav[i - 1]);
            const b = Number(nav[i]);
            if (!Number.isFinite(a) || !Number.isFinite(b) || a === 0) r.push(NaN);
            else r.push(b / a - 1.0);
          }
          return r;
        });
        const t = rets[0].length;
        const corr = Array.from({ length: n }, () => Array.from({ length: n }, () => null));

        const corrPair = (x, y) => {
          let nObs = 0;
          let sx = 0, sy = 0;
          for (let i = 0; i < t; i++) {
            const xi = x[i], yi = y[i];
            if (Number.isFinite(xi) && Number.isFinite(yi)) {
              nObs += 1;
              sx += xi;
              sy += yi;
            }
          }
          if (nObs < 3) return { nObs, value: null };
          const mx = sx / nObs;
          const my = sy / nObs;
          let sxx = 0, syy = 0, sxy = 0;
          for (let i = 0; i < t; i++) {
            const xi = x[i], yi = y[i];
            if (Number.isFinite(xi) && Number.isFinite(yi)) {
              const dx = xi - mx;
              const dy = yi - my;
              sxx += dx * dx;
              syy += dy * dy;
              sxy += dx * dy;
            }
          }
          if (sxx <= 0 || syy <= 0) return { nObs, value: null };
          return { nObs, value: sxy / Math.sqrt(sxx * syy) };
        };

        let nObsMin = null;
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (i === j) {
              corr[i][j] = 1.0;
              continue;
            }
            const { nObs, value } = corrPair(rets[i], rets[j]);
            if (nObsMin == null || nObs < nObsMin) nObsMin = nObs;
            corr[i][j] = value;
          }
        }
        return { ok: true, matrix: corr, nObsMin: nObsMin == null ? 0 : nObsMin };
      }

      function refreshCorrelationForRange(key) {
        if (!lastBaseline || !lastBaseline.nav || !lastBaseline.codes) return;
        const codes = lastBaseline.codes;
        const dates = lastBaseline.nav.dates || [];
        const end = isoToDate(dates[dates.length - 1]);
        if (!end) return;
        const spec = _corrRangeSpec(key);
        const threshold = spec.threshold ? spec.threshold(end) : null;
        const startIdx = _findStartIndexByThreshold(dates, threshold);
        if (startIdx >= dates.length) return;

        // Build series-by-code for selected codes only (exclude EW/BENCH series)
        const seriesByCode = {};
        for (const c of codes) seriesByCode[c] = lastBaseline.nav.series[c];

        const calc = _corrMatrixFromNav({ dates, codes, seriesByCode }, startIdx);
        if (!calc.ok) return;

        const startDate = dates[startIdx];
        const endDate = dates[dates.length - 1];
        $("corrRangeTitle").textContent = `· ${spec.label}（${startDate} ~ ${endDate}）`;
        $("corrRangeHint").textContent = `样本数(最小对)：${calc.nObsMin}`;
        plotCorrelation({ method: "pearson", codes, matrix: calc.matrix, n_obs: calc.nObsMin });
      }

      function updateCorrRangeButtons() {
        const btns = [
          ["1m", "corrRange1m"],
          ["3m", "corrRange3m"],
          ["6m", "corrRange6m"],
          ["1y", "corrRange1y"],
          ["3y", "corrRange3y"],
          ["5y", "corrRange5y"],
          ["10y", "corrRange10y"],
          ["all", "corrRangeAll"],
        ];
        if (!lastBaseline || !lastBaseline.nav || !lastBaseline.nav.dates || lastBaseline.nav.dates.length === 0) {
          for (const [, id] of btns) { const el = $(id); if (el) el.disabled = true; }
          return;
        }
        const dates = lastBaseline.nav.dates;
        const first = isoToDate(dates[0]);
        const end = isoToDate(dates[dates.length - 1]);
        for (const [key, id] of btns) {
          const el = $(id);
          if (!el) continue;
          if (key === "all") {
            el.disabled = false;
            continue;
          }
          const spec = _corrRangeSpec(key);
          const thr = spec.threshold ? spec.threshold(end) : null;
          // disable if full backtest shorter than desired window
          el.disabled = (!first || !thr) ? true : (first > thr);
        }
      }

      function dateToYmd(dt) {
        if (!(dt instanceof Date) || Number.isNaN(dt.getTime())) return "";
        const y = dt.getFullYear();
        const m = String(dt.getMonth() + 1).padStart(2, "0");
        const d = String(dt.getDate()).padStart(2, "0");
        return String(y) + m + d;
      }

      function computeAvailableRangeForSelection() {
        const items = pool.filter(x => selected.has(x.code));
        const starts = items.map(x => x.last_data_start_date).filter(Boolean).sort();
        const ends = items.map(x => x.last_data_end_date).filter(Boolean).sort();
        if (!starts.length || !ends.length) return { start: null, end: null };
        return { start: starts[starts.length - 1], end: ends[0] }; // max start, min end
      }

      function renderRangeHint() {
        const el = $("rangeHint");
        if (!el) return;
        const avail = computeAvailableRangeForSelection();
        if (!avail.start || !avail.end) {
          el.textContent = "共同区间：无";
          return;
        }
        el.textContent = `共同区间：${avail.start}~${avail.end}`;
      }

      function applyQuickRange(years) {
        const avail = computeAvailableRangeForSelection();
        if (!avail.start || !avail.end) {
          setMsg("无法计算快捷区间：请先勾选至少一个且已抓取过数据的标的。");
          return;
        }
        const availSn = ymdToNum(avail.start);
        const availEn = ymdToNum(avail.end);
        if (availSn == null || availEn == null) {
          setMsg("无法计算快捷区间：共同区间无效。");
          return;
        }

        let startYmd = avail.start;
        let endYmd = avail.end;
        if (Number.isFinite(years) && years > 0) {
          const endDt = ymdToDate(avail.end);
          if (!endDt) {
            setMsg("无法计算快捷区间：共同结束日期无效。");
            return;
          }
          const startDt = new Date(endDt.getTime());
          startDt.setFullYear(startDt.getFullYear() - Number(years));
          const candidate = dateToYmd(startDt);
          const candN = ymdToNum(candidate);
          if (candN != null) {
            const nextS = Math.max(availSn, candN);
            startYmd = numToYmd(nextS);
          } else {
            startYmd = avail.start;
          }
        }

        // Always clamp within [avail.start, avail.end]
        const nextSn = ymdToNum(startYmd);
        const nextEn = ymdToNum(endYmd);
        if (nextSn == null || nextEn == null || nextSn > nextEn) {
          startYmd = avail.start;
          endYmd = avail.end;
        }
        $("start").value = startYmd;
        $("end").value = endYmd;
      }

      function maybeAdjustBacktestRange() {
        const avail = computeAvailableRangeForSelection();
        if (!avail.start || !avail.end) return;
        const curS = ($("start").value || "").trim();
        const curE = ($("end").value || "").trim();
        const curSn = ymdToNum(curS);
        const curEn = ymdToNum(curE);
        const availSn = ymdToNum(avail.start);
        const availEn = ymdToNum(avail.end);
        if (curSn == null || curEn == null) {
          // if user hasn't set a valid range yet, initialize to available
          $("start").value = avail.start;
          $("end").value = avail.end;
          return;
        }
        // Only adjust if available interval is smaller than current specified interval (i.e. doesn't cover it)
        if (curSn < availSn || curEn > availEn) {
          const nextS = Math.max(curSn, availSn);
          const nextE = Math.min(curEn, availEn);
          if (nextS > nextE) {
            // no overlap -> fall back to full available interval
            $("start").value = avail.start;
            $("end").value = avail.end;
          } else {
            $("start").value = numToYmd(nextS);
            $("end").value = numToYmd(nextE);
          }
        }
      }

      function renderCodeList() {
        const box = $("codes");
        box.innerHTML = "";
        for (const it of pool) {
          const div = document.createElement("div");
          const checked = selected.has(it.code) ? "checked" : "";
          div.innerHTML = `<label style="display:flex; gap:8px; align-items:center;">
            <input type="checkbox" data-code="${it.code}" ${checked}/>
            <span>${it.code} ${it.name} <span class="muted">(${(it.last_data_start_date && it.last_data_end_date) ? (it.last_data_start_date + "~" + it.last_data_end_date) : "没有"})</span></span>
          </label>`;
          box.appendChild(div);
        }
        box.querySelectorAll("input[type=checkbox]").forEach(cb => {
          cb.addEventListener("change", () => {
            const c = cb.getAttribute("data-code");
            if (cb.checked) selected.add(c); else selected.delete(c);
            renderBenchmarkSelect();
            renderTrendCodeSelect();
            maybeAdjustBacktestRange();
            renderRangeHint();
          });
        });
      }

      function renderBenchmarkSelect() {
        const sel = $("benchmark");
        const codes = Array.from(selected);
        sel.innerHTML = "";
        for (const c of codes) {
          const opt = document.createElement("option");
          opt.value = c;
          opt.textContent = c;
          sel.appendChild(opt);
        }
        if (codes.includes("510300")) sel.value = "510300";
      }

      function renderTrendCodeSelect() {
        const sel = $("trendCode");
        if (!sel) return;
        const codes = Array.from(selected);
        const prev = sel.value || "";
        sel.innerHTML = "";
        for (const c of codes) {
          const opt = document.createElement("option");
          opt.value = c;
          opt.textContent = c;
          sel.appendChild(opt);
        }
        if (codes.includes(prev)) sel.value = prev;
      }

      async function loadPool() {
        const resp = await api(`/etf?adjust=${encodeURIComponent(ADJUST_USED)}`, { method: "GET" });
        pool = await resp.json();
        // default select all
        for (const it of pool) selected.add(it.code);
        renderCodeList();
        renderBenchmarkSelect();
        renderTrendCodeSelect();
        // default defensive ETF: keep empty as requested
        // Initialize or clamp backtest range to available intersection (only if needed)
        maybeAdjustBacktestRange();
        renderRangeHint();
      }

      function setMsg(t) { $("msg").textContent = t || ""; }

      function renderMetrics(metrics) {
        const rows = [
          { key: "benchmark_code", label: "基准标的", value: metrics.benchmark_code },
          { key: "rebalance", label: "再平衡周期", value: metrics.rebalance || "-" },
          { key: "risk_free_rate", label: "无风险收益率(年化)", value: metrics.risk_free_rate != null ? fmtPct(metrics.risk_free_rate) : "-" },
          { key: "cumulative_return", label: "累积收益率", value: fmtPct(metrics.cumulative_return) },
          { key: "annualized_return", label: "年化收益率", value: fmtPct(metrics.annualized_return) },
          { key: "annualized_volatility", label: "年化波动率", value: fmtPct(metrics.annualized_volatility) },
          { key: "max_drawdown", label: "最大回撤", value: fmtPct(metrics.max_drawdown) },
          { key: "max_drawdown_recovery_days", label: "最大回撤修复时长(天)", value: metrics.max_drawdown_recovery_days },
          { key: "sharpe_ratio", label: "夏普比率", value: fmtNum(metrics.sharpe_ratio) },
          { key: "calmar_ratio", label: "卡玛比率", value: fmtNum(metrics.calmar_ratio) },
          { key: "sortino_ratio", label: "索诺提比率", value: fmtNum(metrics.sortino_ratio) },
          { key: "information_ratio", label: "信息比率", value: fmtNum(metrics.information_ratio) },
          { key: "ulcer_index", label: "溃疡指标(UI)", value: fmtNum(metrics.ulcer_index) },
          { key: "ulcer_performance_index", label: "溃疡绩效(UPI)", value: fmtNum(metrics.ulcer_performance_index) },
          { key: "holding_weekly_win_rate", label: "周度绝对胜率", value: fmtPct(metrics.holding_weekly_win_rate) },
          { key: "holding_weekly_payoff_ratio", label: "周度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_weekly_payoff_ratio) },
          { key: "holding_weekly_kelly_fraction", label: "周度绝对凯利比(近似)", value: fmtPct(metrics.holding_weekly_kelly_fraction) },
          { key: "holding_monthly_win_rate", label: "月度绝对胜率", value: fmtPct(metrics.holding_monthly_win_rate) },
          { key: "holding_monthly_payoff_ratio", label: "月度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_monthly_payoff_ratio) },
          { key: "holding_monthly_kelly_fraction", label: "月度绝对凯利比(近似)", value: fmtPct(metrics.holding_monthly_kelly_fraction) },
          { key: "holding_quarterly_win_rate", label: "季度绝对胜率", value: fmtPct(metrics.holding_quarterly_win_rate) },
          { key: "holding_quarterly_payoff_ratio", label: "季度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_quarterly_payoff_ratio) },
          { key: "holding_quarterly_kelly_fraction", label: "季度绝对凯利比(近似)", value: fmtPct(metrics.holding_quarterly_kelly_fraction) },
          { key: "holding_yearly_win_rate", label: "年度绝对胜率", value: fmtPct(metrics.holding_yearly_win_rate) },
          { key: "holding_yearly_payoff_ratio", label: "年度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_yearly_payoff_ratio) },
          { key: "holding_yearly_kelly_fraction", label: "年度绝对凯利比(近似)", value: fmtPct(metrics.holding_yearly_kelly_fraction) },
        ];
        const t = $("metrics");
        t.innerHTML =
          `<tr><th>指标</th><th>值</th></tr>` +
          rows
            .map(
              (r) => `
                <tr>
                  <td>
                    <span>${r.label}</span>
                    <button class="helpBtn" data-metric="${r.key}" title="查看说明"
                      style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">
                      ?
                    </button>
                  </td>
                  <td>${r.value}</td>
                </tr>
              `
            )
            .join("");
      }

      function renderContributionTables(kind, attribution) {
        const nameByCode = new Map((pool || []).map(x => [x.code, x.name]));
        const retEl = $(kind === "ew" ? "ewReturnContrib" : "rotReturnContrib");
        const riskEl = $(kind === "ew" ? "ewRiskContrib" : "rotRiskContrib");
        if (!retEl || !riskEl) return;

        if (!attribution || !attribution.return || !attribution.risk) {
          retEl.innerHTML = "<tr><th>标的</th><th>总收益贡献</th><th>贡献占比</th></tr>";
          riskEl.innerHTML = "<tr><th>标的</th><th>风险贡献占比</th></tr>";
          return;
        }

        const rrows = (attribution.return.by_code || []).slice();
        rrows.sort((a, b) => (Number(b.return_contribution || 0) - Number(a.return_contribution || 0)));
        retEl.innerHTML =
          `<tr><th>标的</th><th>总收益贡献</th><th>贡献占比</th></tr>` +
          rrows
            .map((x) => {
              const c = x.code;
              const nm = nameByCode.get(c) || "";
              const label = `${c}${nm ? " " + nm : ""}`;
              const contrib = (x.return_contribution == null) ? "-" : fmtPct(Number(x.return_contribution));
              const share = (x.return_share == null) ? "-" : (Number(x.return_share) * 100).toFixed(2) + "%";
              return `<tr><td>${label}</td><td>${contrib}</td><td>${share}</td></tr>`;
            })
            .join("");

        const kRisk = (attribution.risk.by_code || []).slice();
        kRisk.sort((a, b) => (Number(b.risk_share || 0) - Number(a.risk_share || 0)));
        riskEl.innerHTML =
          `<tr><th>标的</th><th>风险贡献占比</th></tr>` +
          kRisk
            .map((x) => {
              const c = x.code;
              const nm = nameByCode.get(c) || "";
              const label = `${c}${nm ? " " + nm : ""}`;
              const share = (x.risk_share == null) ? "-" : (Number(x.risk_share) * 100).toFixed(2) + "%";
              return `<tr><td>${label}</td><td>${share}</td></tr>`;
            })
            .join("");
      }

      const pageSize = 12;
      const periodState = {
        weekly: { page: 1, data: [] },
        monthly: { page: 1, data: [] },
        quarterly: { page: 1, data: [] },
        yearly: { page: 1, data: [] },
      };

      function _sortedPeriodRows(rows, sortKey, sortDir) {
        const arr = (rows || []).slice();
        const key = sortKey === "return" ? "return" : "period_end";
        arr.sort((a, b) => {
          const av = key === "return" ? Number(a.return) : String(a.period_end);
          const bv = key === "return" ? Number(b.return) : String(b.period_end);
          if (av < bv) return -1;
          if (av > bv) return 1;
          return 0;
        });
        if (sortDir === "desc") arr.reverse();
        return arr;
      }

      function renderPeriodPaged(kind) {
        const st = periodState[kind];
        const sortKey = $(`${kind}SortKey`).value;
        const sortDir = $(`${kind}SortDir`).value;
        const rows = _sortedPeriodRows(st.data, sortKey, sortDir);
        const total = rows.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        st.page = Math.min(Math.max(1, st.page), totalPages);
        const startIdx = (st.page - 1) * pageSize;
        const pageRows = rows.slice(startIdx, startIdx + pageSize);
        const t = $(kind);
        t.innerHTML = `<tr><th>期末</th><th>收益</th></tr>` + pageRows.map(x => `<tr><td>${x.period_end}</td><td>${fmtPct(x.return)}</td></tr>`).join("");
        $(`${kind}Page`).textContent = `${st.page}/${totalPages} · 共${total}条 · 每页${pageSize}条`;
      }

      function wirePeriodControls(kind) {
        $(`${kind}SortKey`).addEventListener("change", () => { periodState[kind].page = 1; renderPeriodPaged(kind); });
        $(`${kind}SortDir`).addEventListener("change", () => { periodState[kind].page = 1; renderPeriodPaged(kind); });
        $(`${kind}Prev`).addEventListener("click", () => { periodState[kind].page -= 1; renderPeriodPaged(kind); });
        $(`${kind}Next`).addEventListener("click", () => { periodState[kind].page += 1; renderPeriodPaged(kind); });
      }

      function plotNav(nav) {
        const dates = nav.dates;
        const series = nav.series;
        const traces = Object.keys(series).map(name => ({
          x: dates,
          y: series[name],
          mode: "lines",
          name,
          hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>",
        }));
        // RSI overlay (fixed windows: 6/12/24) on EW + benchmark only
        const rsiWins = [6, 12, 24];
        const _rsiWilder = (arr, window) => {
          const w = Math.max(1, Number(window || 1));
          const out = new Array(arr.length).fill(null);
          if (arr.length < w + 1) return out;
          // Wilder smoothing: alpha=1/w
          let avgGain = null;
          let avgLoss = null;
          for (let i = 1; i < arr.length; i++) {
            const prev = Number(arr[i - 1]);
            const cur = Number(arr[i]);
            if (!Number.isFinite(prev) || !Number.isFinite(cur) || prev <= 0 || cur <= 0) continue;
            const chg = cur - prev;
            const gain = Math.max(0, chg);
            const loss = Math.max(0, -chg);
            if (i <= w) {
              // seed with SMA of first w diffs
              // accumulate via temp sums
              if (avgGain == null) { avgGain = 0.0; avgLoss = 0.0; }
              avgGain += gain;
              avgLoss += loss;
              if (i === w) {
                avgGain = avgGain / w;
                avgLoss = avgLoss / w;
              }
            } else {
              avgGain = ((avgGain * (w - 1)) + gain) / w;
              avgLoss = ((avgLoss * (w - 1)) + loss) / w;
            }
            if (i >= w && avgGain != null && avgLoss != null) {
              let rsi = null;
              if (avgLoss === 0 && avgGain === 0) rsi = 50.0;
              else if (avgLoss === 0) rsi = 100.0;
              else if (avgGain === 0) rsi = 0.0;
              else {
                const rs = avgGain / avgLoss;
                rsi = 100.0 - (100.0 / (1.0 + rs));
              }
              out[i] = rsi;
            }
          }
          return out;
        };
        const addRsiFor = (key, labelPrefix, dash) => {
          if (!key || !series[key]) return;
          const navArr = series[key];
          for (const w of rsiWins) {
            traces.push({
              x: dates,
              y: _rsiWilder(navArr, w),
              mode: "lines",
              name: `${labelPrefix}RSI${w}`,
              yaxis: "y2",
              line: { dash: dash || "dot", width: 1.1 },
              hovertemplate: "%{x}<br>%{y:.1f}<extra></extra>",
            });
          }
        };
        // Only show EW RSI (no benchmark RSI)
        addRsiFor("EW", "", "solid");
        Plotly.newPlot(
          "chart",
          traces,
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: {
              type: "log",
              tick0: 0,
              // Coarser ticks to avoid dense labels; roughly 1,2,4,8...
              dtick: Math.log10(2.0),
              tickformat: ".0f",
              showgrid: true,
              gridcolor: "#eee",
              domain: [0.32, 1.0],
            },
            yaxis2: {
              title: "RSI",
              range: [0, 100],
              showgrid: false,
              zeroline: false,
              domain: [0.0, 0.25],
            },
            shapes: [
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 30, y1: 30, line: { color: "#999", width: 1, dash: "dot" } },
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 70, y1: 70, line: { color: "#999", width: 1, dash: "dot" } },
            ],
          },
          { responsive: true }
        );
      }

      function plotRolling(id, title, rollingMap, yTickFormat) {
        const traces = [];
        for (const k of Object.keys(rollingMap || {})) {
          const isPct = yTickFormat === ".0%";
          traces.push({
            x: rollingMap[k].dates,
            y: rollingMap[k].values,
            mode: "lines",
            name: k,
            // Keep axis at 0-decimal percent as requested, but show more precision on hover
            // so long windows (1y/3y) don't look like "steps" due to rounding.
            hovertemplate: isPct ? "%{x}<br>%{y:.2%}<extra></extra>" : "%{x}<br>%{y:.4f}<extra></extra>",
          });
        }
        Plotly.newPlot(
          id,
          traces,
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: yTickFormat ? { tickformat: yTickFormat } : undefined,
          },
          { responsive: true }
        );
      }

      // plotNavRsi removed: RSI is overlaid on NAV charts

      function renderFft(fft) {
        const tbl = $("fftTable");
        const sum = $("fftSummary");
        if (!tbl) return;
        if (!fft || fft.ok === false) {
          if (sum) sum.textContent = fft && fft.reason ? `FFT不可用：${fft.reason}` : "FFT不可用。";
          tbl.innerHTML = "";
          return;
        }
        const windows = fft.windows || [];
        const winLabels = ["full"].concat(windows.map(w => `last_${w}`));
        const fmtPct = (x) => (x == null || !Number.isFinite(Number(x)) ? "-" : (Number(x) * 100).toFixed(1) + "%");
        const fmtNum = (x) => (x == null || !Number.isFinite(Number(x)) ? "-" : Number(x).toFixed(2));
        const fmtPeaks = (peaks) => {
          if (!Array.isArray(peaks) || peaks.length === 0) return "-";
          return peaks
            .slice(0, 3)
            .map((p) => {
              const d = p && Number.isFinite(Number(p.period_days)) ? Math.round(Number(p.period_days)) : null;
              const s = p && Number.isFinite(Number(p.power_share)) ? (Number(p.power_share) * 100).toFixed(1) + "%" : null;
              return d == null ? "-" : `${d}d(${s || "-"})`;
            })
            .join(", ");
        };

        const rows = [];
        const addRowsFor = (label, obj) => {
          for (const w of winLabels) {
            const one = (obj && obj[w]) ? obj[w] : null;
            const ok = one && one.ok;
            rows.push({
              code: label,
              window: w,
              n: one ? one.n : null,
              peaks: ok ? fmtPeaks(one.peaks) : (one && one.reason ? `- (${one.reason})` : "-"),
              low: ok ? fmtPct(one.band_energy && one.band_energy.low) : "-",
              mid: ok ? fmtPct(one.band_energy && one.band_energy.mid) : "-",
              high: ok ? fmtPct(one.band_energy && one.band_energy.high) : "-",
              ent: ok ? fmtNum(one.spectral_entropy) : "-",
            });
          }
        };

        addRowsFor("EW(等权)", fft.ew || {});
        const per = fft.per_code || {};
        for (const code of Object.keys(per)) addRowsFor(code, per[code]);

        if (sum) {
          const nCodes = Object.keys(per).length;
          sum.textContent = `共 ${nCodes} 个标的 + EW(等权)；FFT方法=${fft.method || "-"}。`;
        }

        tbl.innerHTML =
          `<tr><th>标的</th><th>窗口</th><th>样本数</th><th>主导周期(Top3)</th><th>低频能量</th><th>中频能量</th><th>高频能量</th><th>谱熵</th></tr>` +
          rows
            .map(
              (r) =>
                `<tr>` +
                `<td>${esc(r.code)}</td>` +
                `<td>${esc(r.window)}</td>` +
                `<td>${esc(r.n == null ? "-" : String(r.n))}</td>` +
                `<td>${esc(r.peaks)}</td>` +
                `<td>${esc(r.low)}</td>` +
                `<td>${esc(r.mid)}</td>` +
                `<td>${esc(r.high)}</td>` +
                `<td>${esc(r.ent)}</td>` +
                `</tr>`
            )
            .join("");
      }

      function renderFftRoll(fftRoll) {
        const boxEnt = $("fftRollEntropy");
        const boxHigh = $("fftRollHigh");
        if (!boxEnt || !boxHigh) return;
        if (!fftRoll || !fftRoll.ew) {
          boxEnt.innerHTML = "<div class='muted'>无滚动FFT数据</div>";
          boxHigh.innerHTML = "<div class='muted'>无滚动FFT数据</div>";
          return;
        }
        const ew = fftRoll.ew;
        if (ew.ok === false) {
          const reason = ew.reason ? `：${esc(ew.reason)}` : "";
          boxEnt.innerHTML = `<div class='muted'>滚动FFT不可用${reason}</div>`;
          boxHigh.innerHTML = `<div class='muted'>滚动FFT不可用${reason}</div>`;
          return;
        }
        const series = ew.series || {};
        const keys = Object.keys(series);
        if (keys.length === 0) {
          boxEnt.innerHTML = "<div class='muted'>滚动FFT暂无数据（可能样本不足）</div>";
          boxHigh.innerHTML = "<div class='muted'>滚动FFT暂无数据（可能样本不足）</div>";
          return;
        }

        // Entropy chart
        const entTraces = [];
        for (const k of keys) {
          const s = series[k];
          if (!s || s.ok === false) continue;
          entTraces.push({
            x: s.dates,
            y: s.spectral_entropy,
            mode: "lines",
            name: k,
            hovertemplate: "%{x}<br>entropy=%{y:.3f}<extra></extra>",
          });
        }
        Plotly.newPlot(
          "fftRollEntropy",
          entTraces,
          { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { title: "谱熵(0-1)" } },
          { responsive: true }
        );

        // High-band energy chart
        const highTraces = [];
        for (const k of keys) {
          const s = series[k];
          if (!s || s.ok === false) continue;
          highTraces.push({
            x: s.dates,
            y: s.high_band_energy,
            mode: "lines",
            name: k,
            hovertemplate: "%{x}<br>high_energy=%{y:.2%}<extra></extra>",
          });
        }
        Plotly.newPlot(
          "fftRollHigh",
          highTraces,
          { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { title: "高频能量占比", tickformat: ".0%" } },
          { responsive: true }
        );
      }

      function renderPeriodDistributions(distributions) {
        if (!distributions || typeof distributions !== "object") {
          return;
        }
        
        const codeSelect = $("distCodeSelect");
        const typeSelect = $("distTypeSelect");
        const periodSelect = $("distPeriodSelect");
        
        if (!codeSelect || !typeSelect || !periodSelect) return;
        
        // Populate code selector
        const codes = Object.keys(distributions).sort();
        codeSelect.innerHTML = codes.map(c => `<option value="${esc(c)}">${esc(c)}</option>`).join("");
        
        if (codes.length === 0) {
          $("distHistogram").innerHTML = "<div class='muted'>无分布数据</div>";
          $("distQuantiles").innerHTML = "";
          return;
        }
        
        // Render function
        const updateDisplay = () => {
          const code = codeSelect.value;
          const type = typeSelect.value; // "return" or "volatility"
          const period = periodSelect.value; // "daily", "weekly", "monthly", "quarterly", "yearly"
          
          if (!code || !distributions[code]) {
            $("distHistogram").innerHTML = "<div class='muted'>请选择标的</div>";
            $("distQuantiles").innerHTML = "";
            return;
          }
          
          const key = `${period}_${type}`;
          const data = distributions[code][key];
          
          if (!data || !data.hist || !data.quantiles) {
            $("distHistogram").innerHTML = `<div class='muted'>无${period}${type === "return" ? "收益率" : "波动率"}数据</div>`;
            $("distQuantiles").innerHTML = "";
            return;
          }
          
          // Render histogram
          const h = data.hist;
          const edges = h.bin_edges || [];
          const counts = h.counts || [];
          
          if (edges.length < 2 || counts.length < 1) {
            $("distHistogram").innerHTML = "<div class='muted'>无直方图数据</div>";
            $("distQuantiles").innerHTML = "";
            return;
          }
          
          const x = [];
          for (let i = 0; i < counts.length; i++) {
            x.push((edges[i] + edges[i + 1]) / 2);
          }
          
          const isPct = true; // returns and volatility are percentages
          const fmtX = ".2%";
          const title = `${code} - ${period === "daily" ? "日度" : period === "weekly" ? "周度" : period === "monthly" ? "月度" : period === "quarterly" ? "季度" : "年度"}${type === "return" ? "收益率" : "波动率"}分布`;
          
          Plotly.newPlot(
            "distHistogram",
            [{
              x,
              y: counts,
              type: "bar",
              marker: { color: "#4c78a8" },
              hovertemplate: `${fmtX}<br>count=%{y}<extra></extra>`,
            }],
            {
              margin: { t: 40 },
              title: { text: title, font: { size: 14 } },
              xaxis: { tickformat: fmtX, title: type === "return" ? "收益率" : "波动率" },
              yaxis: { title: "频数" },
              annotations: [
                {
                  xref: "paper",
                  yref: "paper",
                  x: 0.01,
                  y: 0.98,
                  showarrow: false,
                  text: `样本数=${data.count || 0} · 均值=${isPct ? fmtPct(data.mean) : fmtNum(data.mean)} · 标准差=${isPct ? fmtPct(data.std) : fmtNum(data.std)}<br>under=${h.underflow || 0}, over=${h.overflow || 0}`,
                  font: { size: 11, color: "#666" },
                },
              ],
            },
            { responsive: true }
          );
          
          // Render quantiles table
          const q = data.quantiles || {};
          const fmtQ = isPct ? fmtPct : fmtNum;
          const quantileRows = [
            ["分位数", "1%", "5%", "10%", "25%", "50%", "75%", "90%", "95%", "99%"],
            ["数值", 
             fmtQ(q.q01), fmtQ(q.q05), fmtQ(q.q10), fmtQ(q.q25), 
             fmtQ(q.q50), fmtQ(q.q75), fmtQ(q.q90), fmtQ(q.q95), fmtQ(q.q99)
            ],
          ];
          
          $("distQuantiles").innerHTML =
            `<tr>${quantileRows[0].map(h => `<th>${h}</th>`).join("")}</tr>` +
            `<tr>${quantileRows[1].map(c => `<td>${c}</td>`).join("")}</tr>`;
        };
        
        // Bind events
        codeSelect.addEventListener("change", updateDisplay);
        typeSelect.addEventListener("change", updateDisplay);
        periodSelect.addEventListener("change", updateDisplay);
        
        // Initial render
        updateDisplay();
      }

      function _pctToDec(x) {
        const v = Number(x);
        if (!Number.isFinite(v)) return NaN;
        return v > 1 ? v / 100.0 : v;
      }

      function _std(vals) {
        const arr = vals.filter((x) => Number.isFinite(x));
        if (arr.length < 2) return NaN;
        const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
        const v = arr.reduce((s, x) => s + (x - mean) ** 2, 0) / (arr.length - 1);
        return Math.sqrt(v);
      }

      function _percentile(vals, p) {
        const arr = vals.filter((x) => Number.isFinite(x)).sort((a, b) => a - b);
        if (arr.length === 0) return NaN;
        const pos = (Math.min(Math.max(p, 0), 100) / 100) * (arr.length - 1);
        const lo = Math.floor(pos);
        const hi = Math.ceil(pos);
        if (lo === hi) return arr[lo];
        return arr[lo] + (arr[hi] - arr[lo]) * (pos - lo);
      }

      function _calcMetricsFromNav(nav, rfAnnual) {
        const n = nav.length;
        if (n < 2) return {};
        const rets = nav.map((v, i) => (i === 0 ? 0 : (v / nav[i - 1] - 1)));
        const annRet = Math.pow(nav[n - 1] / nav[0], 252 / Math.max(1, n - 1)) - 1;
        const vol = _std(rets.slice(1)) * Math.sqrt(252);
        let peak = nav[0];
        let mdd = 0;
        for (let i = 0; i < n; i++) {
          peak = Math.max(peak, nav[i]);
          const dd = nav[i] / peak - 1;
          if (dd < mdd) mdd = dd;
        }
        const rf = Number.isFinite(rfAnnual) ? rfAnnual : 0;
        const ex = rets.slice(1).map(x => x - rf / 252);
        const stdEx = _std(ex);
        const sharpe = (Number.isFinite(stdEx) && stdEx > 0) ? (ex.reduce((a, b) => a + b, 0) / ex.length) / stdEx * Math.sqrt(252) : NaN;
        const calmar = mdd < 0 ? annRet / Math.abs(mdd) : NaN;
        return {
          cumulative_return: nav[n - 1] / nav[0] - 1,
          annualized_return: annRet,
          annualized_volatility: vol,
          max_drawdown: mdd,
          sharpe_ratio: sharpe,
          calmar_ratio: calmar,
        };
      }

      function _calcSignal(nav, rets, t, window, type) {
        const w = Math.max(2, Number(window) || 2);
        if (t < w) return NaN;
        const start = t - w;
        if (type === "return") {
          return nav[t] / nav[start] - 1;
        }
        if (type === "volatility") {
          return _std(rets.slice(start + 1, t + 1));
        }
        if (type === "downside_vol") {
          const downs = rets.slice(start + 1, t + 1).filter(x => x < 0);
          return _std(downs);
        }
        if (type === "drawdown") {
          let peak = nav[start];
          for (let i = start; i <= t; i++) peak = Math.max(peak, nav[i]);
          const dd = nav[t] / peak - 1;
          return -dd;
        }
        return NaN;
      }

      function _futureMaxDrawdown(nav, t, horizon) {
        const h = Math.max(1, Number(horizon) || 1);
        const end = Math.min(nav.length - 1, t + h);
        let peak = nav[t];
        let mdd = 0;
        for (let i = t + 1; i <= end; i++) {
          if (nav[i] > peak) peak = nav[i];
          const dd = nav[i] / peak - 1;
          if (dd < mdd) mdd = dd;
        }
        return mdd;
      }

      function _computeExposureSeries({
        nav,
        sigType,
        sigWindow,
        pIn,
        reducePct,
        recoveryMode,
        pOut,
        cooldownDays,
      }) {
        const n = nav.length;
        const rets = nav.map((v, i) => (i === 0 ? 0 : (v / nav[i - 1] - 1)));
        const sig = new Array(n).fill(NaN);
        for (let t = 0; t < n; t++) sig[t] = _calcSignal(nav, rets, t, sigWindow, sigType);

        const isLowTail = (sigType === "return");
        const pInEff = isLowTail ? (100 - Number(pIn)) : Number(pIn);
        const thrIn = _percentile(sig, pInEff);
        const pOutEff = (pOut == null || Number.isNaN(Number(pOut)))
          ? null
          : (isLowTail ? (100 - Number(pOut)) : Number(pOut));
        const thrOut = (pOutEff == null) ? null : _percentile(sig, pOutEff);

        const reduce = _pctToDec(reducePct);
        const exposure = new Array(n).fill(1.0);
        const rec = String(recoveryMode || "immediate");
        const cd = Math.max(0, Math.floor(Number(cooldownDays || 0)));

        let inReduced = false;
        let cdLeft = 0;
        for (let t = 1; t < n; t++) {
          const s = sig[t - 1];
          const trigIn = isLowTail ? (s <= thrIn) : (s >= thrIn);

          if (!inReduced) {
            if (Number.isFinite(s) && Number.isFinite(thrIn) && trigIn) {
              inReduced = true;
              cdLeft = cd;
            }
          } else {
            if (cdLeft > 0) {
              cdLeft -= 1;
            } else if (rec === "hysteresis" && thrOut != null) {
              // hysteresis exit condition (opposite direction)
              const trigOut = isLowTail ? (s >= thrOut) : (s <= thrOut);
              if (Number.isFinite(s) && Number.isFinite(thrOut) && trigOut) inReduced = false;
            } else {
              // immediate exit (or cooldown-only mode ends here): if not triggered, exit
              if (!(Number.isFinite(s) && Number.isFinite(thrIn) && trigIn)) inReduced = false;
            }
          }

          exposure[t] = inReduced ? (1.0 - reduce) : 1.0;
        }

        return { exposure, sig, thrIn, thrOut };
      }

      function _runRiskExperimentOnSeries({
        name,
        dates,
        nav,
        sigType,
        sigWindow,
        futureWindow,
        eventThrPct,
        sigPct,
        reducePct,
        rfAnnual,
        recoveryMode = "immediate",
        pOut = null,
        cooldownDays = 0,
      }) {
        const n = nav.length;
        if (n < 2) return null;
        const rets = nav.map((v, i) => (i === 0 ? 0 : (v / nav[i - 1] - 1)));
        const exp0 = _computeExposureSeries({
          nav,
          sigType,
          sigWindow,
          pIn: sigPct,
          reducePct,
          recoveryMode,
          pOut,
          cooldownDays,
        });
        const exposure = exp0.exposure;
        const sig = exp0.sig;
        const thrIn = exp0.thrIn;
        const thrOut = exp0.thrOut;

        const navAdj = new Array(n).fill(1.0);
        for (let t = 1; t < n; t++) {
          navAdj[t] = navAdj[t - 1] * (1.0 + rets[t] * exposure[t]);
        }

        const baseMetrics = _calcMetricsFromNav(nav, rfAnnual);
        const adjMetrics = _calcMetricsFromNav(navAdj, rfAnnual);

        const future = [];
        const sigValid = [];
        for (let t = 0; t < n - 1; t++) {
          if (!Number.isFinite(sig[t])) continue;
          const dd = _futureMaxDrawdown(nav, t, futureWindow);
          future.push(dd);
          sigValid.push(sig[t]);
        }
        const q20 = _percentile(sigValid, 20);
        const q40 = _percentile(sigValid, 40);
        const q60 = _percentile(sigValid, 60);
        const q80 = _percentile(sigValid, 80);
        const bins = [
          { label: "Q1(<=P20)", vals: [] },
          { label: "Q2(P20-40)", vals: [] },
          { label: "Q3(P40-60)", vals: [] },
          { label: "Q4(P60-80)", vals: [] },
          { label: "Q5(>P80)", vals: [] },
        ];
        for (let i = 0; i < sigValid.length; i++) {
          const s = sigValid[i];
          const dd = future[i];
          if (!Number.isFinite(dd)) continue;
          if (s <= q20) bins[0].vals.push(dd);
          else if (s <= q40) bins[1].vals.push(dd);
          else if (s <= q60) bins[2].vals.push(dd);
          else if (s <= q80) bins[3].vals.push(dd);
          else bins[4].vals.push(dd);
        }
        const eventThr = -Math.abs(_pctToDec(eventThrPct));
        const binStats = bins.map(b => {
          const arr = b.vals;
          const mean = arr.length ? (arr.reduce((a, x) => a + x, 0) / arr.length) : NaN;
          const p10 = _percentile(arr, 10);
          const p50 = _percentile(arr, 50);
          const p90 = _percentile(arr, 90);
          const hit = arr.length ? arr.filter(x => x <= eventThr).length / arr.length : NaN;
          return { label: b.label, count: arr.length, mean, p10, p50, p90, hit };
        });

        const isLowTail = (sigType === "return");
        const riskLabel = isLowTail ? "Q1(<=P20)" : "Q5(>P80)";
        const riskRow = binStats.find(x => x.label === riskLabel) || null;
        const hitRisk = riskRow ? Number(riskRow.hit) : NaN;

        return {
          name,
          dates,
          nav,
          navAdj,
          baseMetrics,
          adjMetrics,
          binStats,
          thrIn,
          thrOut,
          hitRisk,
          recoveryMode: String(recoveryMode || "immediate"),
          pOut: (pOut == null ? null : Number(pOut)),
          cooldownDays: Number(cooldownDays || 0),
          futureWindow: Number(futureWindow),
          eventThrPct: Number(eventThrPct),
        };
      }

      function _renderRiskMetricsTable(elId, base, adj) {
        const el = $(elId);
        if (!el) return;
        const row = (label, a, b, fmt) => `<tr><td>${label}</td><td>${fmt(a)}</td><td>${fmt(b)}</td></tr>`;
        const fmtPct2 = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtPct(Number(x));
        const fmtNum2 = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtNum(Number(x));
        el.innerHTML =
          `<tr><th>指标</th><th>原策略</th><th>信号降仓</th></tr>` +
          row("累计收益", base.cumulative_return, adj.cumulative_return, fmtPct2) +
          row("年化收益", base.annualized_return, adj.annualized_return, fmtPct2) +
          row("年化波动", base.annualized_volatility, adj.annualized_volatility, fmtPct2) +
          row("最大回撤", base.max_drawdown, adj.max_drawdown, fmtPct2) +
          row("夏普", base.sharpe_ratio, adj.sharpe_ratio, fmtNum2) +
          row("卡玛", base.calmar_ratio, adj.calmar_ratio, fmtNum2);
      }

      function _renderRiskSignalTable(elId, stats) {
        const el = $(elId);
        if (!el) return;
        if (!stats || stats.length === 0) {
          el.innerHTML = "";
          return;
        }
        const fmtP = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtPct(Number(x));
        const fmtN = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : String(x);
        el.innerHTML =
          `<tr><th>分位组</th><th>样本数</th><th>未来回撤均值</th><th>P10</th><th>P50</th><th>P90</th><th>事件命中率</th></tr>` +
          stats.map(r =>
            `<tr><td>${r.label}</td><td>${fmtN(r.count)}</td><td>${fmtP(r.mean)}</td><td>${fmtP(r.p10)}</td><td>${fmtP(r.p50)}</td><td>${fmtP(r.p90)}</td><td>${fmtP(r.hit)}</td></tr>`
          ).join("");
      }

      function renderRotationHoldingPeriodLengthDistributions(holdings, navDates) {
        const sel = $("rotHoldLenCodeSelect");
        const div = $("rotHoldLenHist");
        const tbl = $("rotHoldLenQuantiles");
        if (!sel || !div || !tbl) return;
        if (!Array.isArray(holdings) || !Array.isArray(navDates) || navDates.length === 0) {
          div.innerHTML = "<div class='muted'>请先运行轮动回测</div>";
          tbl.innerHTML = "";
          sel.innerHTML = "";
          return;
        }

        const idxByDate = new Map(navDates.map((d, i) => [String(d), i]));
        const samplesByCode = {};
        for (const p of holdings) {
          const picks = (p && p.picks) ? p.picks : [];
          if (!Array.isArray(picks) || picks.length === 0) continue;
          const s = String(p.start_date || "");
          const e = String(p.end_date || "");
          const si = idxByDate.get(s);
          const ei = idxByDate.get(e);
          if (si == null || ei == null) continue;
          const len = Number(ei) - Number(si) + 1;
          if (!Number.isFinite(len) || len <= 0) continue;
          for (const c0 of picks) {
            const c = String(c0);
            if (!samplesByCode[c]) samplesByCode[c] = [];
            samplesByCode[c].push(len);
          }
        }

        const codes = Object.keys(samplesByCode).sort();
        sel.innerHTML = codes.map(c => `<option value="${esc(c)}">${esc(c)}</option>`).join("");
        if (codes.length === 0) {
          div.innerHTML = "<div class='muted'>无持仓周期数据（可能回测全程空仓）</div>";
          tbl.innerHTML = "";
          return;
        }

        const _histInt = (arr) => {
          const xs = arr.filter(x => Number.isFinite(x)).map(x => Math.floor(Number(x)));
          if (xs.length === 0) return { x: [], y: [] };
          const minv = Math.min(...xs);
          const maxv = Math.max(...xs);
          const range = maxv - minv + 1;
          // If range is reasonable, show discrete bars per length; else bin into ~30 buckets.
          if (range <= 120) {
            const counts = new Array(range).fill(0);
            for (const v of xs) counts[v - minv] += 1;
            const x = [];
            for (let i = 0; i < range; i++) x.push(minv + i);
            return { x, y: counts };
          }
          const bins = 30;
          const w = Math.max(1, Math.ceil(range / bins));
          const nBins = Math.ceil(range / w);
          const y = new Array(nBins).fill(0);
          for (const v of xs) {
            const k = Math.min(nBins - 1, Math.floor((v - minv) / w));
            y[k] += 1;
          }
          const x = new Array(nBins).fill(0).map((_, i) => `${minv + i * w}~${Math.min(maxv, minv + (i + 1) * w - 1)}`);
          return { x, y };
        };

        const _quantiles = (arr) => {
          const xs = arr.filter(x => Number.isFinite(x)).map(x => Number(x));
          const q = (p) => _percentile(xs, p);
          return {
            count: xs.length,
            mean: xs.length ? xs.reduce((a, b) => a + b, 0) / xs.length : NaN,
            std: _std(xs),
            q01: q(1),
            q05: q(5),
            q10: q(10),
            q25: q(25),
            q50: q(50),
            q75: q(75),
            q90: q(90),
            q95: q(95),
            q99: q(99),
          };
        };

        const update = () => {
          const code = sel.value;
          const arr = samplesByCode[code] || [];
          if (!arr.length) {
            div.innerHTML = "<div class='muted'>无数据</div>";
            tbl.innerHTML = "";
            return;
          }
          const h = _histInt(arr);
          Plotly.newPlot("rotHoldLenHist", [{
            x: h.x,
            y: h.y,
            type: "bar",
            marker: { color: "#4c78a8" },
            hovertemplate: "len=%{x}<br>count=%{y}<extra></extra>",
          }], {
            title: { text: `${code} 持仓周期长度分布（交易日）`, font: { size: 14 } },
            margin: { t: 40, b: 60 },
            xaxis: { title: "持仓长度（交易日）", tickangle: (h.x.length > 24 ? -45 : 0) },
            yaxis: { title: "频数" },
          }, { responsive: true, displayModeBar: false });

          const s = _quantiles(arr);
          const fmtI = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : String(Math.round(Number(x)));
          const fmtF = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtNum(Number(x));
          tbl.innerHTML =
            `<tr><th>统计</th><th>值</th></tr>` +
            `<tr><td>样本数</td><td>${fmtI(s.count)}</td></tr>` +
            `<tr><td>均值</td><td>${fmtF(s.mean)}</td></tr>` +
            `<tr><td>标准差</td><td>${fmtF(s.std)}</td></tr>` +
            `<tr><td>1%</td><td>${fmtI(s.q01)}</td></tr>` +
            `<tr><td>5%</td><td>${fmtI(s.q05)}</td></tr>` +
            `<tr><td>10%</td><td>${fmtI(s.q10)}</td></tr>` +
            `<tr><td>25%</td><td>${fmtI(s.q25)}</td></tr>` +
            `<tr><td>50%</td><td>${fmtI(s.q50)}</td></tr>` +
            `<tr><td>75%</td><td>${fmtI(s.q75)}</td></tr>` +
            `<tr><td>90%</td><td>${fmtI(s.q90)}</td></tr>` +
            `<tr><td>95%</td><td>${fmtI(s.q95)}</td></tr>` +
            `<tr><td>99%</td><td>${fmtI(s.q99)}</td></tr>`;
        };

        sel.onchange = update;
        update();
      }

      function renderHoldingLenDistInto(prefix, holdings, navDates) {
        const sel = $(`${prefix}HoldLenCodeSelect`);
        const div = $(`${prefix}HoldLenHist`);
        const tbl = $(`${prefix}HoldLenQuantiles`);
        if (!sel || !div || !tbl) return;
        if (!Array.isArray(holdings) || !Array.isArray(navDates) || navDates.length === 0) {
          div.innerHTML = "<div class='muted'>无数据</div>";
          tbl.innerHTML = "";
          sel.innerHTML = "";
          return;
        }
        const idxByDate = new Map(navDates.map((d, i) => [String(d), i]));
        const samplesByCode = {};
        for (const p of holdings) {
          const picks = (p && p.picks) ? p.picks : [];
          if (!Array.isArray(picks) || picks.length === 0) continue;
          const s = String(p.start_date || "");
          const e = String(p.end_date || "");
          const si = idxByDate.get(s);
          const ei = idxByDate.get(e);
          if (si == null || ei == null) continue;
          const len = Number(ei) - Number(si) + 1;
          if (!Number.isFinite(len) || len <= 0) continue;
          for (const c0 of picks) {
            const c = String(c0);
            if (!samplesByCode[c]) samplesByCode[c] = [];
            samplesByCode[c].push(len);
          }
        }
        const codes = Object.keys(samplesByCode).sort();
        sel.innerHTML = codes.map(c => `<option value="${esc(c)}">${esc(c)}</option>`).join("");
        if (codes.length === 0) {
          div.innerHTML = "<div class='muted'>无持仓周期数据</div>";
          tbl.innerHTML = "";
          return;
        }
        const _histInt = (arr) => {
          const xs = arr.filter(x => Number.isFinite(x)).map(x => Math.floor(Number(x)));
          if (xs.length === 0) return { x: [], y: [] };
          const minv = Math.min(...xs);
          const maxv = Math.max(...xs);
          const range = maxv - minv + 1;
          if (range <= 120) {
            const counts = new Array(range).fill(0);
            for (const v of xs) counts[v - minv] += 1;
            const x = [];
            for (let i = 0; i < range; i++) x.push(minv + i);
            return { x, y: counts };
          }
          const bins = 30;
          const w = Math.max(1, Math.ceil(range / bins));
          const nBins = Math.ceil(range / w);
          const y = new Array(nBins).fill(0);
          for (const v of xs) {
            const k = Math.min(nBins - 1, Math.floor((v - minv) / w));
            y[k] += 1;
          }
          const x = new Array(nBins).fill(0).map((_, i) => `${minv + i * w}~${Math.min(maxv, minv + (i + 1) * w - 1)}`);
          return { x, y };
        };
        const _quantiles = (arr) => {
          const xs = arr.filter(x => Number.isFinite(x)).map(x => Number(x));
          const q = (p) => _percentile(xs, p);
          return {
            count: xs.length,
            mean: xs.length ? xs.reduce((a, b) => a + b, 0) / xs.length : NaN,
            std: _std(xs),
            q01: q(1), q05: q(5), q10: q(10), q25: q(25), q50: q(50), q75: q(75), q90: q(90), q95: q(95), q99: q(99),
          };
        };
        const update = () => {
          const code = sel.value;
          const arr = samplesByCode[code] || [];
          if (!arr.length) {
            div.innerHTML = "<div class='muted'>无数据</div>";
            tbl.innerHTML = "";
            return;
          }
          const h = _histInt(arr);
          Plotly.newPlot(`${prefix}HoldLenHist`, [{
            x: h.x, y: h.y, type: "bar",
            marker: { color: "#4c78a8" },
            hovertemplate: "len=%{x}<br>count=%{y}<extra></extra>",
          }], {
            title: { text: `${code} 持仓周期长度分布（交易日）`, font: { size: 14 } },
            margin: { t: 40, b: 60 },
            xaxis: { title: "持仓长度（交易日）", tickangle: (h.x.length > 24 ? -45 : 0) },
            yaxis: { title: "频数" },
          }, { responsive: true, displayModeBar: false });
          const s = _quantiles(arr);
          const fmtI = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : String(Math.round(Number(x)));
          const fmtF = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtNum(Number(x));
          tbl.innerHTML =
            `<tr><th>统计</th><th>值</th></tr>` +
            `<tr><td>样本数</td><td>${fmtI(s.count)}</td></tr>` +
            `<tr><td>均值</td><td>${fmtF(s.mean)}</td></tr>` +
            `<tr><td>标准差</td><td>${fmtF(s.std)}</td></tr>` +
            `<tr><td>1%</td><td>${fmtI(s.q01)}</td></tr>` +
            `<tr><td>5%</td><td>${fmtI(s.q05)}</td></tr>` +
            `<tr><td>10%</td><td>${fmtI(s.q10)}</td></tr>` +
            `<tr><td>25%</td><td>${fmtI(s.q25)}</td></tr>` +
            `<tr><td>50%</td><td>${fmtI(s.q50)}</td></tr>` +
            `<tr><td>75%</td><td>${fmtI(s.q75)}</td></tr>` +
            `<tr><td>90%</td><td>${fmtI(s.q90)}</td></tr>` +
            `<tr><td>95%</td><td>${fmtI(s.q95)}</td></tr>` +
            `<tr><td>99%</td><td>${fmtI(s.q99)}</td></tr>`;
        };
        sel.onchange = update;
        update();
      }

      // --- Rule-book based risk-control research ---
      window.__riskRuleBook = window.__riskRuleBook || {}; // code -> { sigType, k, p, reduce }
      window.__rcLastSearch = window.__rcLastSearch || {}; // code -> results[]

      function _parseCsvNumsRaw(s) {
        return String(s || "")
          .split(",")
          .map(x => x.trim())
          .filter(Boolean)
          .map(Number)
          .filter(x => Number.isFinite(x));
      }

      function _rcGetBaseline() {
        return window.__lastBaselineResult || lastBaseline || null;
      }

      function _rcInitAssetSelect() {
        const b = _rcGetBaseline();
        const sel = $("rcAssetCode");
        if (!sel) return;
        const prev = (sel.value || "").trim();
        const codes = (b && b.codes) ? b.codes : Array.from(selected);
        sel.innerHTML = (codes || []).map(c => `<option value="${esc(c)}">${esc(c)}</option>`).join("");
        // preserve selection if possible
        if (prev && (codes || []).includes(prev)) {
          sel.value = prev;
        }
      }

      function _rcReadInputs() {
        const rfRaw = ($("rf").value || "").trim();
        let rf = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (rf > 1.0) rf = rf / 100.0;
        const kList = _parseCsvNumsRaw(($("rcKList").value || "20").trim()).map(x => Math.max(2, Math.floor(x)));
        const pList = _parseCsvNumsRaw(($("rcPList").value || "80").trim()).map(x => Math.min(99, Math.max(1, x)));
        const pOutList = _parseCsvNumsRaw(($("rcPOutList") && $("rcPOutList").value ? $("rcPOutList").value : "").trim())
          .map(x => Math.min(99, Math.max(1, x)));
        const rList = _parseCsvNumsRaw(($("rcReduceList").value || "50").trim()).map(x => Math.min(100, Math.max(0, x)));
        const sigTypes = Array.from(document.querySelectorAll("input.rcSig")).filter(x => x.checked).map(x => x.value);
        const recModes = Array.from(document.querySelectorAll("input.rcRec")).filter(x => x.checked).map(x => x.value);
        const cooldownList = _parseCsvNumsRaw(($("rcCooldownList") && $("rcCooldownList").value ? $("rcCooldownList").value : "0").trim())
          .map(x => Math.max(0, Math.floor(x)));
        const futureHListRaw = _parseCsvNumsRaw(($("rcFutureH").value || "20").trim());
        const futureHList = (futureHListRaw.length ? futureHListRaw : [20]).map(x => Math.max(1, Math.floor(x)));
        const eventThrListRaw = _parseCsvNumsRaw(($("rcEventThr").value || "10").trim());
        const eventThrList = (eventThrListRaw.length ? eventThrListRaw : [10]);
        const objective = ($("rcObjective").value || "calmar_ratio");
        const lambda = Number(($("rcLambda") && $("rcLambda").value ? $("rcLambda").value : "1.0").trim());
        return { rf, kList, pList, pOutList, rList, sigTypes, recModes, cooldownList, futureHList, eventThrList, objective, lambda };
      }

      function _rcObjectiveScore(objKey, exp, lambda) {
        const metrics = exp ? exp.adjMetrics : null;
        if (!metrics) return -Infinity;
        const hit = (exp && Number.isFinite(Number(exp.hitRisk))) ? Number(exp.hitRisk) : NaN;
        const lam = (Number.isFinite(Number(lambda)) ? Number(lambda) : 0);
        if (objKey === "min_mdd") {
          const mdd = Number(metrics.max_drawdown);
          // max_drawdown is negative; best is closest to 0 => minimize absolute drawdown.
          return Number.isFinite(mdd) ? (-Math.abs(mdd)) : -Infinity;
        }
        if (objKey === "sharpe_ratio") return Number(metrics.sharpe_ratio);
        if (objKey === "calmar_minus_hit") return Number(metrics.calmar_ratio) - lam * (Number.isFinite(hit) ? hit : 0);
        if (objKey === "sharpe_minus_hit") return Number(metrics.sharpe_ratio) - lam * (Number.isFinite(hit) ? hit : 0);
        return Number(metrics.calmar_ratio); // default
      }

      function _rcSearchOne(code) {
        const b = _rcGetBaseline();
        if (!b || !b.nav || !b.nav.series || !b.nav.dates) {
          setMsg("请先运行等权分析（上方“运行分析”），再做逐标的风控搜索。");
          return [];
        }
        const dates = b.nav.dates;
        const nav = b.nav.series[code];
        if (!nav || nav.length < 2) {
          setMsg(`无标的 NAV 序列：${code}`);
          return [];
        }
        const { rf, kList, pList, pOutList, rList, sigTypes, recModes, cooldownList, futureHList, eventThrList, objective, lambda } = _rcReadInputs();

        const results = [];
        for (const sigType of sigTypes) {
          for (const k of kList) {
            for (const p of pList) {
              for (const reduce of rList) {
                for (const futureH of futureHList) {
                  for (const eventThr of eventThrList) {
                    for (const recMode of recModes.length ? recModes : ["immediate"]) {
                      const pOutCandidates = (recMode === "hysteresis") ? (pOutList.length ? pOutList : [Math.max(1, Math.min(99, Number(p) - 20))]) : [null];
                      const cdCandidates = (recMode === "cooldown") ? (cooldownList.length ? cooldownList : [0]) : [0];
                      for (const pOut of pOutCandidates) {
                        for (const cd of cdCandidates) {
                          const exp = _runRiskExperimentOnSeries({
                            name: code,
                            dates,
                            nav,
                            sigType,
                            sigWindow: k,
                            futureWindow: futureH,
                            eventThrPct: eventThr,
                            sigPct: p,
                            reducePct: reduce,
                            rfAnnual: rf,
                            recoveryMode: recMode,
                            pOut,
                            cooldownDays: cd,
                          });
                          if (!exp || !exp.adjMetrics) continue;
                          const score = _rcObjectiveScore(objective, exp, lambda);
                          if (!Number.isFinite(score)) continue;
                          results.push({
                            code,
                            sigType,
                            k,
                            p,
                            pOut,
                            cooldownDays: cd,
                            recoveryMode: recMode,
                            reduce,
                            futureH,
                            eventThr,
                            thrIn: exp.thrIn,
                            thrOut: exp.thrOut,
                            hitRisk: exp.hitRisk,
                            exp,
                            score,
                          });
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        results.sort((a, b) => (Number(b.score) - Number(a.score)));
        window.__rcLastSearch[code] = results;
        return results;
      }

      function _rcRenderAssetTop(code) {
        const el = $("rcAssetTop");
        if (!el) return;
        const allRows = (window.__rcLastSearch[code] || []);
        const limSel = $("rcAssetTopLimit");
        const limVal = limSel ? String(limSel.value || "12") : "12";
        let rows = allRows;
        if (limVal !== "all") {
          const n = Math.max(1, Math.floor(Number(limVal || 12)));
          rows = allRows.slice(0, n);
        }
        const cntEl = $("rcAssetTopCount");
        if (cntEl) cntEl.textContent = `共 ${allRows.length} 条，当前展示 ${rows.length} 条`;
        if (rows.length === 0) {
          el.innerHTML = `<tr><th>提示</th></tr><tr><td class="muted">暂无结果，请点击“搜索当前标的”。</td></tr>`;
          return;
        }
        const fmtP = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtPct(Number(x));
        const fmtN = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtNum(Number(x));
        el.innerHTML =
          `<tr><th>#</th><th>信号</th><th>K</th><th>P_in</th><th>恢复</th><th>P_out/N</th><th>降仓Y</th><th>H</th><th>X</th><th>风险命中率</th><th>年化</th><th>波动</th><th>MDD</th><th>夏普</th><th>卡玛</th><th>操作</th></tr>` +
          rows.map((r, i) => {
            const m = r.exp.adjMetrics || {};
            const rec = String(r.recoveryMode || "immediate");
            const recLabel = (rec === "hysteresis") ? "滞回" : (rec === "cooldown" ? "冷却" : "立即");
            const pOutOrN = (rec === "hysteresis") ? (`Pout=${r.pOut==null? "-" : String(r.pOut)+"%"}`) : (`N=${String(r.cooldownDays || 0)}`);
            return `<tr>
              <td>${i + 1}</td>
              <td>${esc(r.sigType)}</td>
              <td>${esc(String(r.k))}</td>
              <td>${esc(String(r.p))}%</td>
              <td>${esc(recLabel)}</td>
              <td>${esc(pOutOrN)}</td>
              <td>${esc(String(r.reduce))}%</td>
              <td>${esc(String(r.futureH || "-"))}</td>
              <td>${esc(String(r.eventThr || "-"))}%</td>
              <td>${fmtP(r.hitRisk)}</td>
              <td>${fmtP(m.annualized_return)}</td>
              <td>${fmtP(m.annualized_volatility)}</td>
              <td>${fmtP(m.max_drawdown)}</td>
              <td>${fmtN(m.sharpe_ratio)}</td>
              <td>${fmtN(m.calmar_ratio)}</td>
              <td><button class="rcSetRuleBtn" data-code="${esc(code)}" data-idx="${i}">设为规则</button></td>
            </tr>`;
          }).join("");
      }

      function _rcRenderRuleBook() {
        const el = $("rcRuleBook");
        if (!el) return;
        const b = _rcGetBaseline();
        const codes = (b && b.codes) ? b.codes : Array.from(selected);
        const rb = window.__riskRuleBook || {};
        el.innerHTML =
          `<tr><th>标的</th><th>规则</th><th>参数</th><th>操作</th></tr>` +
          (codes || []).map((c) => {
            const r = rb[c];
            if (!r) {
              return `<tr><td>${esc(c)}</td><td class="muted">未设置</td><td class="muted">-</td><td class="muted">先做搜索</td></tr>`;
            }
            const ruleText = `${r.sigType}${r.sigType==="return" ? "(低分位触发)" : ""}`;
            const rec = String(r.recoveryMode || "immediate");
            const recLabel = (rec === "hysteresis") ? `滞回(Pout=${r.pOut==null? "-" : String(r.pOut)+"%"})` : (rec === "cooldown" ? `冷却(N=${String(r.cooldownDays||0)})` : "立即恢复");
            const paramText = `K=${r.k}, Pin=${r.p}%, ${recLabel}, 降仓=${r.reduce}%`;
            return `<tr><td>${esc(c)}</td><td>${esc(ruleText)}</td><td>${esc(paramText)}</td><td><button class="rcDelRuleBtn" data-code="${esc(c)}">删除</button></td></tr>`;
          }).join("");
      }

      function _rcRenderAssetChart(code) {
        const b = _rcGetBaseline();
        if (!b || !b.nav || !b.nav.series) return;
        const baseNav = b.nav.series[code] || [];
        const dates = b.nav.dates || [];
        const top = (window.__rcLastSearch[code] || [])[0];
        if (!top) {
          $("rcAssetChart").innerHTML = "<div class='muted'>暂无图表：请先搜索当前标的</div>";
          return;
        }
        const navAdj = top.exp.navAdj || [];
        Plotly.newPlot("rcAssetChart", [
          { x: dates, y: baseNav, mode: "lines", name: `${code}-BH`, line: { width: 1.2, color: "#666" } },
          { x: dates, y: navAdj, mode: "lines", name: `${code}-风控`, line: { width: 1.5, color: "#d62728" } },
        ], { title: `单标的：${code} buy&hold vs 风控（Top1）`, margin: { t: 40 }, yaxis: { type: "log", tickformat: ".0f", gridcolor: "#eee" } }, { responsive: true, displayModeBar: false });
      }

      function _rcAttachAssetTopHandlers() {
        const el = $("rcAssetTop");
        if (!el) return;
        el.addEventListener("click", (ev) => {
          const t = ev.target;
          if (!(t && t.classList && t.classList.contains("rcSetRuleBtn"))) return;
          const code = t.dataset.code;
          const idx = Number(t.dataset.idx || "0");
          const rows = (window.__rcLastSearch[code] || []);
          const row = rows[idx];
          if (!row) return;
          window.__riskRuleBook[code] = {
            sigType: row.sigType,
            k: row.k,
            p: row.p,
            reduce: row.reduce,
            recoveryMode: row.recoveryMode || "immediate",
            pOut: row.pOut == null ? null : Number(row.pOut),
            cooldownDays: Number(row.cooldownDays || 0),
          };
          _rcRenderRuleBook();
        });
      }

      function _rcAttachRuleBookHandlers() {
        const el = $("rcRuleBook");
        if (!el) return;
        el.addEventListener("click", (ev) => {
          const t = ev.target;
          if (!(t && t.classList && t.classList.contains("rcDelRuleBtn"))) return;
          const code = t.dataset.code;
          if (code && window.__riskRuleBook) delete window.__riskRuleBook[code];
          _rcRenderRuleBook();
        });
      }

      function _rcBuildExposureByCode() {
        const b = _rcGetBaseline();
        if (!b || !b.nav || !b.nav.series) return null;
        const { rf, futureHList, eventThrList } = _rcReadInputs();
        const futureH = (futureHList && futureHList.length) ? Number(futureHList[0]) : 20;
        const eventThr = (eventThrList && eventThrList.length) ? Number(eventThrList[0]) : 10;
        const dates = b.nav.dates || [];
        const out = {};
        for (const code of (b.codes || [])) {
          const rule = window.__riskRuleBook[code];
          if (!rule) continue;
          const nav = b.nav.series[code];
          const exp = _runRiskExperimentOnSeries({
            name: code,
            dates,
            nav,
            sigType: rule.sigType,
            sigWindow: rule.k,
            futureWindow: futureH,
            eventThrPct: eventThr,
            sigPct: rule.p,
            reducePct: rule.reduce,
            rfAnnual: rf,
            recoveryMode: rule.recoveryMode || "immediate",
            pOut: rule.pOut == null ? null : Number(rule.pOut),
            cooldownDays: Number(rule.cooldownDays || 0),
          });
          if (!exp) continue;
          const exp2 = _computeExposureSeries({
            nav,
            sigType: rule.sigType,
            sigWindow: rule.k,
            pIn: rule.p,
            reducePct: rule.reduce,
            recoveryMode: rule.recoveryMode || "immediate",
            pOut: rule.pOut == null ? null : Number(rule.pOut),
            cooldownDays: Number(rule.cooldownDays || 0),
          });
          const exposure = exp2.exposure;
          out[code] = { exposure, binStats: exp.binStats };
        }
        return { dates, byCode: out };
      }

      function _rcSimulateEwComposite() {
        const b = _rcGetBaseline();
        if (!b || !b.nav || !b.nav.series) return null;
        const expoPack = _rcBuildExposureByCode();
        if (!expoPack) return null;
        const dates = b.nav.dates || [];
        const codes = b.codes || [];
        const reb = ($("rebalance").value || "yearly").toLowerCase();
        const rfRaw = ($("rf").value || "").trim();
        let rf = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (rf > 1.0) rf = rf / 100.0;

        const navByCode = {};
        const retByCode = {};
        for (const c of codes) {
          const nav = b.nav.series[c] || [];
          navByCode[c] = nav;
          retByCode[c] = nav.map((v, i) => (i === 0 ? 0 : (v / nav[i - 1] - 1)));
        }

        const n = dates.length;
        const w = {};
        for (const c of codes) w[c] = 1.0 / Math.max(1, codes.length);
        const navBase = new Array(n).fill(1.0);
        const navAdj = new Array(n).fill(1.0);

        const keyOf = (ds) => {
          const d = new Date(ds);
          const y = d.getFullYear();
          const m = d.getMonth() + 1;
          const q = Math.floor((m - 1) / 3) + 1;
          const onejan = new Date(d.getFullYear(), 0, 1);
          const day = Math.floor((d - onejan) / 86400000);
          const wk = Math.floor((day + onejan.getDay()) / 7) + 1;
          if (reb === "weekly") return `${y}-W${wk}`;
          if (reb === "monthly") return `${y}-${m}`;
          if (reb === "quarterly") return `${y}-Q${q}`;
          if (reb === "yearly") return `${y}`;
          if (reb === "daily") return `${y}-${m}-${d.getDate()}`;
          return "all"; // none
        };

        for (let t = 1; t < n; t++) {
          // portfolio return using yesterday weights (drift inside period)
          let rBase = 0.0;
          let rAdj = 0.0;
          for (const c of codes) {
            const wi = Number(w[c] || 0);
            const ri = Number((retByCode[c] && retByCode[c][t]) || 0);
            const expo = (expoPack.byCode[c] && expoPack.byCode[c].exposure) ? Number(expoPack.byCode[c].exposure[t]) : 1.0;
            rBase += wi * ri;
            rAdj += wi * (expo * ri);
          }
          navBase[t] = navBase[t - 1] * (1.0 + rBase);
          navAdj[t] = navAdj[t - 1] * (1.0 + rAdj);

          // drift weights by raw returns (not exposure) then renormalize
          let sum = 0.0;
          const wNew = {};
          for (const c of codes) {
            const wi = Number(w[c] || 0);
            const ri = Number((retByCode[c] && retByCode[c][t]) || 0);
            const v = wi * (1.0 + ri);
            wNew[c] = v;
            sum += v;
          }
          if (sum > 0) {
            for (const c of codes) w[c] = wNew[c] / sum;
          }

          // rebalance at period boundary: if current key != next key, reset weights for next day
          if (reb !== "none" && t < n - 1) {
            const k1 = keyOf(dates[t]);
            const k2 = keyOf(dates[t + 1]);
            if (k1 !== k2) {
              for (const c of codes) w[c] = 1.0 / Math.max(1, codes.length);
            }
          }
        }

        const mBase = _calcMetricsFromNav(navBase, rf);
        const mAdj = _calcMetricsFromNav(navAdj, rf);

        // Use average binStats across codes as a simple summary table
        const stats = [];
        const bins = ["Q1(<=P20)", "Q2(P20-40)", "Q3(P40-60)", "Q4(P60-80)", "Q5(>P80)"];
        for (const bname of bins) {
          const rows = [];
          for (const c of codes) {
            const bs = (expoPack.byCode[c] && expoPack.byCode[c].binStats) ? expoPack.byCode[c].binStats : null;
            const one = bs ? bs.find(x => x.label === bname) : null;
            if (one) rows.push(one);
          }
          const mean = rows.length ? rows.reduce((a, x) => a + Number(x.mean || 0), 0) / rows.length : NaN;
          const hit = rows.length ? rows.reduce((a, x) => a + Number(x.hit || 0), 0) / rows.length : NaN;
          stats.push({ label: bname, count: rows.length, mean, p10: NaN, p50: NaN, p90: NaN, hit });
        }

        return { dates, navBase, navAdj, mBase, mAdj, binStats: stats };
      }

      function _rcSimulateRotationComposite() {
        const rot = window.__lastRotationResult || null;
        const b = _rcGetBaseline();
        if (!rot || !rot.nav || !rot.nav.series || !rot.nav.dates) return null;
        if (!b || !b.nav || !b.nav.dates) return null;
        const expoPack = _rcBuildExposureByCode();
        if (!expoPack) return null;
        const rfRaw = ($("rf").value || "").trim();
        let rf = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (rf > 1.0) rf = rf / 100.0;

        const dates = rot.nav.dates || [];
        const nav = rot.nav.series.ROTATION || [];
        if (nav.length < 2) return null;
        const rets = nav.map((v, i) => (i === 0 ? 0 : (v / nav[i - 1] - 1)));

        // map exposure by date for each code (baseline dates axis)
        const expoByCodeByDate = {};
        const idxByDateBase = new Map((expoPack.dates || []).map((d, i) => [String(d), i]));
        for (const [c, pack] of Object.entries(expoPack.byCode || {})) {
          const arr = pack.exposure || [];
          expoByCodeByDate[c] = (ds) => {
            const j = idxByDateBase.get(String(ds));
            if (j == null) return 1.0;
            const v = arr[j];
            return Number.isFinite(Number(v)) ? Number(v) : 1.0;
          };
        }

        // held codes per date from rotation holdings
        const held = new Array(dates.length).fill(null).map(() => []);
        const idxByDate = new Map(dates.map((d, i) => [String(d), i]));
        const periods = rot.holding_streaks || rot.holdings || [];
        for (const p of periods) {
          const s = String(p.start_date || "");
          const e = String(p.end_date || "");
          const picks = (p.picks || []).map(String);
          const si = idxByDate.get(s);
          const ei = idxByDate.get(e);
          if (si == null || ei == null) continue;
          for (let i = si; i <= ei; i++) {
            held[i] = picks;
          }
        }

        const navAdj = new Array(nav.length).fill(1.0);
        for (let t = 1; t < nav.length; t++) {
          const codes = held[t] || [];
          let expo = 0.0;
          if (codes.length === 0) {
            expo = 0.0;
          } else {
            let sum = 0.0;
            let cnt = 0;
            for (const c of codes) {
              if (!expoByCodeByDate[c]) continue;
              sum += expoByCodeByDate[c](dates[t]);
              cnt += 1;
            }
            expo = cnt ? (sum / cnt) : 1.0;
          }
          navAdj[t] = navAdj[t - 1] * (1.0 + rets[t] * expo);
        }
        const mBase = _calcMetricsFromNav(nav, rf);
        const mAdj = _calcMetricsFromNav(navAdj, rf);
        return { dates, navBase: nav, navAdj, mBase, mAdj, binStats: [] };
      }

      function rcSearchCurrentAsset() {
        const b = _rcGetBaseline();
        if (!b) return;
        // Do NOT reset selection here; only ensure options exist.
        if (!$("rcAssetCode") || ($("rcAssetCode").options || []).length === 0) _rcInitAssetSelect();
        const code = ($("rcAssetCode").value || "").trim();
        if (!code) return;
        $("status").textContent = `搜索中(${code})...`;
        setTimeout(() => {
          _rcSearchOne(code);
          _rcRenderAssetTop(code);
          _rcRenderAssetChart(code);
          _rcRenderRuleBook();
          $("status").textContent = "";
        }, 10);
      }

      function rcSearchAllAssets() {
        const b = _rcGetBaseline();
        if (!b || !b.codes) return setMsg("请先运行等权分析。");
        _rcInitAssetSelect();
        const codes = b.codes || [];
        $("status").textContent = "搜索中(全部标的)...";
        setTimeout(() => {
          for (const c of codes) {
            const res = _rcSearchOne(c);
            if (res && res[0]) {
              window.__riskRuleBook[c] = { sigType: res[0].sigType, k: res[0].k, p: res[0].p, reduce: res[0].reduce };
            }
          }
          const cur = ($("rcAssetCode").value || (codes[0] || "")).trim();
          if (cur) {
            _rcRenderAssetTop(cur);
            _rcRenderAssetChart(cur);
          }
          _rcRenderRuleBook();
          $("status").textContent = "";
        }, 10);
      }

      function rcApplyComposite() {
        const b = _rcGetBaseline();
        if (!b) return setMsg("请先运行等权分析。");
        const ew = _rcSimulateEwComposite();
        if (ew) {
          Plotly.newPlot("ewRiskChart", [
            { x: ew.dates, y: ew.navBase, mode: "lines", name: "等权-原策略(sim)", line: { width: 1.2, color: "#2ca02c" } },
            { x: ew.dates, y: ew.navAdj, mode: "lines", name: "等权-复合风控", line: { width: 1.4, color: "#ff7f0e" } },
          ], { title: "等权：原策略 vs 复合风控", margin: { t: 40 }, yaxis: { type: "log", tickformat: ".0f", gridcolor: "#eee" } }, { responsive: true, displayModeBar: false });
          _renderRiskMetricsTable("ewRiskMetrics", ew.mBase, ew.mAdj);
          _renderRiskSignalTable("ewRiskSignalTable", ew.binStats);
        }
        const rot = _rcSimulateRotationComposite();
        if (rot) {
          Plotly.newPlot("rotRiskChart", [
            { x: rot.dates, y: rot.navBase, mode: "lines", name: "轮动-原策略", line: { width: 1.2, color: "#1f77b4" } },
            { x: rot.dates, y: rot.navAdj, mode: "lines", name: "轮动-复合风控", line: { width: 1.4, color: "#d62728" } },
          ], { title: "轮动：原策略 vs 复合风控（按持仓标的规则）", margin: { t: 40 }, yaxis: { type: "log", tickformat: ".0f", gridcolor: "#eee" } }, { responsive: true, displayModeBar: false });
          _renderRiskMetricsTable("rotRiskMetrics", rot.mBase, rot.mAdj);
          _renderRiskSignalTable("rotRiskSignalTable", rot.binStats);
        } else {
          $("rotRiskChart").innerHTML = "<div class='muted'>提示：先运行轮动回测，才能计算轮动的复合风控效果。</div>";
        }
      }

      function plotCorrelation(corr) {
        const el = $("corrHeatmap");
        if (!corr || !corr.codes || !corr.matrix) {
          el.innerHTML = "<div class='muted'>无相关性数据</div>";
          return;
        }
        const codes = corr.codes;
        const z = corr.matrix;
        const n = codes.length;
        const idx = Array.from({ length: n }, (_, i) => String(i + 1));
        const text = z.map(row => row.map(v => (v == null || Number.isNaN(v)) ? "" : Number(v).toFixed(2)));

        // legend: 1..N -> code + name
        const nameByCode = new Map((pool || []).map(x => [x.code, x.name]));
        const lines = codes.map((c, i) => `${i + 1}. ${c} ${nameByCode.get(c) || ""}`.trim());
        $("corrLegend").textContent = lines.join("    ");

        Plotly.newPlot(
          "corrHeatmap",
          [{
            type: "heatmap",
            x: idx,
            y: idx,
            z,
            zmin: -1,
            zmax: 1,
            colorscale: [
              [0.0, "#2ca02c"],  // green for -1
              [0.5, "#ffffff"],  // white for 0
              [1.0, "#d62728"],  // red for +1
            ],
            text,
            texttemplate: "%{text}",
            textfont: { color: "#000000" },
            hovertemplate: "编号 %{y} × %{x}<br>ρ=%{z:.3f}<extra></extra>",
            showscale: false,
          }],
          {
            margin: { t: 20, l: 60, r: 20, b: 60 },
            xaxis: { tickmode: "array", tickvals: idx, ticktext: idx, side: "top" },
            yaxis: { tickmode: "array", tickvals: idx, ticktext: idx, autorange: "reversed", scaleanchor: "x", scaleratio: 1 },
          },
          { responsive: true }
        );
      }

      function plotRotation(result) {
        const dates = result.nav.dates;
        const s = result.nav.series;
        const rsiWins = [6, 12, 24];
        const _rsiWilder = (arr, window) => {
          const w = Math.max(1, Number(window || 1));
          const out = new Array(arr.length).fill(null);
          if (arr.length < w + 1) return out;
          let avgGain = null;
          let avgLoss = null;
          for (let i = 1; i < arr.length; i++) {
            const prev = Number(arr[i - 1]);
            const cur = Number(arr[i]);
            if (!Number.isFinite(prev) || !Number.isFinite(cur) || prev <= 0 || cur <= 0) continue;
            const chg = cur - prev;
            const gain = Math.max(0, chg);
            const loss = Math.max(0, -chg);
            if (i <= w) {
              if (avgGain == null) { avgGain = 0.0; avgLoss = 0.0; }
              avgGain += gain;
              avgLoss += loss;
              if (i === w) {
                avgGain = avgGain / w;
                avgLoss = avgLoss / w;
              }
            } else {
              avgGain = ((avgGain * (w - 1)) + gain) / w;
              avgLoss = ((avgLoss * (w - 1)) + loss) / w;
            }
            if (i >= w && avgGain != null && avgLoss != null) {
              let rsi = null;
              if (avgLoss === 0 && avgGain === 0) rsi = 50.0;
              else if (avgLoss === 0) rsi = 100.0;
              else if (avgGain === 0) rsi = 0.0;
              else {
                const rs = avgGain / avgLoss;
                rsi = 100.0 - (100.0 / (1.0 + rs));
              }
              out[i] = rsi;
            }
          }
          return out;
        };
        const _drawdownFromNav = (nav) => {
          let peak = -Infinity;
          const out = [];
          for (const v of nav) {
            const x = Number(v);
            if (!Number.isFinite(x) || x <= 0) { out.push(null); continue; }
            peak = Math.max(peak, x);
            out.push(peak > 0 ? (x / peak - 1.0) : null);
          }
          return out;
        };
        const _rollingReturn = (nav, window) => {
          const w = Math.max(1, Number(window || 1));
          const out = new Array(nav.length).fill(null);
          for (let i = w; i < nav.length; i++) {
            const a = Number(nav[i - w]);
            const b = Number(nav[i]);
            if (!Number.isFinite(a) || !Number.isFinite(b) || a <= 0) continue;
            out[i] = (b / a) - 1.0;
          }
          return out;
        };
        const _rollingDrawdown = (nav, window) => {
          const w = Math.max(2, Number(window || 2));
          const out = new Array(nav.length).fill(null);
          for (let i = w - 1; i < nav.length; i++) {
            const start = i - w + 1;
            let peak = -Infinity;
            let ok = true;
            for (let j = start; j <= i; j++) {
              const x = Number(nav[j]);
              if (!Number.isFinite(x) || x <= 0) { ok = false; break; }
              peak = Math.max(peak, x);
            }
            const cur = Number(nav[i]);
            if (!ok || !Number.isFinite(cur) || peak <= 0) { out[i] = null; continue; }
            out[i] = (cur / peak) - 1.0;
          }
          return out;
        };
        const _rollingMeanStd = (arr, window) => {
          const w = Math.max(2, Number(window || 2));
          const mean = new Array(arr.length).fill(null);
          const std = new Array(arr.length).fill(null);
          let sum = 0.0;
          let sumsq = 0.0;
          let cnt = 0;
          const q = [];
          for (let i = 0; i < arr.length; i++) {
            const x = Number(arr[i]);
            q.push(x);
            if (Number.isFinite(x)) {
              sum += x;
              sumsq += x * x;
              cnt += 1;
            }
            if (q.length > w) {
              const y = Number(q.shift());
              if (Number.isFinite(y)) {
                sum -= y;
                sumsq -= y * y;
                cnt -= 1;
              }
            }
            if (q.length === w && cnt === w) {
              const m = sum / w;
              const v = Math.max(0.0, (sumsq / w) - (m * m));
              mean[i] = m;
              std[i] = Math.sqrt(v);
            }
          }
          return { mean, std };
        };
        const _rollingMean = (arr, window) => _rollingMeanStd(arr, window).mean;
        const traces = [
          { x: dates, y: s.ROTATION, mode: "lines", name: "ROTATION", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
          { x: dates, y: s.EW_REBAL, mode: "lines", name: "EW_REBAL", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
        ];
        // RSI (strategy only) below NAV (same figure, separate panel)
        for (const w of rsiWins) {
          traces.push({ x: dates, y: _rsiWilder(s.ROTATION || [], w), mode: "lines", name: `RSI${w}`, yaxis: "y2", line: { width: 1.1 }, hovertemplate: "%{x}<br>%{y:.1f}<extra></extra>" });
        }
        Plotly.newPlot(
          "rotChart",
          traces,
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: { type: "log", tick0: 0, dtick: Math.log10(2.0), tickformat: ".0f", gridcolor: "#eee", domain: [0.32, 1.0] },
            yaxis2: { title: "RSI", range: [0, 100], showgrid: false, zeroline: false, domain: [0.0, 0.25] },
            shapes: [
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 30, y1: 30, line: { color: "#999", width: 1, dash: "dot" } },
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 70, y1: 70, line: { color: "#999", width: 1, dash: "dot" } },
            ],
          },
          { responsive: true }
        );
        Plotly.newPlot(
          "rotDDCompare",
          [
            { x: dates, y: _drawdownFromNav(s.ROTATION), mode: "lines", name: "ROTATION DD", hovertemplate: "%{x}<br>%{y:.2%}<extra></extra>" },
            { x: dates, y: _drawdownFromNav(s.EW_REBAL), mode: "lines", name: "EW_REBAL DD", hovertemplate: "%{x}<br>%{y:.2%}<extra></extra>" },
          ],
          {
            margin: { t: 10, b: 30 },
            legend: { orientation: "h" },
            yaxis: { tickformat: ".0%", rangemode: "tozero", gridcolor: "#eee" },
          },
          { responsive: true }
        );
        Plotly.newPlot(
          "rotExcessChart",
          (() => {
            const ex = s.EXCESS || [];
            const ms250 = _rollingMeanStd(ex, 250);
            const ma250 = ms250.mean;
            const sd250 = ms250.std;
            const upper = ma250.map((m, i) => (m == null || sd250[i] == null ? null : (m + 2.0 * sd250[i])));
            const lower = ma250.map((m, i) => (m == null || sd250[i] == null ? null : (m - 2.0 * sd250[i])));
            const out = [
              { x: dates, y: ex, mode: "lines", name: "EXCESS", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
              // Bollinger band (lower -> upper fill)
              { x: dates, y: lower, mode: "lines", name: "BB Lower(250)", line: { color: "rgba(31,119,180,0.25)", width: 1 }, hoverinfo: "skip" },
              { x: dates, y: upper, mode: "lines", name: "BB Upper(250)", line: { color: "rgba(31,119,180,0.25)", width: 1 }, fill: "tonexty", fillcolor: "rgba(31,119,180,0.10)", hoverinfo: "skip" },
              { x: dates, y: ma250, mode: "lines", name: "MA250", line: { color: "rgba(31,119,180,0.85)", width: 1.5 }, hovertemplate: "%{x}<br>MA250=%{y:.4f}<extra></extra>" },
            ];
            // RSI on EXCESS below chart (same figure, separate panel)
            for (const w of rsiWins) {
              out.push({ x: dates, y: _rsiWilder(ex, w), mode: "lines", name: `RSI${w}`, yaxis: "y2", line: { width: 1.1 }, hovertemplate: "%{x}<br>%{y:.1f}<extra></extra>" });
            }
            return out;
          })(),
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: { type: "log", tick0: 0, dtick: Math.log10(2.0), tickformat: ".0f", gridcolor: "#eee", domain: [0.32, 1.0] },
            yaxis2: { title: "RSI", range: [0, 100], showgrid: false, zeroline: false, domain: [0.0, 0.25] },
            shapes: [
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 30, y1: 30, line: { color: "#999", width: 1, dash: "dot" } },
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 70, y1: 70, line: { color: "#999", width: 1, dash: "dot" } },
            ],
          },
          { responsive: true }
        );

        // 40-day rolling return difference: ROTATION - EW_REBAL
        const rot40 = _rollingReturn(s.ROTATION || [], 40);
        const ew40 = _rollingReturn(s.EW_REBAL || [], 40);
        const diff40 = rot40.map((x, i) => {
          const a = Number(x);
          const b = Number(ew40[i]);
          if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
          return a - b;
        });
        const diff40Ma250 = _rollingMean(diff40, 250);
        Plotly.newPlot(
          "rot40dDiffChart",
          [
            { x: dates, y: diff40, mode: "lines", name: "40D Δ", line: { color: "rgba(214,39,40,0.85)", width: 1.5 }, hovertemplate: "%{x}<br>Δ=%{y:.2%}<extra></extra>" },
            { x: dates, y: diff40Ma250, mode: "lines", name: "MA250(Δ)", line: { color: "rgba(214,39,40,0.45)", width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>MA250(Δ)=%{y:.2%}<extra></extra>" },
          ],
          {
            margin: { t: 10, b: 30 },
            legend: { orientation: "h" },
            yaxis: { tickformat: ".0%", zeroline: true, zerolinecolor: "#bbb", gridcolor: "#eee" },
          },
          { responsive: true }
        );

        // Rolling (1/3/5y) return & max drawdown for ROTATION and EXCESS.
        const w1 = 252, w3 = 252 * 3, w5 = 252 * 5;
        const _plotRollingCombo = (divId, nav, titlePrefix) => {
          const r1 = _rollingReturn(nav, w1), r3 = _rollingReturn(nav, w3), r5 = _rollingReturn(nav, w5);
          const d1 = _rollingDrawdown(nav, w1), d3 = _rollingDrawdown(nav, w3), d5 = _rollingDrawdown(nav, w5);
          const c1 = "rgba(31,119,180,0.90)";
          const c3 = "rgba(44,160,44,0.90)";
          const c5 = "rgba(255,127,14,0.90)";
          const ddMin = (() => {
            let m = 0.0;
            for (const arr of [d1, d3, d5]) {
              for (const v of arr) {
                const x = Number(v);
                if (!Number.isFinite(x)) continue;
                if (x < m) m = x;
              }
            }
            // pad slightly for readability
            return Math.min(-0.01, m - 0.02);
          })();
          Plotly.newPlot(
            divId,
            [
              // returns (top panel)
              { x: dates, y: r1, mode: "lines", name: `${titlePrefix} R(1y)`, xaxis: "x2", yaxis: "y", line: { color: c1, width: 1.4 }, hovertemplate: "%{x}<br>R1Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: r3, mode: "lines", name: `${titlePrefix} R(3y)`, xaxis: "x2", yaxis: "y", line: { color: c3, width: 1.4 }, hovertemplate: "%{x}<br>R3Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: r5, mode: "lines", name: `${titlePrefix} R(5y)`, xaxis: "x2", yaxis: "y", line: { color: c5, width: 1.4 }, hovertemplate: "%{x}<br>R5Y=%{y:.1%}<extra></extra>" },
              // drawdowns (bottom panel)
              { x: dates, y: d1, mode: "lines", name: `${titlePrefix} DD(1y)`, xaxis: "x", yaxis: "y2", line: { color: c1, width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>DD1Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: d3, mode: "lines", name: `${titlePrefix} DD(3y)`, xaxis: "x", yaxis: "y2", line: { color: c3, width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>DD3Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: d5, mode: "lines", name: `${titlePrefix} DD(5y)`, xaxis: "x", yaxis: "y2", line: { color: c5, width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>DD5Y=%{y:.1%}<extra></extra>" },
            ],
            {
              margin: { t: 10, b: 30 },
              legend: { orientation: "h" },
              // bottom x-axis
              xaxis: { domain: [0, 1], anchor: "y2" },
              // top x-axis (hidden ticks, match zoom)
              xaxis2: { domain: [0, 1], anchor: "y", matches: "x", showticklabels: false },
              // top panel: returns
              yaxis: { title: "Rolling Return", tickformat: ".0%", domain: [0.55, 1.0], zeroline: true, zerolinecolor: "#bbb", gridcolor: "#eee" },
              // bottom panel: drawdowns
              yaxis2: { title: "Rolling Drawdown", tickformat: ".0%", domain: [0.0, 0.45], range: [ddMin, 0], zeroline: true, zerolinecolor: "#bbb", gridcolor: "#eee" },
            },
            { responsive: true }
          );
        };
        _plotRollingCombo("rotRollingCombo", s.ROTATION || [], "ROT");
        _plotRollingCombo("rotExcessRollingCombo", s.EXCESS || [], "EX");
      }

      function renderRotationMetrics(m) {
        const s = m.strategy || {};
        const ex = m.excess_vs_equal_weight || {};
        const rows = [
          { key: "rot_cum", label: "策略累积收益", value: fmtPct(s.cumulative_return) },
          { key: "rot_ann", label: "策略年化收益", value: fmtPct(s.annualized_return) },
          { key: "rot_vol", label: "策略年化波动", value: fmtPct(s.annualized_volatility) },
          { key: "rot_mdd", label: "策略最大回撤", value: fmtPct(s.max_drawdown) },
          { key: "rot_sharpe", label: "策略夏普", value: fmtNum(s.sharpe_ratio) },
          { key: "rot_sortino", label: "策略索诺提", value: fmtNum(s.sortino_ratio) },
          { key: "rot_ui", label: "溃疡指标(UI)", value: fmtNum(s.ulcer_index) },
          { key: "rot_upi", label: "溃疡绩效(UPI)", value: fmtNum(s.ulcer_performance_index) },
          { key: "rot_turnover", label: "平均日换手", value: fmtPct(s.avg_daily_turnover) },
          { key: "rot_excess_cum", label: "超额累积收益", value: fmtPct(ex.cumulative_return) },
          { key: "rot_excess_ann", label: "超额年化收益(几何/CAGR)", value: fmtPct((ex.annualized_return_geo != null) ? ex.annualized_return_geo : ex.annualized_return) },
          { key: "rot_excess_ann_arith", label: "超额年化收益(算术)", value: fmtPct(ex.annualized_return_arith) },
          { key: "rot_ir", label: "超额信息比率(近似)", value: fmtNum(ex.information_ratio) },
        ];
        $("rotMetrics").innerHTML =
          `<tr><th>指标</th><th>值</th></tr>` +
          rows
            .map(
              (r) => `
                <tr>
                  <td>
                    <span>${r.label}</span>
                    <button class="helpBtn" data-metric="${r.key}" title="查看说明"
                      style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">
                      ?
                    </button>
                  </td>
                  <td>${r.value}</td>
                </tr>
              `
            )
            .join("");
      }

      function renderWinPayoff(wp) {
        const rows = [
          { key: null, label: "调仓频率", value: wp.rebalance || "-" },
          { key: null, label: "期数", value: wp.periods != null ? wp.periods : "-" },
          { key: "rot_wp_win", label: "胜率(超额>0)", value: wp.win_rate != null ? fmtPct(wp.win_rate) : "-" },
          { key: "rot_wp_avg_win", label: "平均盈利(超额,算术)", value: wp.avg_win_excess != null ? fmtPct(wp.avg_win_excess) : "-" },
          { key: "rot_wp_avg_win_geo", label: "平均盈利(超额,几何)", value: wp.avg_win_excess_geo != null ? fmtPct(wp.avg_win_excess_geo) : "-" },
          { key: "rot_wp_avg_loss", label: "平均亏损(超额,算术)", value: wp.avg_loss_excess != null ? fmtPct(wp.avg_loss_excess) : "-" },
          { key: "rot_wp_avg_loss_geo", label: "平均亏损(超额,几何)", value: wp.avg_loss_excess_geo != null ? fmtPct(wp.avg_loss_excess_geo) : "-" },
          { key: "rot_wp_payoff", label: "赔率(盈/亏,算术)", value: wp.payoff_ratio != null ? fmtNum(wp.payoff_ratio) : "-" },
          { key: "rot_wp_payoff_geo", label: "赔率(盈/亏,几何)", value: wp.payoff_ratio_geo != null ? fmtNum(wp.payoff_ratio_geo) : "-" },
          { key: "rot_wp_kelly", label: "凯利比(近似)", value: wp.kelly_fraction != null ? fmtPct(wp.kelly_fraction) : "-" },
          { key: "rot_abs_win", label: "绝对胜率(期收益>0)", value: wp.abs_win_rate != null ? fmtPct(wp.abs_win_rate) : "-" },
          { key: "rot_abs_avg_win", label: "绝对平均盈利(算术)", value: wp.abs_avg_win != null ? fmtPct(wp.abs_avg_win) : "-" },
          { key: "rot_abs_avg_win_geo", label: "绝对平均盈利(几何)", value: wp.abs_avg_win_geo != null ? fmtPct(wp.abs_avg_win_geo) : "-" },
          { key: "rot_abs_avg_loss", label: "绝对平均亏损(算术)", value: wp.abs_avg_loss != null ? fmtPct(wp.abs_avg_loss) : "-" },
          { key: "rot_abs_avg_loss_geo", label: "绝对平均亏损(几何)", value: wp.abs_avg_loss_geo != null ? fmtPct(wp.abs_avg_loss_geo) : "-" },
          { key: "rot_abs_payoff", label: "绝对赔率(盈/亏,算术)", value: wp.abs_payoff_ratio != null ? fmtNum(wp.abs_payoff_ratio) : "-" },
          { key: "rot_abs_payoff_geo", label: "绝对赔率(盈/亏,几何)", value: wp.abs_payoff_ratio_geo != null ? fmtNum(wp.abs_payoff_ratio_geo) : "-" },
          { key: "rot_abs_kelly", label: "绝对凯利比(近似)", value: wp.abs_kelly_fraction != null ? fmtPct(wp.abs_kelly_fraction) : "-" },
        ];
        $("rotWinPayoff").innerHTML =
          `<tr><th>指标</th><th>值</th></tr>` +
          rows
            .map(
              (r) => `
                <tr>
                  <td>
                    <span>${r.label}</span>
                    ${
                      r.key
                        ? `<button class="helpBtn" data-metric="${r.key}" title="查看说明"
                          style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button>`
                        : ""
                    }
                  </td>
                  <td>${r.value}</td>
                </tr>
              `
            )
            .join("");
      }

      const rotState = { page: 1, rows: [] };
      function _sortedRotRows(rows, key, dir) {
        const arr = (rows || []).slice();
        const k = key === "excess" ? "excess_return" : (key === "end" ? "end_date" : "start_date");
        arr.sort((a, b) => {
          const av = k === "excess_return" ? Number(a[k]) : String(a[k]);
          const bv = k === "excess_return" ? Number(b[k]) : String(b[k]);
          if (av < bv) return -1;
          if (av > bv) return 1;
          return 0;
        });
        if (dir === "desc") arr.reverse();
        return arr;
      }
      function renderRotPeriods() {
        const key = $("rotPeriodSortKey").value;
        const dir = $("rotPeriodSortDir").value;
        const rows = _sortedRotRows(rotState.rows, key, dir);
        const total = rows.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        rotState.page = Math.min(Math.max(1, rotState.page), totalPages);
        const startIdx = (rotState.page - 1) * pageSize;
        const pageRows = rows.slice(startIdx, startIdx + pageSize);
        const fmtLegBuy = (xs) => (xs || []).map(x => `${x.code}:${fmtPct(x.delta_weight)}`).join(" ");
        const fmtLegSell = (xs) => (xs || []).map(x => `${x.code}:${fmtPct(Math.abs(x.delta_weight))}`).join(" ");
        $("rotPeriods").innerHTML =
          `<tr><th>开始</th><th>结束</th><th>轮动收益</th><th>等权收益</th><th>超额</th><th>胜</th><th>调入(Δw)</th><th>调出(Δw)</th></tr>` +
          pageRows.map(r => `<tr><td>${r.start_date}</td><td>${r.end_date}</td><td>${fmtPct(r.strategy_return)}</td><td>${fmtPct(r.equal_weight_return)}</td><td>${fmtPct(r.excess_return)}</td><td>${r.win ? "是" : "否"}</td><td>${fmtLegBuy(r.buys)}</td><td>${fmtLegSell(r.sells)}</td></tr>`).join("");
        $("rotPeriodPage").textContent = `${rotState.page}/${totalPages} · 共${total}条 · 每页${pageSize}条`;
      }

      const rotPeriodTableState = {
        weekly: { page: 1, rows: [] },
        monthly: { page: 1, rows: [] },
        quarterly: { page: 1, rows: [] },
        yearly: { page: 1, rows: [] },
      };
      function _sortedRotPeriodRows(rows, sortKey, sortDir) {
        const arr = (rows || []).slice();
        let k = "period_end";
        if (sortKey === "strategy") k = "strategy_return";
        if (sortKey === "excess") k = "excess_return";
        arr.sort((a, b) => {
          const av = k === "period_end" ? String(a[k]) : Number(a[k]);
          const bv = k === "period_end" ? String(b[k]) : Number(b[k]);
          if (av < bv) return -1;
          if (av > bv) return 1;
          return 0;
        });
        if (sortDir === "desc") arr.reverse();
        return arr;
      }
      function renderRotPeriodTable(kind) {
        const st = rotPeriodTableState[kind];
        const sortKey = $(`rot${kind[0].toUpperCase() + kind.slice(1)}SortKey`).value;
        const sortDir = $(`rot${kind[0].toUpperCase() + kind.slice(1)}SortDir`).value;
        const rows = _sortedRotPeriodRows(st.rows, sortKey, sortDir);
        const total = rows.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        st.page = Math.min(Math.max(1, st.page), totalPages);
        const startIdx = (st.page - 1) * pageSize;
        const pageRows = rows.slice(startIdx, startIdx + pageSize);
        $( `rot${kind[0].toUpperCase() + kind.slice(1)}` ).innerHTML =
          `<tr><th>期末</th><th>策略</th><th>基准</th><th>超额</th></tr>` +
          pageRows.map(r => `<tr><td>${r.period_end}</td><td>${fmtPct(r.strategy_return)}</td><td>${fmtPct(r.benchmark_return)}</td><td>${fmtPct(r.excess_return)}</td></tr>`).join("");
        $(`rot${kind[0].toUpperCase() + kind.slice(1)}Page`).textContent = `${st.page}/${totalPages} · 共${total}条 · 每页${pageSize}条`;
      }
      function wireRotPeriodControls(kind) {
        const cap = kind[0].toUpperCase() + kind.slice(1);
        $(`rot${cap}SortKey`).addEventListener("change", () => { rotPeriodTableState[kind].page = 1; renderRotPeriodTable(kind); });
        $(`rot${cap}SortDir`).addEventListener("change", () => { rotPeriodTableState[kind].page = 1; renderRotPeriodTable(kind); });
        $(`rot${cap}Prev`).addEventListener("click", () => { rotPeriodTableState[kind].page -= 1; renderRotPeriodTable(kind); });
        $(`rot${cap}Next`).addEventListener("click", () => { rotPeriodTableState[kind].page += 1; renderRotPeriodTable(kind); });
      }

      function _checkedValues(sel) {
        return Array.from(document.querySelectorAll(sel)).filter(x => x && x.checked).map(x => x.value);
      }

      function renderCalendarAnchorBox(prefix, rebalance) {
        const box = $(`${prefix}CalAnchorBox`);
        const label = $(`${prefix}CalAnchorLabel`);
        if (!box || !label) return;
        const r = String(rebalance || "weekly").toLowerCase();
        box.innerHTML = "";
        const mkCb = (cls, val, text, checked=true) =>
          `<label style="display:flex; gap:6px; align-items:center; margin:0;">
            <input type="checkbox" class="${cls}" value="${val}" ${checked ? "checked" : ""} />${text}
          </label>`;
        const mkCsv = (id, val, placeholder) =>
          `<input id="${id}" value="${esc(val)}" placeholder="${esc(placeholder)}" style="min-width:280px;" />
           <div class="muted" style="margin-top:4px;">输入逗号分隔整数，例如 1,5,10（表示当期第1/5/10个交易日）。</div>`;

        if (r === "weekly") {
          label.textContent = "调仓日（周度）";
          const cls = `${prefix}CalAnchor`;
          box.innerHTML = `<div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
            ${mkCb(cls, 0, "周一")}
            ${mkCb(cls, 1, "周二")}
            ${mkCb(cls, 2, "周三")}
            ${mkCb(cls, 3, "周四")}
            ${mkCb(cls, 4, "周五")}
          </div>`;
          return;
        }
        if (r === "monthly") {
          label.textContent = "调仓日（月度，日历日 1~28）";
          const cls = `${prefix}CalAnchor`;
          const items = Array.from({length: 28}, (_, i) => i + 1)
            .map((d) => mkCb(cls, d, `${d}号`, d === 1))
            .join("");
          box.innerHTML = `<div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; max-height:140px; overflow:auto; border:1px solid #ddd; padding:8px; border-radius:8px;">${items}</div>`;
          return;
        }
        if (r === "quarterly") {
          label.textContent = "调仓日（季度，第N个交易日）";
          box.innerHTML = mkCsv(`${prefix}CalAnchorCsv`, "1,5,10,20,40,60", "例如 1,5,10,20,40,60");
          return;
        }
        if (r === "yearly") {
          label.textContent = "调仓日（年度，第N个交易日）";
          box.innerHTML = mkCsv(`${prefix}CalAnchorCsv`, "1,5,10,20,60,120,180,240", "例如 1,5,10,20,60,120,180,240");
          return;
        }
        label.textContent = "调仓锚点";
        box.innerHTML = `<div class="muted">当前调仓周期不支持日历锚点研究（仅支持 weekly/monthly/quarterly/yearly）。</div>`;
      }

      function parseCalendarAnchors(prefix, rebalance) {
        const r = String(rebalance || "weekly").toLowerCase();
        const cls = `${prefix}CalAnchor`;
        if (r === "weekly" || r === "monthly") {
          const xs = _checkedValues(`input.${cls}`).map((x) => Number(x)).filter((x) => Number.isFinite(x));
          if (xs.length === 0) return { ok: false, reason: "请至少选择一个调仓锚点" };
          return { ok: true, anchors: xs };
        }
        if (r === "quarterly" || r === "yearly") {
          const el = $(`${prefix}CalAnchorCsv`);
          const raw = (el && el.value ? el.value : "").trim();
          const xs = raw.split(",").map(x => x.trim()).filter(Boolean).map(Number).map(x => Math.floor(x)).filter(x => Number.isFinite(x));
          const ys = xs.filter(x => x >= 1);
          if (ys.length === 0) return { ok: false, reason: "请输入至少一个 >=1 的整数锚点（逗号分隔）" };
          const maxN = (r === "quarterly") ? 90 : 300;
          const bad = ys.find(x => x > maxN);
          if (bad != null) return { ok: false, reason: `锚点 N 过大：${bad}（${r === "quarterly" ? "季度" : "年度"}建议 <= ${maxN}）` };
          return { ok: true, anchors: ys };
        }
        return { ok: false, reason: "当前调仓周期不支持日历锚点研究（仅支持 weekly/monthly/quarterly/yearly）" };
      }

      function _renderCalendarTable(tableId, data) {
        const el = $(tableId);
        if (!el) return;
        const grid = (data && data.grid) ? data.grid : [];
        const reb = (data && data.meta && data.meta.rebalance) ? String(data.meta.rebalance) : "weekly";
        const pxMap = (data && data.exec_price_map) ? data.exec_price_map : {};
        const rolling = (data && data.rolling) ? data.rolling : null;
        const rollingStats = (data && data.rolling_stats) ? data.rolling_stats : null;
        const rollYears = (data && data.meta && Array.isArray(data.meta.rolling_years)) ? data.meta.rolling_years : [1, 3, 5];
        const anchorLabel = (a) => {
          const n = Number(a);
          if (reb === "weekly") {
            const m = {0:"周一",1:"周二",2:"周三",3:"周四",4:"周五"};
            return m[n] || String(a);
          }
          if (reb === "monthly") return `${n}号`;
          if (reb === "quarterly") return `季度第${n}个交易日`;
          if (reb === "yearly") return `年度第${n}个交易日`;
          return String(a);
        };
        const keyLabel = (key) => {
          const parts = String(key).split("|");
          const a = parts[0];
          const px = parts[1] || "";
          return `${anchorLabel(a)} · ${(pxMap[px] || px)}`;
        };
        const rows = grid.slice().sort((a, b) => {
          if (a.anchor !== b.anchor) return Number(a.anchor) - Number(b.anchor);
          return String(a.exec_price).localeCompare(String(b.exec_price));
        });
        el.innerHTML =
          `<tr><th>调仓锚点</th><th>成交价</th><th>年化收益</th><th>夏普</th><th>卡玛</th><th>索诺提</th><th>溃疡(UI)</th><th>UPI</th><th>信息比率</th><th>最大回撤</th><th>平均日换手</th><th>状态</th></tr>` +
          rows.map((r) => {
            const ok = !!r.ok;
            const m = ok ? (r.metrics || {}) : {};
            const ann = ok ? fmtPct(m.annualized_return) : "-";
            const sr = ok ? fmtNum(m.sharpe_ratio) : "-";
            const calmar = ok ? fmtNum(m.calmar_ratio) : "-";
            const sortino = ok ? fmtNum(m.sortino_ratio) : "-";
            const ui = ok ? fmtNum(m.ulcer_index) : "-";
            const upi = ok ? fmtNum(m.ulcer_performance_index) : "-";
            const ir = ok ? fmtNum(m.information_ratio) : "-";
            const mdd = ok ? fmtPct(m.max_drawdown) : "-";
            const to = ok ? fmtPct(m.avg_daily_turnover) : "-";
            const status = ok ? "OK" : (esc(r.reason || "ERR"));
            return `<tr><td>${anchorLabel(r.anchor)}</td><td>${pxMap[r.exec_price] || r.exec_price}</td><td>${ann}</td><td>${sr}</td><td>${calmar}</td><td>${sortino}</td><td>${ui}</td><td>${upi}</td><td>${ir}</td><td>${mdd}</td><td>${to}</td><td>${status}</td></tr>`;
          }).join("");

        // Heatmap (annualized_return)
        const divId = (tableId === "ewCalTable") ? "ewCalHeatmap" : "rotCalHeatmap";
        const okRows = rows.filter(x => x.ok && x.metrics && Number.isFinite(Number(x.metrics.annualized_return)));
        if (!$(divId)) return;
        if (okRows.length === 0) { Plotly.purge(divId); return; }
        const uniqWk = Array.from(new Set(rows.map(x => Number(x.anchor)))).sort((a, b) => a - b);
        const uniqPx = Array.from(new Set(rows.map(x => String(x.exec_price)))).sort();
        const z = uniqWk.map(wd => uniqPx.map(px => {
          const one = rows.find(x => Number(x.anchor) === wd && String(x.exec_price) === px && x.ok);
          if (!one) return null;
          const v = one.metrics ? Number(one.metrics.annualized_return) : NaN;
          return Number.isFinite(v) ? v * 100.0 : null; // percent
        }));
        const y = uniqWk.map(wd => anchorLabel(wd));
        const x = uniqPx.map(px => pxMap[px] || px);
        Plotly.newPlot(divId, [{
          type: "heatmap",
          x,
          y,
          z,
          colorscale: "RdYlGn",
          colorbar: { title: "年化收益(%)" },
          hovertemplate: "%{y} · %{x}<br>%{z:.2f}%<extra></extra>",
        }], {
          title: (tableId === "ewCalTable") ? "等权：年化收益热力图（%）" : "轮动：年化收益热力图（%）",
          margin: { l: 60, r: 20, t: 50, b: 60 },
        }, { displayModeBar: false });

        // Rolling N-year return curves (1/3/5y) + summary stats table (stability).
        const chartId = (tableId === "ewCalTable") ? "ewCalRollingChart" : "rotCalRollingChart";
        const statId = (tableId === "ewCalTable") ? "ewCalRollingStats" : "rotCalRollingStats";
        const chartEl = $(chartId);
        const statEl = $(statId);
        if (chartEl && rolling && rolling.dates && rolling.series) {
          const rdates = rolling.dates;
          const series = rolling.series;
          const keys = Object.keys(series);
          const years = rollYears.map(x => Number(x)).filter(x => Number.isFinite(x));
          const yearKeys = years.map(y => `${y}y`);
          const buildTraces = (yk) => keys.map((k) => ({
            x: rdates,
            y: (series[k] && series[k][yk]) ? series[k][yk] : [],
            mode: "lines",
            name: keyLabel(k),
            line: { width: 1.2 },
            hovertemplate: "%{x}<br>%{y:.1%}<extra></extra>",
          }));
          const tracesAll = [];
          const vis = [];
          for (const yk of yearKeys) {
            const ts = buildTraces(yk);
            for (const t of ts) { tracesAll.push(t); vis.push(false); }
          }
          // default: 1y visible
          const nKeys = keys.length;
          for (let i = 0; i < nKeys; i++) vis[i] = true;
          tracesAll.forEach((t, i) => { t.visible = vis[i]; });
          const buttons = yearKeys.map((yk, idx) => {
            const v = new Array(tracesAll.length).fill(false);
            const base = idx * nKeys;
            for (let i = 0; i < nKeys; i++) v[base + i] = true;
            return { label: yk.toUpperCase(), method: "update", args: [{ visible: v }, { title: `${tableId === "ewCalTable" ? "等权" : "轮动"}：滚动收益率（${yk.toUpperCase()}）` }] };
          });
          Plotly.newPlot(chartId, tracesAll, {
            title: `${tableId === "ewCalTable" ? "等权" : "轮动"}：滚动收益率（1Y/3Y/5Y）`,
            margin: { t: 50, b: 40, l: 60, r: 20 },
            legend: { orientation: "h" },
            yaxis: { tickformat: ".0%", gridcolor: "#eee", zeroline: true, zerolinecolor: "#bbb" },
            updatemenus: [{ type: "buttons", direction: "right", x: 0.0, y: 1.18, showactive: true, buttons }],
          }, { responsive: true, displayModeBar: false });
        }
        if (statEl && rollingStats) {
          const keys = Object.keys(rollingStats);
          const years = rollYears.map(x => Number(x)).filter(x => Number.isFinite(x));
          const yearKeys = years.map(y => `${y}y`);
          const rows2 = [];
          for (const k of keys.sort()) {
            for (const yk of yearKeys) {
              const st = (rollingStats[k] && rollingStats[k][yk]) ? rollingStats[k][yk] : {};
              rows2.push({
                key: k,
                yk,
                count: st.count,
                mean: st.mean,
                std: st.std,
                p10: st.p10,
                p50: st.p50,
                p90: st.p90,
                pos: st.pos_ratio,
                min: st.min,
                max: st.max,
              });
            }
          }
          statEl.innerHTML =
            `<tr><th>方案</th><th>窗口</th><th>样本数</th><th>均值</th><th>Std</th><th>P10</th><th>P50</th><th>P90</th><th>正收益占比</th><th>最小</th><th>最大</th></tr>` +
            rows2.map(r => {
              const f = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtPct(Number(x));
              const n = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : String(x);
              const label = keyLabel(r.key);
              return `<tr><td>${label}</td><td>${r.yk.toUpperCase()}</td><td>${n(r.count)}</td><td>${f(r.mean)}</td><td>${f(r.std)}</td><td>${f(r.p10)}</td><td>${f(r.p50)}</td><td>${f(r.p90)}</td><td>${f(r.pos)}</td><td>${f(r.min)}</td><td>${f(r.max)}</td></tr>`;
            }).join("");
        }
      }

      async function runRotation() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const rebalance = $("rotRebalance").value;
        const top_k = Number(($("rotTopK").value || "1").trim());
        const lookback_days = Number(($("rotLookback").value || "252").trim());
        const skip_days = Number(($("rotSkip").value || "0").trim());
        const cost_bps = Number(($("rotCost").value || "0").trim());
        const risk_off = ($("rotRiskOff").value === "true");
        const momentum_floor = Number(($("rotFloor").value || "0").trim());
        const score_method = $("rotScoreMethod").value;
        const tp_sl_mode = ($("rotTpSlMode").value || "none");
        const atrWindowRaw = ($("rotAtrWindow").value || "").trim();
        const atr_window = atrWindowRaw === "" ? null : Number(atrWindowRaw);
        if (atr_window != null && (!Number.isFinite(atr_window) || atr_window < 2)) return setMsg("ATR窗口必须>=2（或留空表示同步动量回看）");
        const atr_mult = Number(($("rotAtrMult").value || "2.0").trim());
        if (!Number.isFinite(atr_mult) || atr_mult <= 0) return setMsg("ATR倍数必须>0，例如 2");
        const atr_step = Number(($("rotAtrStep").value || "0.5").trim());
        if (!Number.isFinite(atr_step) || atr_step <= 0) return setMsg("渐进步长必须>0，例如 0.5");
        const atr_min_mult = Number(($("rotAtrMinMult").value || "0.5").trim());
        if (!Number.isFinite(atr_min_mult) || atr_min_mult <= 0) return setMsg("最小倍数必须>0，例如 0.5");
        const trend_filter = ($("rotTrendOn").value === "true");
        const trend_mode = $("rotTrendMode").value;
        const trend_sma_window = Number(($("rotTrendSma").value || "200").trim());
        const rsi_filter = ($("rotRsiOn").value === "true");
        const rsi_window = Number(($("rotRsiWin").value || "14").trim());
        const rsi_overbought = Number(($("rotRsiOver").value || "70").trim());
        const rsi_oversold = Number(($("rotRsiUnder").value || "30").trim());
        const vol_monitor = ($("rotVolOn").value === "true");
        const vol_window = Number(($("rotVolWin").value || "20").trim());
        const vol_target_ann = Number(($("rotVolTarget").value || "0.20").trim());
        const vol_max_ann = Number(($("rotVolMax").value || "0.60").trim());
        const chop_filter = ($("rotChopOn").value === "true");
        const chop_mode = ($("rotChopMode").value || "er");
        const chop_window = Number(($("rotChopWin").value || "20").trim());
        const chop_er_threshold = Number(($("rotChopThr").value || "0.25").trim());
        const chop_adx_window = Number(($("rotChopAdxWin").value || "20").trim());
        const chop_adx_threshold = Number(($("rotChopAdxThr").value || "20").trim());
        const corr_filter = ($("rotCorrOn").value === "true");
        const corrWinRaw = ($("rotCorrWindow").value || "").trim();
        const corr_window = corrWinRaw === "" ? null : Number(corrWinRaw);
        if (corr_filter && corr_window != null && (!Number.isFinite(corr_window) || corr_window < 2)) return setMsg("相关性回看窗口必须>=2（或留空表示同步动量回看）");
        const corr_threshold = Number(($("rotCorrThr").value || "0.5").trim());
        if (corr_filter && (!Number.isFinite(corr_threshold) || corr_threshold < -1 || corr_threshold > 1)) return setMsg("相关性阈值需在 [-1,1]，例如 0.5");
        const inertia = ($("rotInertiaOn").value === "true");
        const inertia_min_hold_periods = Number(($("rotInertiaMinHold").value || "0").trim());
        if (inertia && (!Number.isFinite(inertia_min_hold_periods) || inertia_min_hold_periods < 0)) return setMsg("最短持有期必须是 >=0 的整数，例如 2");
        const inertia_score_gap = Number(($("rotInertiaScoreGap").value || "0").trim());
        if (inertia && (!Number.isFinite(inertia_score_gap) || inertia_score_gap < 0)) return setMsg("单标的切换阈值必须是 >=0 的数字，例如 0.01");
        const inertia_min_turnover = Number(($("rotInertiaMinTurnover").value || "0").trim());
        if (inertia && (!Number.isFinite(inertia_min_turnover) || inertia_min_turnover < 0 || inertia_min_turnover > 1)) return setMsg("最小换手阈值需在 [0,1]，例如 0.2");
        const rr_sizing = ($("rotRROn").value === "true");
        const rrYearsRaw = ($("rotRRYears").value || "3").trim();
        const rr_years = Number(rrYearsRaw);
        if (rr_sizing && (!Number.isFinite(rr_years) || rr_years <= 0)) return setMsg("滚动收益率窗口年数 N 必须>0，例如 3");
        const thrRaw = ($("rotRRThr").value || "").trim();
        const wtsRaw = ($("rotRRWts").value || "").trim();
        const parseCsvNums = (s) => s.split(",").map(x => x.trim()).filter(Boolean).map(Number);
        let rr_thresholds = null;
        let rr_weights = null;
        if (rr_sizing) {
          rr_thresholds = parseCsvNums(thrRaw);
          rr_weights = parseCsvNums(wtsRaw);
          if (rr_thresholds.length === 0 || rr_thresholds.length > 5) return setMsg("收益率阈值必须为 1~5 个逗号分隔数字，例如 50,100,150,200,250");
          if (rr_weights.length !== rr_thresholds.length + 1) return setMsg("仓位档位数量必须 = 阈值数量 + 1，例如 6 档对应 5 个阈值");
          // normalize percent-like inputs
          rr_thresholds = rr_thresholds.map(x => (x > 1.0 ? x / 100.0 : x));
          rr_weights = rr_weights.map(x => (x > 1.0 ? x / 100.0 : x));
          for (const x of rr_thresholds) if (!Number.isFinite(x)) return setMsg("收益率阈值必须是数字");
          for (const x of rr_weights) if (!Number.isFinite(x)) return setMsg("仓位必须是数字");
          for (let i = 0; i + 1 < rr_thresholds.length; i++) if (!(rr_thresholds[i] < rr_thresholds[i + 1])) return setMsg("收益率阈值必须严格递增");
          for (const x of rr_weights) if (x < 0 || x > 1) return setMsg("仓位必须在 0~100%（或 0~1）");
        }
        const dd_control = ($("rotDDOn").value === "true");
        let dd_threshold = Number(($("rotDDThr").value || "10").trim());
        if (dd_control && (!Number.isFinite(dd_threshold) || dd_threshold <= 0)) return setMsg("回撤阈值 X 必须>0，例如 10 或 0.10");
        if (dd_threshold > 1.0) dd_threshold = dd_threshold / 100.0;
        if (dd_control && (dd_threshold <= 0 || dd_threshold >= 1.0)) return setMsg("回撤阈值 X 需在 (0,100%)，例如 10");
        let dd_reduce = Number(($("rotDDReduce").value || "100").trim());
        if (dd_control && (!Number.isFinite(dd_reduce) || dd_reduce < 0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        if (dd_reduce > 1.0) dd_reduce = dd_reduce / 100.0;
        if (dd_control && (dd_reduce < 0 || dd_reduce > 1.0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        const dd_sleep_days = Number(($("rotDDSleep").value || "20").trim());
        if (dd_control && (!Number.isFinite(dd_sleep_days) || dd_sleep_days < 1)) return setMsg("休眠天数必须>=1，例如 20");
        const timing_rsi_gate = ($("rotTimingOn").value === "true");
        const timing_rsi_window = Number(($("rotTimingRsiWin").value || "24").trim());
        if (timing_rsi_gate && (!Number.isFinite(timing_rsi_window) || timing_rsi_window < 2)) return setMsg("择时 RSI 窗口必须>=2");
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        if (trend_filter && (!Number.isFinite(trend_sma_window) || trend_sma_window <= 0)) return setMsg("趋势 SMA 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_window) || rsi_window <= 0)) return setMsg("RSI 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_overbought) || rsi_overbought < 0 || rsi_overbought > 100)) return setMsg("RSI 超买阈值需在 0~100");
        if (rsi_filter && (!Number.isFinite(rsi_oversold) || rsi_oversold < 0 || rsi_oversold > 100)) return setMsg("RSI 超卖阈值需在 0~100");
        if (vol_monitor && (!Number.isFinite(vol_window) || vol_window <= 0)) return setMsg("Vol 窗口必须是正整数");
        if (vol_monitor && (!Number.isFinite(vol_target_ann) || vol_target_ann <= 0)) return setMsg("目标年化Vol必须>0，例如 0.20");
        if (vol_monitor && (!Number.isFinite(vol_max_ann) || vol_max_ann <= 0)) return setMsg("最大年化Vol必须>0，例如 0.60");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_window) || chop_window <= 1)) return setMsg("ER窗口必须>=2");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_er_threshold) || chop_er_threshold <= 0)) return setMsg("ER阈值必须>0，例如 0.25");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_window) || chop_adx_window <= 1)) return setMsg("ADX窗口必须>=2");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_threshold) || chop_adx_threshold <= 0)) return setMsg("ADX阈值必须>0，例如 20");
        $("status").textContent = "回测中...";
        setMsg("");
        const asset_rc_rules = (() => {
          const rb = window.__riskRuleBook || {};
          const out = [];
          for (const [code, r] of Object.entries(rb)) {
            if (!r) continue;
            out.push({
              code,
              sig_type: r.sigType,
              k: Number(r.k),
              p_in: Number(r.p),
              reduce_pct: Number(r.reduce),
              recovery_mode: r.recoveryMode || "immediate",
              p_out: (r.pOut == null ? null : Number(r.pOut)),
              cooldown_days: Number(r.cooldownDays || 0),
            });
          }
          return out.length ? out : null;
        })();
        const resp = await api("/analysis/rotation", {
          method: "POST",
          body: JSON.stringify({
            codes, start, end, rebalance, top_k, lookback_days, skip_days, cost_bps,
            risk_off, momentum_floor, risk_free_rate,
            score_method,
            tp_sl_mode,
            atr_window, atr_mult, atr_step, atr_min_mult,
            corr_filter, corr_window, corr_threshold,
            inertia, inertia_min_hold_periods, inertia_score_gap, inertia_min_turnover,
            rr_sizing, rr_years, rr_thresholds, rr_weights,
            dd_control, dd_threshold, dd_reduce, dd_sleep_days,
            timing_rsi_gate, timing_rsi_window,
            trend_filter, trend_mode, trend_sma_window,
            rsi_filter, rsi_window, rsi_overbought, rsi_oversold,
            vol_monitor, vol_window, vol_target_ann, vol_max_ann,
            chop_filter, chop_mode, chop_window, chop_er_threshold, chop_adx_window, chop_adx_threshold,
            asset_rc_rules,
          }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        window.__lastRotationResult = data;
        plotRotation(data);
        renderRotationMetrics(data.metrics || {});
        // Use continuous holding streaks (not per-rebalance periods) for holding-length distributions.
        renderRotationHoldingPeriodLengthDistributions(data.holding_streaks || data.holdings || [], (data.nav && data.nav.dates) ? data.nav.dates : []);
        // optional: if rules already exist, allow one-click composite
        try { _rcInitAssetSelect(); _rcRenderRuleBook(); } catch (e) { /* ignore */ }
        renderWinPayoff(data.win_payoff || {});
        renderContributionTables("rot", data.attribution);
        rotState.rows = data.period_details || [];
        rotState.page = 1;
        renderRotPeriods();
        // periodic returns tables
        rotPeriodTableState.weekly.rows = (data.period_returns && data.period_returns.weekly) ? data.period_returns.weekly : [];
        rotPeriodTableState.monthly.rows = (data.period_returns && data.period_returns.monthly) ? data.period_returns.monthly : [];
        rotPeriodTableState.quarterly.rows = (data.period_returns && data.period_returns.quarterly) ? data.period_returns.quarterly : [];
        rotPeriodTableState.yearly.rows = (data.period_returns && data.period_returns.yearly) ? data.period_returns.yearly : [];
        rotPeriodTableState.weekly.page = 1;
        rotPeriodTableState.monthly.page = 1;
        rotPeriodTableState.quarterly.page = 1;
        rotPeriodTableState.yearly.page = 1;
        renderRotPeriodTable("weekly");
        renderRotPeriodTable("monthly");
        renderRotPeriodTable("quarterly");
        renderRotPeriodTable("yearly");
      }

      async function runEwCalendarEffect() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = (($("ewCalStart").value || "").trim()) || $("start").value.trim();
        const end = (($("ewCalEnd").value || "").trim()) || $("end").value.trim();
        const adjust = $("ewCalAdjust").value || ADJUST_USED;
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        const rebalance = $("rebalance").value || "weekly";
        const rebalance_shift = ($("ewCalShift") && $("ewCalShift").value) ? $("ewCalShift").value : "prev";
        const parsed = parseCalendarAnchors("ew", rebalance);
        if (!parsed.ok) return setMsg(parsed.reason);
        const anchors = parsed.anchors;
        const exec_prices = _checkedValues("input.ewCalPx");
        if (anchors.length === 0) return setMsg("请至少选择一个调仓锚点");
        if (exec_prices.length === 0) return setMsg("请至少选择一个成交价口径（开盘/收盘/OC均价）");
        $("status").textContent = "计算日历效应（等权）...";
        setMsg("");
        const resp = await api("/analysis/baseline/calendar-effect", {
          method: "POST",
          body: JSON.stringify({ codes, start, end, adjust, risk_free_rate, rebalance, rebalance_shift, anchors, exec_prices }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        _renderCalendarTable("ewCalTable", data);
      }

      async function runRotCalendarEffect() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = (($("rotCalStart").value || "").trim()) || $("start").value.trim();
        const end = (($("rotCalEnd").value || "").trim()) || $("end").value.trim();
        const rebalance = $("rotRebalance").value;
        const rebalance_shift = ($("rotCalShift") && $("rotCalShift").value) ? $("rotCalShift").value : "prev";
        const top_k = Number(($("rotTopK").value || "1").trim());
        const lookback_days = Number(($("rotLookback").value || "252").trim());
        const skip_days = Number(($("rotSkip").value || "0").trim());
        const cost_bps = Number(($("rotCost").value || "0").trim());
        const risk_off = ($("rotRiskOff").value === "true");
        const momentum_floor = Number(($("rotFloor").value || "0").trim());
        const score_method = $("rotScoreMethod").value;
        const tp_sl_mode = ($("rotTpSlMode").value || "none");
        const atrWindowRaw = ($("rotAtrWindow").value || "").trim();
        const atr_window = atrWindowRaw === "" ? null : Number(atrWindowRaw);
        if (atr_window != null && (!Number.isFinite(atr_window) || atr_window < 2)) return setMsg("ATR窗口必须>=2（或留空表示同步动量回看）");
        const atr_mult = Number(($("rotAtrMult").value || "2.0").trim());
        if (!Number.isFinite(atr_mult) || atr_mult <= 0) return setMsg("ATR倍数必须>0，例如 2");
        const atr_step = Number(($("rotAtrStep").value || "0.5").trim());
        if (!Number.isFinite(atr_step) || atr_step <= 0) return setMsg("渐进步长必须>0，例如 0.5");
        const atr_min_mult = Number(($("rotAtrMinMult").value || "0.5").trim());
        if (!Number.isFinite(atr_min_mult) || atr_min_mult <= 0) return setMsg("最小倍数必须>0，例如 0.5");
        const trend_filter = ($("rotTrendOn").value === "true");
        const trend_mode = $("rotTrendMode").value;
        const trend_sma_window = Number(($("rotTrendSma").value || "200").trim());
        const rsi_filter = ($("rotRsiOn").value === "true");
        const rsi_window = Number(($("rotRsiWin").value || "14").trim());
        const rsi_overbought = Number(($("rotRsiOver").value || "70").trim());
        const rsi_oversold = Number(($("rotRsiUnder").value || "30").trim());
        const vol_monitor = ($("rotVolOn").value === "true");
        const vol_window = Number(($("rotVolWin").value || "20").trim());
        const vol_target_ann = Number(($("rotVolTarget").value || "0.20").trim());
        const vol_max_ann = Number(($("rotVolMax").value || "0.60").trim());
        const chop_filter = ($("rotChopOn").value === "true");
        const chop_mode = ($("rotChopMode").value || "er");
        const chop_window = Number(($("rotChopWin").value || "20").trim());
        const chop_er_threshold = Number(($("rotChopThr").value || "0.25").trim());
        const chop_adx_window = Number(($("rotChopAdxWin").value || "20").trim());
        const chop_adx_threshold = Number(($("rotChopAdxThr").value || "20").trim());
        const corr_filter = ($("rotCorrOn").value === "true");
        const corrWinRaw = ($("rotCorrWindow").value || "").trim();
        const corr_window = corrWinRaw === "" ? null : Number(corrWinRaw);
        if (corr_filter && corr_window != null && (!Number.isFinite(corr_window) || corr_window < 2)) return setMsg("相关性回看窗口必须>=2（或留空表示同步动量回看）");
        const corr_threshold = Number(($("rotCorrThr").value || "0.5").trim());
        if (corr_filter && (!Number.isFinite(corr_threshold) || corr_threshold < -1 || corr_threshold > 1)) return setMsg("相关性阈值需在 [-1,1]，例如 0.5");
        const rr_sizing = ($("rotRROn").value === "true");
        const rrYearsRaw = ($("rotRRYears").value || "3").trim();
        const rr_years = Number(rrYearsRaw);
        if (rr_sizing && (!Number.isFinite(rr_years) || rr_years <= 0)) return setMsg("滚动收益率窗口年数 N 必须>0，例如 3");
        const thrRaw = ($("rotRRThr").value || "").trim();
        const wtsRaw = ($("rotRRWts").value || "").trim();
        const parseCsvNums = (s) => s.split(",").map(x => x.trim()).filter(Boolean).map(Number);
        let rr_thresholds = null;
        let rr_weights = null;
        if (rr_sizing) {
          rr_thresholds = parseCsvNums(thrRaw);
          rr_weights = parseCsvNums(wtsRaw);
          if (rr_thresholds.length === 0 || rr_thresholds.length > 5) return setMsg("收益率阈值必须为 1~5 个逗号分隔数字，例如 50,100,150,200,250");
          if (rr_weights.length !== rr_thresholds.length + 1) return setMsg("仓位档位数量必须 = 阈值数量 + 1，例如 6 档对应 5 个阈值");
          rr_thresholds = rr_thresholds.map(x => (x > 1.0 ? x / 100.0 : x));
          rr_weights = rr_weights.map(x => (x > 1.0 ? x / 100.0 : x));
          for (const x of rr_thresholds) if (!Number.isFinite(x)) return setMsg("收益率阈值必须是数字");
          for (const x of rr_weights) if (!Number.isFinite(x)) return setMsg("仓位必须是数字");
          for (let i = 0; i + 1 < rr_thresholds.length; i++) if (!(rr_thresholds[i] < rr_thresholds[i + 1])) return setMsg("收益率阈值必须严格递增");
          for (const x of rr_weights) if (x < 0 || x > 1) return setMsg("仓位必须在 0~100%（或 0~1）");
        }
        const dd_control = ($("rotDDOn").value === "true");
        let dd_threshold = Number(($("rotDDThr").value || "10").trim());
        if (dd_control && (!Number.isFinite(dd_threshold) || dd_threshold <= 0)) return setMsg("回撤阈值 X 必须>0，例如 10 或 0.10");
        if (dd_threshold > 1.0) dd_threshold = dd_threshold / 100.0;
        if (dd_control && (dd_threshold <= 0 || dd_threshold >= 1.0)) return setMsg("回撤阈值 X 需在 (0,100%)，例如 10");
        let dd_reduce = Number(($("rotDDReduce").value || "100").trim());
        if (dd_control && (!Number.isFinite(dd_reduce) || dd_reduce < 0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        if (dd_reduce > 1.0) dd_reduce = dd_reduce / 100.0;
        if (dd_control && (dd_reduce < 0 || dd_reduce > 1.0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        const dd_sleep_days = Number(($("rotDDSleep").value || "20").trim());
        if (dd_control && (!Number.isFinite(dd_sleep_days) || dd_sleep_days < 1)) return setMsg("休眠天数必须>=1，例如 20");
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        if (trend_filter && (!Number.isFinite(trend_sma_window) || trend_sma_window <= 0)) return setMsg("趋势 SMA 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_window) || rsi_window <= 0)) return setMsg("RSI 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_overbought) || rsi_overbought < 0 || rsi_overbought > 100)) return setMsg("RSI 超买阈值需在 0~100");
        if (rsi_filter && (!Number.isFinite(rsi_oversold) || rsi_oversold < 0 || rsi_oversold > 100)) return setMsg("RSI 超卖阈值需在 0~100");
        if (vol_monitor && (!Number.isFinite(vol_window) || vol_window <= 0)) return setMsg("Vol 窗口必须是正整数");
        if (vol_monitor && (!Number.isFinite(vol_target_ann) || vol_target_ann <= 0)) return setMsg("目标年化Vol必须>0，例如 0.20");
        if (vol_monitor && (!Number.isFinite(vol_max_ann) || vol_max_ann <= 0)) return setMsg("最大年化Vol必须>0，例如 0.60");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_window) || chop_window <= 1)) return setMsg("ER窗口必须>=2");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_er_threshold) || chop_er_threshold <= 0)) return setMsg("ER阈值必须>0，例如 0.25");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_window) || chop_adx_window <= 1)) return setMsg("ADX窗口必须>=2");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_threshold) || chop_adx_threshold <= 0)) return setMsg("ADX阈值必须>0，例如 20");
        const parsed = parseCalendarAnchors("rot", rebalance);
        if (!parsed.ok) return setMsg(parsed.reason);
        const anchors = parsed.anchors;
        const exec_prices = _checkedValues("input.rotCalPx");
        if (anchors.length === 0) return setMsg("请至少选择一个调仓锚点");
        if (exec_prices.length === 0) return setMsg("请至少选择一个成交价口径（开盘/收盘/OC均价）");

        $("status").textContent = "计算日历效应（轮动）...";
        setMsg("");
        const asset_rc_rules = (() => {
          const rb = window.__riskRuleBook || {};
          const out = [];
          for (const [code, r] of Object.entries(rb)) {
            if (!r) continue;
            out.push({
              code,
              sig_type: r.sigType,
              k: Number(r.k),
              p_in: Number(r.p),
              reduce_pct: Number(r.reduce),
              recovery_mode: r.recoveryMode || "immediate",
              p_out: (r.pOut == null ? null : Number(r.pOut)),
              cooldown_days: Number(r.cooldownDays || 0),
            });
          }
          return out.length ? out : null;
        })();
        const resp = await api("/analysis/rotation/calendar-effect", {
          method: "POST",
          body: JSON.stringify({
            codes, start, end, rebalance, rebalance_shift, top_k, lookback_days, skip_days, cost_bps,
            risk_off, momentum_floor, risk_free_rate,
            score_method,
            tp_sl_mode,
            atr_window, atr_mult, atr_step, atr_min_mult,
            corr_filter, corr_window, corr_threshold,
            rr_sizing, rr_years, rr_thresholds, rr_weights,
            dd_control, dd_threshold, dd_reduce, dd_sleep_days,
            trend_filter, trend_mode, trend_sma_window,
            rsi_filter, rsi_window, rsi_overbought, rsi_oversold,
            vol_monitor, vol_window, vol_target_ann, vol_max_ann,
            chop_filter, chop_mode, chop_window, chop_er_threshold, chop_adx_window, chop_adx_threshold,
            anchors, exec_prices,
            asset_rc_rules,
          }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        _renderCalendarTable("rotCalTable", data);
      }

      async function runAnalysis() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const benchmark_code = $("benchmark").value || null;
        const rebalance = $("rebalance").value || "yearly";
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 0.02");
        // allow percent input like "2.5" to mean 2.5%
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        const fftWindowsRaw = (($("fftWindows") && $("fftWindows").value) ? $("fftWindows").value : "252,126").trim();
        const fft_windows = fftWindowsRaw
          .split(",")
          .map((x) => x.trim())
          .filter(Boolean)
          .map((x) => Number(x))
          .filter((x) => Number.isFinite(x))
          .map((x) => Math.floor(x))
          .filter((x) => x >= 8);
        if (fft_windows.length === 0) return setMsg("FFT滚动窗口必须至少包含一个 >=8 的交易日整数，例如 252,126");
        const fft_roll = ($("fftRollOn").value === "true");
        const fft_roll_step = Math.max(1, Math.floor(Number(($("fftRollStep").value || "5").trim())));
        if (!Number.isFinite(fft_roll_step) || fft_roll_step < 1) return setMsg("滚动FFT步长必须是正整数，例如 5");
        $("status").textContent = "计算中...";
        setMsg("");
        const resp = await api("/analysis/baseline", { method: "POST", body: JSON.stringify({ codes, start, end, benchmark_code, adjust: ADJUST_USED, rebalance, risk_free_rate, fft_windows, fft_roll, fft_roll_step }) });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        lastBaseline = data;
        window.__lastBaselineResult = data;
        corrRangeKey = "all";
        plotNav(data.nav);
        renderMetrics(data.metrics);
        renderContributionTables("ew", data.attribution);
        periodState.weekly.data = data.period_returns.weekly || [];
        periodState.monthly.data = data.period_returns.monthly || [];
        periodState.quarterly.data = data.period_returns.quarterly || [];
        periodState.yearly.data = data.period_returns.yearly || [];
        periodState.weekly.page = 1;
        periodState.monthly.page = 1;
        periodState.quarterly.page = 1;
        periodState.yearly.page = 1;
        renderPeriodPaged("weekly");
        renderPeriodPaged("monthly");
        renderPeriodPaged("quarterly");
        renderPeriodPaged("yearly");
        updateCorrRangeButtons();
        // default: full backtest range (client-side recompute for consistency)
        refreshCorrelationForRange("all");
        // show percent with 0 decimals
        plotRolling("rollingReturns", "Rolling Returns", data.rolling.returns, ".0%");
        plotRolling("rollingDD", "Rolling Drawdown", (data.rolling.drawdown || data.rolling.max_drawdown), ".0%");
        renderFft(data.fft);
        renderFftRoll(data.fft_roll);
        renderPeriodDistributions(data.period_distributions);
        try {
          _rcInitAssetSelect();
          _rcRenderRuleBook();
          if (!window.__rcHandlersAttached) {
            _rcAttachAssetTopHandlers();
            _rcAttachRuleBookHandlers();
            window.__rcHandlersAttached = true;
          }
          const c0 = ($("rcAssetCode") && $("rcAssetCode").value) ? $("rcAssetCode").value : (data.codes && data.codes[0]);
          if (c0) _rcRenderAssetTop(String(c0));
        } catch (e) { /* best effort */ }
      }

      function initTabs(containerId) {
        const root = $(containerId);
        if (!root) return;
        const buttons = Array.from(root.querySelectorAll(".tabBtn[data-tab]"));
        const panels = buttons.map(b => $(b.dataset.tab)).filter(Boolean);
        const setActive = (tabId) => {
          buttons.forEach((b) => {
            const on = (b.dataset.tab === tabId);
            b.classList.toggle("active", on);
            b.setAttribute("aria-selected", on ? "true" : "false");
          });
          panels.forEach((p) => p.classList.toggle("active", p.id === tabId));
        };
        buttons.forEach((b) => b.addEventListener("click", () => setActive(b.dataset.tab)));
        const first = buttons[0] && buttons[0].dataset ? buttons[0].dataset.tab : null;
        if (first) setActive(first);
      }
      initTabs("rotTabs");

      function setBoxVisible(boxId, on) {
        const el = $(boxId);
        if (!el) return;
        el.style.display = on ? "" : "none";
        const inputs = Array.from(el.querySelectorAll("input, select"));
        inputs.forEach((x) => { x.disabled = !on; });
      }
      function updateChopModeUI() {
        const chopOn = ($("rotChopOn").value === "true");
        const mode = ($("rotChopMode").value || "er");
        const showEr = chopOn && mode === "er";
        const showAdx = chopOn && mode === "adx";
        setBoxVisible("rotChopErBox", showEr);
        setBoxVisible("rotChopErThrBox", showEr);
        setBoxVisible("rotChopAdxBox", showAdx);
        setBoxVisible("rotChopAdxThrBox", showAdx);
      }
      $("rotChopOn").addEventListener("change", updateChopModeUI);
      $("rotChopMode").addEventListener("change", updateChopModeUI);
      updateChopModeUI();

      function updateTrendUi() {
        const mode = ($("trendStrategy") && $("trendStrategy").value) ? $("trendStrategy").value : "ma_filter";
        setBoxVisible("trendSmaBox", mode === "ma_filter" || mode === "ema_filter" || mode === "linreg_slope");
        setBoxVisible("trendCrossBox", mode === "ma_cross");
        setBoxVisible("trendDonchianBox", mode === "donchian");
        setBoxVisible("trendMomBox", mode === "tsmom");
        setBoxVisible("trendBiasBox", mode === "bias");
      }
      if ($("trendStrategy")) $("trendStrategy").addEventListener("change", updateTrendUi);
      updateTrendUi();

      $("run").addEventListener("click", runAnalysis);
      $("runRotation").addEventListener("click", runRotation);
      if ($("rcSearchOne")) $("rcSearchOne").addEventListener("click", rcSearchCurrentAsset);
      if ($("rcSearchAll")) $("rcSearchAll").addEventListener("click", rcSearchAllAssets);
      if ($("rcApplyComposite")) $("rcApplyComposite").addEventListener("click", rcApplyComposite);
      // Result table display limit
      if ($("rcAssetTopLimit")) {
        $("rcAssetTopLimit").addEventListener("change", () => {
          const cur = ($("rcAssetCode") && $("rcAssetCode").value) ? String($("rcAssetCode").value).trim() : "";
          if (cur) _rcRenderAssetTop(cur);
        });
      }
      async function runTrend() {
        const code = ($("trendCode") && $("trendCode").value) ? $("trendCode").value : "";
        if (!code) return setMsg("请先选择一个标的。");
        const start = ($("start").value || "").trim();
        const end = ($("end").value || "").trim();
        const strategy = ($("trendStrategy").value || "ma_filter");
        const sma_window = Number(($("trendSmaWin").value || "200").trim());
        const fast_window = Number(($("trendFastWin").value || "50").trim());
        const slow_window = Number(($("trendSlowWin").value || "200").trim());
        const donchian_entry = Number(($("trendDonEntry").value || "20").trim());
        const donchian_exit = Number(($("trendDonExit").value || "10").trim());
        const mom_lookback = Number(($("trendMomLb").value || "252").trim());
        const bias_ma_window = Number(($("trendBiasMA") && $("trendBiasMA").value ? $("trendBiasMA").value : "20").trim());
        const bias_entry_raw = Number(($("trendBiasEntry") && $("trendBiasEntry").value ? $("trendBiasEntry").value : "2").trim());
        const bias_hot_raw = Number(($("trendBiasHot") && $("trendBiasHot").value ? $("trendBiasHot").value : "10").trim());
        const bias_cold_raw = Number(($("trendBiasCold") && $("trendBiasCold").value ? $("trendBiasCold").value : "-2").trim());
        const bias_pos_mode = ($("trendBiasPosMode") && $("trendBiasPosMode").value) ? $("trendBiasPosMode").value : "binary";
        const cost_bps = Number(($("trendCost").value || "0").trim());
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;

        if (!Number.isFinite(cost_bps) || cost_bps < 0) return setMsg("交易成本(bps)必须>=0");
        if ((strategy === "ma_filter" || strategy === "ema_filter" || strategy === "linreg_slope") && (!Number.isFinite(sma_window) || sma_window < 2)) return setMsg("窗口必须>=2");
        if (strategy === "ma_cross") {
          if (!Number.isFinite(fast_window) || fast_window < 2) return setMsg("快均线窗口必须>=2");
          if (!Number.isFinite(slow_window) || slow_window < 2) return setMsg("慢均线窗口必须>=2");
          if (!(fast_window < slow_window)) return setMsg("快均线窗口必须小于慢均线窗口");
        }
        if (strategy === "donchian") {
          if (!Number.isFinite(donchian_entry) || donchian_entry < 2) return setMsg("入场窗口必须>=2");
          if (!Number.isFinite(donchian_exit) || donchian_exit < 2) return setMsg("退出窗口必须>=2");
        }
        if (strategy === "tsmom" && (!Number.isFinite(mom_lookback) || mom_lookback < 2)) return setMsg("动量回看必须>=2");
        if (strategy === "bias") {
          if (!Number.isFinite(bias_ma_window) || bias_ma_window < 2) return setMsg("BIAS MA窗口必须>=2");
          if (!Number.isFinite(bias_entry_raw)) return setMsg("入场阈值(%)必须是数字");
          if (!Number.isFinite(bias_hot_raw)) return setMsg("过热阈值(%)必须是数字");
          if (!Number.isFinite(bias_cold_raw)) return setMsg("过冷阈值(%)必须是数字");
          if (!(bias_cold_raw < bias_entry_raw && bias_entry_raw < bias_hot_raw)) return setMsg("阈值必须满足：过冷 < 入场 < 过热");
          if (!(bias_pos_mode === "binary" || bias_pos_mode === "continuous")) return setMsg("仓位模式必须是 0/1仓位 或 动态仓位");
        }

        $("status").textContent = "回测趋势策略中...";
        setMsg("");
        const resp = await api("/analysis/trend", {
          method: "POST",
          body: JSON.stringify({
            code, start, end,
            risk_free_rate,
            cost_bps,
            strategy,
            sma_window, fast_window, slow_window,
            donchian_entry, donchian_exit,
            mom_lookback,
            bias_ma_window,
            bias_entry: bias_entry_raw,
            bias_hot: bias_hot_raw,
            bias_cold: bias_cold_raw,
            bias_pos_mode,
          }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);

        // plots
        const dates = data.nav.dates;
        const s = data.nav.series;
        const dd = (nav) => {
          let peak = -Infinity;
          const out = [];
          for (const v of nav) {
            const x = Number(v);
            if (!Number.isFinite(x) || x <= 0) { out.push(null); continue; }
            peak = Math.max(peak, x);
            out.push(peak > 0 ? (x / peak - 1.0) : null);
          }
          return out;
        };
        Plotly.newPlot("trendChart", [
          { x: dates, y: s.STRAT, mode: "lines", name: "STRAT", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
          { x: dates, y: s.BUY_HOLD, mode: "lines", name: "BUY_HOLD", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
        ], { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { type: "log", dtick: Math.log10(2.0), tickformat: ".0f", gridcolor: "#eee" } }, { responsive: true });
        Plotly.newPlot("trendDD", [
          { x: dates, y: dd(s.STRAT), mode: "lines", name: "STRAT DD", hovertemplate: "%{x}<br>%{y:.1%}<extra></extra>" },
          { x: dates, y: dd(s.BUY_HOLD), mode: "lines", name: "BH DD", hovertemplate: "%{x}<br>%{y:.1%}<extra></extra>" },
        ], { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { tickformat: ".0%", gridcolor: "#eee", zeroline: true, zerolinecolor: "#bbb" } }, { responsive: true });

        // metrics table
        const ms = (data.metrics && data.metrics.strategy) ? data.metrics.strategy : {};
        const mb = (data.metrics && data.metrics.benchmark) ? data.metrics.benchmark : {};
        const ex = (data.metrics && data.metrics.excess) ? data.metrics.excess : {};
        const rows = [
          ["策略累积收益", fmtPct(ms.cumulative_return), "买入持有累积收益", fmtPct(mb.cumulative_return)],
          ["策略年化收益", fmtPct(ms.annualized_return), "买入持有年化收益", fmtPct(mb.annualized_return)],
          ["策略年化波动", fmtPct(ms.annualized_volatility), "买入持有年化波动", fmtPct(mb.annualized_volatility)],
          ["策略最大回撤", fmtPct(ms.max_drawdown), "买入持有最大回撤", fmtPct(mb.max_drawdown)],
          ["策略夏普", fmtNum(ms.sharpe_ratio), "买入持有夏普", fmtNum(mb.sharpe_ratio)],
          ["策略索诺提", fmtNum(ms.sortino_ratio), "买入持有索诺提", fmtNum(mb.sortino_ratio)],
          ["策略溃疡(UI)", fmtNum(ms.ulcer_index), "买入持有溃疡(UI)", fmtNum(mb.ulcer_index)],
          ["平均日换手", fmtPct(ms.avg_daily_turnover), "超额年化收益(几何)", fmtPct((ex.annualized_return_geo != null) ? ex.annualized_return_geo : ex.annualized_return)],
          ["", "", "超额年化收益(算术)", fmtPct(ex.annualized_return_arith)],
          ["超额累积收益", fmtPct(ex.cumulative_return), "信息比率(近似)", fmtNum(ex.information_ratio)],
        ];
        $("trendMetrics").innerHTML =
          `<tr><th colspan="2">策略</th><th colspan="2">基准/超额</th></tr>` +
          rows.map(r => `<tr><td>${r[0]}</td><td>${r[1]}</td><td>${r[2]}</td><td>${r[3]}</td></tr>`).join("");
      }
      $("runTrend").addEventListener("click", runTrend);
      $("runEwCalendar").addEventListener("click", runEwCalendarEffect);
      $("runRotCalendar").addEventListener("click", runRotCalendarEffect);
      $("exportPdf").addEventListener("click", exportPdfReport);

      // dynamic anchor options for calendar-effect panels (EW uses top rebalance; rotation uses rotRebalance)
      const updateEwAnchorUI = () => renderCalendarAnchorBox("ew", $("rebalance").value || "weekly");
      const updateRotAnchorUI = () => renderCalendarAnchorBox("rot", $("rotRebalance").value || "weekly");
      $("rebalance").addEventListener("change", updateEwAnchorUI);
      $("rotRebalance").addEventListener("change", updateRotAnchorUI);
      updateEwAnchorUI();
      updateRotAnchorUI();

      async function runMcEw() {
        const btn = $("runMcEw");
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const benchmark_code = $("benchmark").value || null;
        const rebalance = $("rebalance").value || "weekly";
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        const n_sims = Number(($("mcN").value || "2000").trim());
        const block_size = Number(($("mcBlock").value || "5").trim());
        const winRaw = ($("mcWindow").value || "").trim();
        const sample_window_days = winRaw === "" ? null : Number(winRaw);
        if (sample_window_days != null && !Number.isFinite(sample_window_days)) return setMsg("滚动窗口必须是整数交易日，例如 2520");
        const seedRaw = ($("mcSeed").value || "").trim();
        const seed = seedRaw === "" ? null : Number(seedRaw);
        const oldTxt = btn.textContent;
        btn.disabled = true;
        btn.textContent = "计算中...";
        $("status").textContent = "蒙特卡洛模拟中...";
        setMsg("");
        try {
          const resp = await api("/analysis/baseline/montecarlo", {
            method: "POST",
            body: JSON.stringify({ codes, start, end, benchmark_code, adjust: ADJUST_USED, rebalance, risk_free_rate, n_sims, block_size, seed, sample_window_days }),
          });
          const text = await resp.text();
          if (!resp.ok) return setMsg(text);
          const data = JSON.parse(text);
          lastMcEw = data.mc;
          renderMcTable("mcEwTable", data.mc);
          plotMcHist("mcEwHist", data.mc, $("mcEwMetric").value);
          renderFit("Ew", data.mc, $("mcEwMetric").value);
        } finally {
          $("status").textContent = "";
          btn.disabled = false;
          btn.textContent = oldTxt;
        }
      }

      async function runMcRot() {
        const btn = $("runMcRot");
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const rebalance = $("rotRebalance").value;
        const top_k = Number(($("rotTopK").value || "1").trim());
        const lookback_days = Number(($("rotLookback").value || "20").trim());
        const skip_days = Number(($("rotSkip").value || "0").trim());
        const cost_bps = Number(($("rotCost").value || "0").trim());
        const risk_off = ($("rotRiskOff").value === "true");
        const momentum_floor = Number(($("rotFloor").value || "0").trim());
        const score_method = $("rotScoreMethod").value;
        const tp_sl_mode = ($("rotTpSlMode").value || "none");
        const atrWindowRaw = ($("rotAtrWindow").value || "").trim();
        const atr_window = atrWindowRaw === "" ? null : Number(atrWindowRaw);
        if (atr_window != null && (!Number.isFinite(atr_window) || atr_window < 2)) return setMsg("ATR窗口必须>=2（或留空表示同步动量回看）");
        const atr_mult = Number(($("rotAtrMult").value || "2.0").trim());
        if (!Number.isFinite(atr_mult) || atr_mult <= 0) return setMsg("ATR倍数必须>0，例如 2");
        const atr_step = Number(($("rotAtrStep").value || "0.5").trim());
        if (!Number.isFinite(atr_step) || atr_step <= 0) return setMsg("渐进步长必须>0，例如 0.5");
        const atr_min_mult = Number(($("rotAtrMinMult").value || "0.5").trim());
        if (!Number.isFinite(atr_min_mult) || atr_min_mult <= 0) return setMsg("最小倍数必须>0，例如 0.5");
        const trend_filter = ($("rotTrendOn").value === "true");
        const trend_mode = $("rotTrendMode").value;
        const trend_sma_window = Number(($("rotTrendSma").value || "200").trim());
        const rsi_filter = ($("rotRsiOn").value === "true");
        const rsi_window = Number(($("rotRsiWin").value || "14").trim());
        const rsi_overbought = Number(($("rotRsiOver").value || "70").trim());
        const rsi_oversold = Number(($("rotRsiUnder").value || "30").trim());
        const vol_monitor = ($("rotVolOn").value === "true");
        const vol_window = Number(($("rotVolWin").value || "20").trim());
        const vol_target_ann = Number(($("rotVolTarget").value || "0.20").trim());
        const vol_max_ann = Number(($("rotVolMax").value || "0.60").trim());
        const chop_filter = ($("rotChopOn").value === "true");
        const chop_mode = ($("rotChopMode").value || "er");
        const chop_window = Number(($("rotChopWin").value || "20").trim());
        const chop_er_threshold = Number(($("rotChopThr").value || "0.25").trim());
        const chop_adx_window = Number(($("rotChopAdxWin").value || "20").trim());
        const chop_adx_threshold = Number(($("rotChopAdxThr").value || "20").trim());
        const corr_filter = ($("rotCorrOn").value === "true");
        const corrWinRaw = ($("rotCorrWindow").value || "").trim();
        const corr_window = corrWinRaw === "" ? null : Number(corrWinRaw);
        if (corr_filter && corr_window != null && (!Number.isFinite(corr_window) || corr_window < 2)) return setMsg("相关性回看窗口必须>=2（或留空表示同步动量回看）");
        const corr_threshold = Number(($("rotCorrThr").value || "0.5").trim());
        if (corr_filter && (!Number.isFinite(corr_threshold) || corr_threshold < -1 || corr_threshold > 1)) return setMsg("相关性阈值需在 [-1,1]，例如 0.5");
        const rr_sizing = ($("rotRROn").value === "true");
        const rrYearsRaw = ($("rotRRYears").value || "3").trim();
        const rr_years = Number(rrYearsRaw);
        if (rr_sizing && (!Number.isFinite(rr_years) || rr_years <= 0)) return setMsg("滚动收益率窗口年数 N 必须>0，例如 3");
        const thrRaw = ($("rotRRThr").value || "").trim();
        const wtsRaw = ($("rotRRWts").value || "").trim();
        const parseCsvNums = (s) => s.split(",").map(x => x.trim()).filter(Boolean).map(Number);
        let rr_thresholds = null;
        let rr_weights = null;
        if (rr_sizing) {
          rr_thresholds = parseCsvNums(thrRaw);
          rr_weights = parseCsvNums(wtsRaw);
          if (rr_thresholds.length === 0 || rr_thresholds.length > 5) return setMsg("收益率阈值必须为 1~5 个逗号分隔数字，例如 50,100,150,200,250");
          if (rr_weights.length !== rr_thresholds.length + 1) return setMsg("仓位档位数量必须 = 阈值数量 + 1，例如 6 档对应 5 个阈值");
          rr_thresholds = rr_thresholds.map(x => (x > 1.0 ? x / 100.0 : x));
          rr_weights = rr_weights.map(x => (x > 1.0 ? x / 100.0 : x));
          for (const x of rr_thresholds) if (!Number.isFinite(x)) return setMsg("收益率阈值必须是数字");
          for (const x of rr_weights) if (!Number.isFinite(x)) return setMsg("仓位必须是数字");
          for (let i = 0; i + 1 < rr_thresholds.length; i++) if (!(rr_thresholds[i] < rr_thresholds[i + 1])) return setMsg("收益率阈值必须严格递增");
          for (const x of rr_weights) if (x < 0 || x > 1) return setMsg("仓位必须在 0~100%（或 0~1）");
        }
        const dd_control = ($("rotDDOn").value === "true");
        let dd_threshold = Number(($("rotDDThr").value || "10").trim());
        if (dd_control && (!Number.isFinite(dd_threshold) || dd_threshold <= 0)) return setMsg("回撤阈值 X 必须>0，例如 10 或 0.10");
        if (dd_threshold > 1.0) dd_threshold = dd_threshold / 100.0;
        if (dd_control && (dd_threshold <= 0 || dd_threshold >= 1.0)) return setMsg("回撤阈值 X 需在 (0,100%)，例如 10");
        let dd_reduce = Number(($("rotDDReduce").value || "100").trim());
        if (dd_control && (!Number.isFinite(dd_reduce) || dd_reduce < 0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        if (dd_reduce > 1.0) dd_reduce = dd_reduce / 100.0;
        if (dd_control && (dd_reduce < 0 || dd_reduce > 1.0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        const dd_sleep_days = Number(($("rotDDSleep").value || "20").trim());
        if (dd_control && (!Number.isFinite(dd_sleep_days) || dd_sleep_days < 1)) return setMsg("休眠天数必须>=1，例如 20");
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        if (trend_filter && (!Number.isFinite(trend_sma_window) || trend_sma_window <= 0)) return setMsg("趋势 SMA 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_window) || rsi_window <= 0)) return setMsg("RSI 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_overbought) || rsi_overbought < 0 || rsi_overbought > 100)) return setMsg("RSI 超买阈值需在 0~100");
        if (rsi_filter && (!Number.isFinite(rsi_oversold) || rsi_oversold < 0 || rsi_oversold > 100)) return setMsg("RSI 超卖阈值需在 0~100");
        if (vol_monitor && (!Number.isFinite(vol_window) || vol_window <= 0)) return setMsg("Vol 窗口必须是正整数");
        if (vol_monitor && (!Number.isFinite(vol_target_ann) || vol_target_ann <= 0)) return setMsg("目标年化Vol必须>0，例如 0.20");
        if (vol_monitor && (!Number.isFinite(vol_max_ann) || vol_max_ann <= 0)) return setMsg("最大年化Vol必须>0，例如 0.60");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_window) || chop_window <= 1)) return setMsg("ER窗口必须>=2");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_er_threshold) || chop_er_threshold <= 0)) return setMsg("ER阈值必须>0，例如 0.25");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_window) || chop_adx_window <= 1)) return setMsg("ADX窗口必须>=2");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_threshold) || chop_adx_threshold <= 0)) return setMsg("ADX阈值必须>0，例如 20");
        const n_sims = Number(($("mcN").value || "2000").trim());
        const block_size = Number(($("mcBlock").value || "5").trim());
        const winRaw = ($("mcWindow").value || "").trim();
        const sample_window_days = winRaw === "" ? null : Number(winRaw);
        if (sample_window_days != null && !Number.isFinite(sample_window_days)) return setMsg("滚动窗口必须是整数交易日，例如 2520");
        const seedRaw = ($("mcSeed").value || "").trim();
        const seed = seedRaw === "" ? null : Number(seedRaw);
        const oldTxt = btn.textContent;
        btn.disabled = true;
        btn.textContent = "计算中...";
        $("status").textContent = "蒙特卡洛模拟中...";
        setMsg("");
        try {
          const asset_rc_rules = (() => {
            const rb = window.__riskRuleBook || {};
            const out = [];
            for (const [code, r] of Object.entries(rb)) {
              if (!r) continue;
              out.push({
                code,
                sig_type: r.sigType,
                k: Number(r.k),
                p_in: Number(r.p),
                reduce_pct: Number(r.reduce),
                recovery_mode: r.recoveryMode || "immediate",
                p_out: (r.pOut == null ? null : Number(r.pOut)),
                cooldown_days: Number(r.cooldownDays || 0),
              });
            }
            return out.length ? out : null;
          })();
          const resp = await api("/analysis/rotation/montecarlo", {
            method: "POST",
            body: JSON.stringify({
              codes, start, end, rebalance, top_k, lookback_days, skip_days, cost_bps,
              risk_off, momentum_floor, risk_free_rate,
              score_method,
              tp_sl_mode,
              atr_window, atr_mult, atr_step, atr_min_mult,
              corr_filter, corr_window, corr_threshold,
              rr_sizing, rr_years, rr_thresholds, rr_weights,
              dd_control, dd_threshold, dd_reduce, dd_sleep_days,
              trend_filter, trend_mode, trend_sma_window,
              rsi_filter, rsi_window, rsi_overbought, rsi_oversold,
              vol_monitor, vol_window, vol_target_ann, vol_max_ann,
              chop_filter, chop_mode, chop_window, chop_er_threshold, chop_adx_window, chop_adx_threshold,
              asset_rc_rules,
              n_sims, block_size, seed, sample_window_days
            }),
          });
          const text = await resp.text();
          if (!resp.ok) return setMsg(text);
          const data = JSON.parse(text);
          lastMcRot = data.mc.strategy;
          lastMcExcess = data.mc.excess;
          renderMcTable("mcRotTable", data.mc.strategy);
          renderMcTable("mcExcessTable", data.mc.excess);
          plotMcHist("mcRotHist", data.mc.strategy, $("mcRotMetric").value);
          plotMcHist("mcExcessHist", data.mc.excess, $("mcExcessMetric").value);
          renderFit("Rot", data.mc.strategy, $("mcRotMetric").value);
          renderFit("Excess", data.mc.excess, $("mcExcessMetric").value);
          // Observed holding-period length distributions (per-code)
          try {
            const obs = (data.observed_holding_len || {});
            renderHoldingLenDistInto("mcRot", obs.holding_streaks || obs.holdings || [], obs.nav_dates || []);
          } catch (e) { /* ignore */ }
          // Monte Carlo period-return distributions (strategy & excess)
          _renderPeriodDistTable("mcRotPeriodStats", data.mc.strategy ? data.mc.strategy.period_return : null);
          _renderPeriodDistTable("mcExcessPeriodStats", data.mc.excess ? data.mc.excess.period_return : null);
          _plotPeriodDistHist("mcRotPeriodHist", data.mc.strategy ? data.mc.strategy.period_return : null, "MC 策略逐期收益率分布", "#4c78a8");
          _plotPeriodDistHist("mcExcessPeriodHist", data.mc.excess ? data.mc.excess.period_return : null, "MC 逐期超额收益率分布（轮动-等权）", "#f58518");
        } finally {
          $("status").textContent = "";
          btn.disabled = false;
          btn.textContent = oldTxt;
        }
      }

      $("runMcEw").addEventListener("click", runMcEw);
      $("runMcRot").addEventListener("click", runMcRot);

      // mini-program fixed rotation wiring
      if ($("mpRotA_mix")) $("mpRotA_mix").addEventListener("click", () => _mpRotSetAnchor("mix"));
      if ($("mpRotA_0")) $("mpRotA_0").addEventListener("click", () => _mpRotSetAnchor("0"));
      if ($("mpRotA_1")) $("mpRotA_1").addEventListener("click", () => _mpRotSetAnchor("1"));
      if ($("mpRotA_2")) $("mpRotA_2").addEventListener("click", () => _mpRotSetAnchor("2"));
      if ($("mpRotA_3")) $("mpRotA_3").addEventListener("click", () => _mpRotSetAnchor("3"));
      if ($("mpRotA_4")) $("mpRotA_4").addEventListener("click", () => _mpRotSetAnchor("4"));
      Array.from(document.querySelectorAll("button.mpRotRange[data-k]")).forEach((b) => {
        b.addEventListener("click", () => { mpRotState.rangeKey = String(b.dataset.k || "all"); });
      });
      if ($("runMpRot")) $("runMpRot").addEventListener("click", runMiniRotationToMain);
      _mpRotSetAnchor("mix");

      // Correlation range buttons (default full range; disable unavailable based on current backtest).
      const wireCorrBtn = (key, id) => {
        const el = $(id);
        if (!el) return;
        el.addEventListener("click", () => {
          corrRangeKey = key;
          refreshCorrelationForRange(key);
        });
      };
      wireCorrBtn("1m", "corrRange1m");
      wireCorrBtn("3m", "corrRange3m");
      wireCorrBtn("6m", "corrRange6m");
      wireCorrBtn("1y", "corrRange1y");
      wireCorrBtn("3y", "corrRange3y");
      wireCorrBtn("5y", "corrRange5y");
      wireCorrBtn("10y", "corrRange10y");
      wireCorrBtn("all", "corrRangeAll");

      function updateAtrUi() {
        const mode = ($("rotTpSlMode").value || "none");
        const isAtr = (mode === "atr_chandelier_fixed" || mode === "atr_chandelier_progressive");
        const prog = (mode === "atr_chandelier_progressive");
        $("rotAtrWindow").disabled = !isAtr;
        $("rotAtrMult").disabled = !isAtr;
        $("rotAtrStepBox").style.display = prog ? "" : "none";
        $("rotAtrMinMultBox").style.display = prog ? "" : "none";
        $("rotAtrStep").disabled = !prog;
        $("rotAtrMinMult").disabled = !prog;
      }
      $("rotTpSlMode").addEventListener("change", updateAtrUi);
      updateAtrUi();

      // Re-plot histograms when metric selection changes (if mc already rendered)
      $("mcEwMetric").addEventListener("change", () => {
        if (!lastMcEw) return;
        plotMcHist("mcEwHist", lastMcEw, $("mcEwMetric").value);
        renderFit("Ew", lastMcEw, $("mcEwMetric").value);
      });
      $("mcRotMetric").addEventListener("change", () => {
        if (!lastMcRot) return;
        plotMcHist("mcRotHist", lastMcRot, $("mcRotMetric").value);
        renderFit("Rot", lastMcRot, $("mcRotMetric").value);
      });
      $("mcExcessMetric").addEventListener("change", () => {
        if (!lastMcExcess) return;
        plotMcHist("mcExcessHist", lastMcExcess, $("mcExcessMetric").value);
        renderFit("Excess", lastMcExcess, $("mcExcessMetric").value);
      });
      $("metricModalClose").addEventListener("click", closeMetricModal);
      $("metricModal").addEventListener("click", (e) => {
        if (e.target && e.target.id === "metricModal") closeMetricModal();
      });
      // Global delegation for all help buttons (metrics + parameters)
      document.addEventListener("click", (e) => {
        const btn = e.target && e.target.closest ? e.target.closest("button.helpBtn") : null;
        if (!btn) return;
        const key = btn.getAttribute("data-metric");
        if (!key) return;
        openMetricModal(key, {});
      });
      wirePeriodControls("weekly");
      wirePeriodControls("monthly");
      wirePeriodControls("quarterly");
      wirePeriodControls("yearly");

      $("rotPeriodSortKey").addEventListener("change", () => { rotState.page = 1; renderRotPeriods(); });
      $("rotPeriodSortDir").addEventListener("change", () => { rotState.page = 1; renderRotPeriods(); });
      $("rotPeriodPrev").addEventListener("click", () => { rotState.page -= 1; renderRotPeriods(); });
      $("rotPeriodNext").addEventListener("click", () => { rotState.page += 1; renderRotPeriods(); });
      wireRotPeriodControls("weekly");
      wireRotPeriodControls("monthly");
      wireRotPeriodControls("quarterly");
      wireRotPeriodControls("yearly");
      $("selAll").addEventListener("click", () => { pool.forEach(x => selected.add(x.code)); renderCodeList(); renderBenchmarkSelect(); });
      $("selAll").addEventListener("click", () => { maybeAdjustBacktestRange(); renderRangeHint(); });
      $("selNone").addEventListener("click", () => { selected.clear(); renderCodeList(); renderBenchmarkSelect(); maybeAdjustBacktestRange(); renderRangeHint(); });
      $("selInvert").addEventListener("click", () => {
        const next = new Set();
        for (const it of pool) if (!selected.has(it.code)) next.add(it.code);
        selected.clear(); for (const c of next) selected.add(c);
        renderCodeList(); renderBenchmarkSelect(); maybeAdjustBacktestRange(); renderRangeHint();
      });

      $("range1y").addEventListener("click", () => { setMsg(""); applyQuickRange(1); });
      $("range3y").addEventListener("click", () => { setMsg(""); applyQuickRange(3); });
      $("range5y").addEventListener("click", () => { setMsg(""); applyQuickRange(5); });
      $("range10y").addEventListener("click", () => { setMsg(""); applyQuickRange(10); });
      $("rangeAll").addEventListener("click", () => { setMsg(""); applyQuickRange(null); });

      loadPool().catch(e => setMsg(String(e)));
    </script>
  </body>
</html>

