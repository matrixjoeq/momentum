<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>基准分析（等权组合）</title>
    <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
    <style>
      body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 24px; }
      .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: end; }
      label { display: block; font-size: 12px; color: #444; margin-bottom: 4px; }
      input, select { padding: 8px; min-width: 180px; }
      button { padding: 8px 12px; cursor: pointer; }
      .muted { color: #666; font-size: 12px; }
      .panel { margin-top: 16px; }
      table { border-collapse: collapse; width: 100%; }
      th, td { border-bottom: 1px solid #ddd; padding: 8px; text-align: left; font-size: 13px; }
      th { background: #f7f7f7; }
      #chart, #rollingReturns, #rollingDD { width: 100%; height: 520px; }
      .two { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
      .code-list { max-height: 220px; overflow: auto; border: 1px solid #ddd; padding: 8px; min-width: 320px; }
      .msg { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; }
      .no-print { }
      .tabs { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; border-bottom: 1px solid #ddd; padding-bottom: 8px; margin-bottom: 12px; }
      .tabBtn { padding: 8px 12px; border: 1px solid #bbb; background: #fff; border-radius: 10px 10px 0 0; cursor: pointer; }
      .tabBtn.active { border-color: #444; font-weight: 600; }
      .tabPanel { display: none; }
      .tabPanel.active { display: block; }

      @media print {
        body { margin: 12mm; }
        .no-print { display: none !important; }
        #metricModal { display: none !important; }
        .panel, table { break-inside: avoid; page-break-inside: avoid; }
        h2, h3 { break-after: avoid; page-break-after: avoid; }
        #chart, #rollingReturns, #rollingDD,
        #ewCalHeatmap, #ewCalRollingChart,
        #rotChart, #rotDDCompare, #rotExcessChart, #rot40dDiffChart, #rotRollingCombo, #rotExcessRollingCombo,
        #rotCalHeatmap, #rotCalRollingChart,
        #corrHeatmap,
        #trendChart, #trendDD,
        #mcEwHist, #mcRotHist, #mcExcessHist,
        #mcEwQQ, #mcRotQQ, #mcExcessQQ {
          height: 420px !important;
        }
      }
    </style>
  </head>
  <body>
    <h2>基准分析：等权持有组合</h2>
    <div class="muted">用于动量轮动研究的基准数据：标的净值、等权组合净值、绩效指标与滚动统计。</div>

    <div class="panel row no-print">
      <div>
        <label>开始日期</label>
        <input id="start" placeholder="YYYYMMDD" />
      </div>
      <div>
        <label>结束日期</label>
        <input id="end" placeholder="YYYYMMDD" />
      </div>
      <div style="min-width: 420px;">
        <label>回测区间快捷选项（按勾选标的共同区间计算）</label>
        <div class="row" style="gap:8px; align-items:center;">
          <button id="range1y" title="近一年（按共同最大区间）">近一年</button>
          <button id="range3y" title="近三年（按共同最大区间）">近三年</button>
          <button id="range5y" title="近五年（按共同最大区间）">近五年</button>
          <button id="range10y" title="近十年（按共同最大区间）">近十年</button>
          <button id="rangeAll" title="成立以来（按共同最大区间）">成立以来</button>
          <span id="rangeHint" class="muted" style="margin-left:6px;"></span>
        </div>
      </div>
      <div>
        <label>等权再平衡周期</label>
        <select id="rebalance">
          <option value="daily">日度</option>
          <option value="weekly" selected>周度（默认）</option>
          <option value="monthly">月度</option>
          <option value="quarterly">季度</option>
          <option value="yearly">年度</option>
          <option value="none">不平衡（买入持有）</option>
        </select>
      </div>
      <div>
        <label>基准标的（用于信息比率）</label>
        <select id="benchmark"></select>
      </div>
      <div>
        <label>无风险收益率（年化，长期中国0-1年国债）</label>
        <input id="rf" placeholder="如 2.5 或 0.025" value="2.5" />
      </div>
      <button id="run">运行分析</button>
      <button id="exportPdf">导出PDF报告</button>
      <div id="status" class="muted"></div>
    </div>

    <div class="panel no-print">
      <div class="row">
        <div class="code-list" id="codes"></div>
        <div class="muted">
          勾选候选池中的标的组成组合。图例可点击隐藏/显示曲线。
          <div style="margin-top:8px">
            <button id="selAll">全选</button>
            <button id="selNone">取消全选</button>
            <button id="selInvert">反选</button>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="muted" id="dataNote">
        数据口径：交易价格=none（不复权）；动量评分/动量门槛=hfq（后复权，总回报）；趋势/RSI/波动率/震荡过滤= qfq（前复权）。
      </div>
      <div id="chart"></div>
    </div>

    <div class="panel">
      <div class="two" style="grid-template-columns: 1.05fr 1.95fr; align-items:start;">
        <div>
          <h3>等权组合指标</h3>
          <table id="metrics"></table>
        </div>

        <div>
          <h3>周期收益率（等权组合）</h3>

          <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start;">
            <div>
              <div class="muted">周度</div>
              <div class="row" style="gap:8px; margin:6px 0;">
                <select id="weeklySortKey" style="min-width:120px;">
                  <option value="date">日期</option>
                  <option value="return">收益</option>
                </select>
                <select id="weeklySortDir" style="min-width:120px;">
                  <option value="desc">递减</option>
                  <option value="asc">递增</option>
                </select>
                <button id="weeklyPrev">上一页</button>
                <button id="weeklyNext">下一页</button>
                <span class="muted" id="weeklyPage"></span>
              </div>
              <table id="weekly"></table>

              <div style="margin-top:12px">
                <div class="muted">季度</div>
                <div class="row" style="gap:8px; margin:6px 0;">
                  <select id="quarterlySortKey" style="min-width:120px;">
                    <option value="date">日期</option>
                    <option value="return">收益</option>
                  </select>
                  <select id="quarterlySortDir" style="min-width:120px;">
                    <option value="desc">递减</option>
                    <option value="asc">递增</option>
                  </select>
                  <button id="quarterlyPrev">上一页</button>
                  <button id="quarterlyNext">下一页</button>
                  <span class="muted" id="quarterlyPage"></span>
                </div>
                <table id="quarterly"></table>
              </div>
            </div>

            <div>
              <div class="muted">月度</div>
              <div class="row" style="gap:8px; margin:6px 0;">
                <select id="monthlySortKey" style="min-width:120px;">
                  <option value="date">日期</option>
                  <option value="return">收益</option>
                </select>
                <select id="monthlySortDir" style="min-width:120px;">
                  <option value="desc">递减</option>
                  <option value="asc">递增</option>
                </select>
                <button id="monthlyPrev">上一页</button>
                <button id="monthlyNext">下一页</button>
                <span class="muted" id="monthlyPage"></span>
              </div>
              <table id="monthly"></table>

              <div style="margin-top:12px">
                <div class="muted">年度</div>
                <div class="row" style="gap:8px; margin:6px 0;">
                  <select id="yearlySortKey" style="min-width:120px;">
                    <option value="date">日期</option>
                    <option value="return">收益</option>
                  </select>
                  <select id="yearlySortDir" style="min-width:120px;">
                    <option value="desc">递减</option>
                    <option value="asc">递增</option>
                  </select>
                  <button id="yearlyPrev">上一页</button>
                  <button id="yearlyNext">下一页</button>
                  <span class="muted" id="yearlyPage"></span>
                </div>
                <table id="yearly"></table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel two" style="grid-template-columns: 1fr 1fr; align-items:start;">
      <div>
        <h3>收益贡献（等权组合，全区间） <button class="helpBtn" data-metric="ew_return_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
        <table id="ewReturnContrib"></table>
      </div>
      <div>
        <h3>风险贡献（等权组合，全区间） <button class="helpBtn" data-metric="ew_risk_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
        <table id="ewRiskContrib"></table>
      </div>
    </div>

    <div class="panel">
      <h3>相关性矩阵（日收益） <span id="corrRangeTitle" class="muted"></span></h3>
      <div class="muted">口径：hfq（后复权）。横纵坐标为标的编号（见下方映射）。</div>
      <div class="row no-print" style="gap:8px; margin-top:8px;">
        <button id="corrRange1m">近一月</button>
        <button id="corrRange3m">近三月</button>
        <button id="corrRange6m">近六月</button>
        <button id="corrRange1y">近一年</button>
        <button id="corrRange3y">近三年</button>
        <button id="corrRange5y">近五年</button>
        <button id="corrRange10y">近十年</button>
        <button id="corrRangeAll">全回测区间</button>
        <span id="corrRangeHint" class="muted" style="margin-left:6px;"></span>
      </div>
      <div id="corrLegend" class="muted" style="margin-top:6px;"></div>
      <div id="corrHeatmap" style="width:100%; height:520px;"></div>
    </div>

    <div class="panel two" style="grid-template-columns: 1fr 1fr; align-items:start;">
      <div>
        <h3>滚动收益率（等权组合）</h3>
        <div id="rollingReturns"></div>
      </div>
      <div>
        <h3>滚动最大回撤（等权组合）</h3>
        <div id="rollingDD"></div>
      </div>
    </div>

    <!-- RSI is overlaid on NAV charts (secondary axis) -->

    <div class="panel">
      <h3>傅里叶变换分析（候选标的）</h3>
      <div class="muted">口径：对数收益（Δlog(P)）；输出主导周期、频段能量占比（低/中/高频）与谱熵。默认同时给出全区间与近1年/近半年窗口。</div>
      <div class="row no-print" style="margin-top:8px">
        <div>
          <label>FFT滚动窗口(交易日, 逗号分隔)</label>
          <input id="fftWindows" value="252,126" />
        </div>
        <div>
          <label>滚动FFT指标开关</label>
          <select id="fftRollOn" style="min-width:160px;">
            <option value="true" selected>开启</option>
            <option value="false">关闭</option>
          </select>
        </div>
        <div>
          <label>滚动FFT步长(交易日)</label>
          <input id="fftRollStep" value="5" />
        </div>
      </div>
      <div id="fftSummary" class="muted" style="margin-top:8px;"></div>
      <table id="fftTable"></table>
    </div>

    <div class="panel">
      <h3>滚动FFT指标时间序列（等权 EW）</h3>
      <div class="muted">展示 EW 组合在不同滚动窗口下的谱熵与高频能量占比随时间变化（按步长采样）。如果某些阶段谱熵显著下降/高频占比下降，才可能用于降低换手或提高入场门槛。</div>
      <div id="fftRollEntropy" style="width:100%; height:420px; margin-top:8px;"></div>
      <div id="fftRollHigh" style="width:100%; height:420px; margin-top:8px;"></div>
    </div>

    <div class="panel">
      <h3>日历效应研究（等权 EW）</h3>
      <div class="muted">研究不同调仓周期下：调仓锚点（周度=周一~周五；月度=每月1~28号；季度/年度=当期第N个交易日）与成交价口径（开盘/收盘/OC均价）对组合表现的影响。此处参数与轮动策略研究互不影响。</div>
      <div class="row no-print" style="margin-top:8px; align-items:end;">
        <div>
          <label>开始日期（留空=沿用上方）</label>
          <input id="ewCalStart" placeholder="YYYYMMDD" />
        </div>
        <div>
          <label>结束日期（留空=沿用上方）</label>
          <input id="ewCalEnd" placeholder="YYYYMMDD" />
        </div>
        <div>
          <label>价格复权口径</label>
          <select id="ewCalAdjust" style="min-width:160px;">
            <option value="hfq" selected>hfq（后复权）</option>
            <option value="qfq">qfq（前复权）</option>
            <option value="none">none（不复权）</option>
          </select>
        </div>
        <div style="min-width:360px;">
          <label id="ewCalAnchorLabel">调仓锚点</label>
          <div id="ewCalAnchorBox"></div>
        </div>
        <div style="min-width:260px;">
          <label>成交价口径</label>
          <div class="row" style="gap:10px; align-items:center;">
            <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="ewCalPx" value="open" checked />开盘</label>
            <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="ewCalPx" value="close" checked />收盘</label>
            <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="ewCalPx" value="oc2" checked />OC均价</label>
          </div>
        </div>
        <button id="runEwCalendar">运行（日历效应 EW）</button>
      </div>
      <div id="ewCalHeatmap" style="width:100%; height:360px; margin-top:10px;"></div>
      <table id="ewCalTable" style="margin-top:6px;"></table>
      <div id="ewCalRollingChart" style="width:100%; height:360px; margin-top:12px;"></div>
      <table id="ewCalRollingStats" style="margin-top:6px;"></table>
    </div>

    <div class="panel">
      <h3>蒙特卡洛模拟（等权组合）</h3>
      <div class="row">
        <div>
          <label>模拟次数</label>
          <input id="mcN" value="10000" />
        </div>
        <div>
          <label>区块长度(交易日)</label>
          <input id="mcBlock" value="5" />
        </div>
        <div>
          <label>滚动窗口(交易日，可空)</label>
          <input id="mcWindow" placeholder="如 2520 表示近10年" />
        </div>
        <div>
          <label>随机种子(可空)</label>
          <input id="mcSeed" placeholder="如 42" />
        </div>
        <button id="runMcEw">运行蒙特卡洛（等权）</button>
      </div>
      <table id="mcEwTable"></table>
      <div class="row" style="margin-top:8px">
        <label>直方图指标</label>
        <select id="mcEwMetric" style="min-width:220px;">
          <option value="cumulative_return">累积收益</option>
          <option value="annualized_return">年化收益</option>
          <option value="annualized_volatility">年化波动</option>
          <option value="max_drawdown">最大回撤</option>
          <option value="sharpe_ratio">夏普</option>
        </select>
      </div>
      <div id="mcEwHist" style="width:100%; height:420px;"></div>
      <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
        <div>
          <div class="muted">分布拟合结果（按 BIC 排序）</div>
          <table id="mcEwFitTable"></table>
        </div>
        <div>
          <div class="row" style="gap:8px">
            <label>Q-Q 分布</label>
            <select id="mcEwDist" style="min-width:180px;"></select>
          </div>
          <div id="mcEwQQ" style="width:100%; height:420px;"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h2 style="margin-top: 8px">动量轮动回测</h2>
      <div class="muted">
        动量信号：hfq（后复权，总回报）；技术分析（趋势/RSI/波动率/震荡过滤）：qfq（前复权）；交易价格：none（不复权）。
        轮动净值：none 收益为主，但遇到拆分/分红等公司行为导致 none 价格断点时，用 hfq 的当日收益进行修正以避免净值虚假跳变；等权对比净值：hfq（后复权，总回报，含分红再投资），且等权再平衡频率与轮动调仓频率一致。
      </div>

      <div class="panel no-print">
        <div class="tabs" id="rotTabs" role="tablist" aria-label="动量轮动参数">
          <button class="tabBtn active" data-tab="rotTabBase" role="tab" aria-selected="true">基础参数</button>
          <button class="tabBtn" data-tab="rotTabFloor" role="tab" aria-selected="false">动量过滤</button>
          <button class="tabBtn" data-tab="rotTabTrend" role="tab" aria-selected="false">趋势过滤</button>
          <button class="tabBtn" data-tab="rotTabRsi" role="tab" aria-selected="false">RSI过滤</button>
          <button class="tabBtn" data-tab="rotTabVol" role="tab" aria-selected="false">波动率过滤</button>
          <button class="tabBtn" data-tab="rotTabChop" role="tab" aria-selected="false">震荡过滤</button>
          <button class="tabBtn" data-tab="rotTabCorr" role="tab" aria-selected="false">相关性过滤</button>
          <button class="tabBtn" data-tab="rotTabRR" role="tab" aria-selected="false">滚动收益率</button>
          <button class="tabBtn" data-tab="rotTabTpSl" role="tab" aria-selected="false">止盈止损</button>
          <button class="tabBtn" data-tab="rotTabTiming" role="tab" aria-selected="false">择时</button>
          <button class="tabBtn" data-tab="rotTabDD" role="tab" aria-selected="false">回撤控制</button>
        </div>

        <div id="rotTabBase" class="tabPanel active" role="tabpanel">
          <div class="row">
            <div>
              <label>调仓频率 <button class="helpBtn" data-metric="param_rot_rebalance" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotRebalance">
                <option value="daily">日度</option>
                <option value="weekly" selected>周度（默认）</option>
                <option value="monthly">月度</option>
                <option value="quarterly">季度</option>
                <option value="yearly">年度</option>
              </select>
            </div>
            <div>
              <label>TopK <button class="helpBtn" data-metric="param_rot_topk" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotTopK" value="1" />
            </div>
            <div>
              <label>打分方式 <button class="helpBtn" data-metric="param_rot_score_method" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotScoreMethod" style="min-width:200px;">
                <option value="raw_mom" selected>纯动量（raw）</option>
                <option value="return_over_vol">收益/波动率</option>
                <option value="sharpe_mom">Sharpe 动量</option>
                <option value="sortino_mom">Sortino 动量</option>
              </select>
            </div>
            <div>
              <label>动量回看(交易日) <button class="helpBtn" data-metric="param_rot_lookback" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotLookback" value="20" />
            </div>
            <div>
              <label>跳过最近(交易日) <button class="helpBtn" data-metric="param_rot_skip" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotSkip" value="0" />
            </div>
            <div>
              <label>交易成本(bps) <button class="helpBtn" data-metric="param_rot_cost" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotCost" value="0" />
            </div>
          </div>
        </div>

        <div id="rotTabFloor" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>动量阈值开关 <button class="helpBtn" data-metric="param_rot_riskoff" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotRiskOff">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">启用</option>
              </select>
            </div>
            <div>
              <label>动量阈值 <button class="helpBtn" data-metric="param_rot_floor" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <input id="rotFloor" value="0" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">说明：阈值触发后将进入空仓（现金）。</div>
        </div>

        <div id="rotTabTrend" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>趋势过滤开关 <button class="helpBtn" data-metric="param_rot_trend" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotTrendOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>趋势过滤模式</label>
              <select id="rotTrendMode" style="min-width:160px;">
                <option value="each" selected>逐标的</option>
                <option value="universe">全市场(候选均值)</option>
              </select>
            </div>
            <div>
              <label>SMA窗口(交易日)</label>
              <input id="rotTrendSma" value="20" />
            </div>
          </div>
        </div>

        <div id="rotTabRsi" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>RSI过滤开关 <button class="helpBtn" data-metric="param_rot_rsi" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotRsiOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>RSI窗口</label>
              <input id="rotRsiWin" value="20" />
            </div>
            <div>
              <label>超买阈值</label>
              <input id="rotRsiOver" value="70" />
            </div>
            <div>
              <label>超卖阈值</label>
              <input id="rotRsiUnder" value="30" />
            </div>
          </div>
        </div>

        <div id="rotTabVol" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>波动率过滤开关 <button class="helpBtn" data-metric="param_rot_vol" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotVolOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>波动率窗口</label>
              <input id="rotVolWin" value="20" />
            </div>
            <div>
              <label>目标年化波动率</label>
              <input id="rotVolTarget" value="0.20" />
            </div>
            <div>
              <label>最大年化波动率</label>
              <input id="rotVolMax" value="0.60" />
            </div>
          </div>
        </div>

        <div id="rotTabChop" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>震荡过滤开关 <button class="helpBtn" data-metric="param_rot_chop" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></label>
              <select id="rotChopOn" style="min-width:160px;">
                <option value="false" selected>关闭</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>模式</label>
              <select id="rotChopMode" style="min-width:160px;">
                <option value="er" selected>ER（Efficiency Ratio）</option>
                <option value="adx">ADX（Average Directional Index）</option>
              </select>
            </div>
            <div id="rotChopErBox">
              <label>ER窗口</label>
              <input id="rotChopWin" value="20" />
            </div>
            <div id="rotChopErThrBox">
              <label>ER阈值</label>
              <input id="rotChopThr" value="0.25" />
            </div>
            <div id="rotChopAdxBox">
              <label>ADX窗口</label>
              <input id="rotChopAdxWin" value="20" />
            </div>
            <div id="rotChopAdxThrBox">
              <label>ADX阈值</label>
              <input id="rotChopAdxThr" value="20" />
            </div>
          </div>
        </div>

        <div id="rotTabCorr" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>相关性过滤开关（hfq）</label>
              <select id="rotCorrOn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>回看窗口(交易日)</label>
              <input id="rotCorrWindow" placeholder="空=同步动量回看" />
            </div>
            <div>
              <label>相关性阈值</label>
              <input id="rotCorrThr" value="0.5" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：若本期计划调入标的与当前持仓标的在回看窗口内的相关性（基于 hfq 收盘价日收益）大于阈值，则本期不调仓（保持原持仓）。
          </div>
        </div>

        <div id="rotTabRR" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>滚动收益率仓位开关</label>
              <select id="rotRROn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>窗口年数 N</label>
              <input id="rotRRYears" value="3" />
            </div>
            <div style="min-width:360px;">
              <label>收益率阈值（最多5档）</label>
              <input id="rotRRThr" value="50,100,150,200,250" />
            </div>
            <div style="min-width:360px;">
              <label>对应仓位（阈值+1 档）</label>
              <input id="rotRRWts" value="100,80,60,40,20,10" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：调仓决策时，根据策略过去 N 年滚动收益率（基于策略净值）决定本期总仓位（现金为剩余仓位）。阈值和仓位支持输入百分比（如 50 表示 50%）。
          </div>
        </div>

        <div id="rotTabTpSl" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>止盈止损模式（qfq）</label>
              <select id="rotTpSlMode" style="min-width:240px;">
                <option value="none" selected>关闭（默认）</option>
                <option value="prev_week_low_stop">上一周期最低止损（止损价=上一调仓周期 qfq 收盘最低；持仓不变则更新为本周期最低）</option>
                <option value="atr_chandelier_fixed">ATR 吊灯止损（固定倍数）</option>
                <option value="atr_chandelier_progressive">ATR 吊灯止损（渐进式倍数）</option>
              </select>
            </div>
            <div>
              <label>ATR窗口(交易日)</label>
              <input id="rotAtrWindow" placeholder="空=同步动量回看" />
            </div>
            <div>
              <label>ATR倍数</label>
              <input id="rotAtrMult" value="2.0" />
            </div>
            <div id="rotAtrStepBox">
              <label>渐进步长(ATR)</label>
              <input id="rotAtrStep" value="0.5" />
            </div>
            <div id="rotAtrMinMultBox">
              <label>最小倍数(ATR)</label>
              <input id="rotAtrMinMult" value="0.5" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：止损价与触发均使用前复权(qfq)收盘价 close。触发后从下一交易日起空仓，直到下一次调仓。支持周/月/季/年等所有调仓周期（“上一周期/本周期”以调仓周期划分）。
          </div>
        </div>

        <div id="rotTabTiming" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>择时开关</label>
              <select id="rotTimingOn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>RSI窗口(交易日)</label>
              <select id="rotTimingRsiWin" style="min-width:160px;">
                <option value="6">6</option>
                <option value="12">12</option>
                <option value="24" selected>24</option>
              </select>
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            规则：当“策略净值 RSI” ≤ 50 时切换为等权持有（EW_REBAL），当 RSI &gt; 50 时重新激活轮动策略。<br/>
            重要：RSI 信号使用 <b>不考虑择时休眠</b> 的“假想净值（shadow NAV）”计算，避免“休眠导致RSI变形”的自我反馈问题；择时只改变实际持仓与净值。
          </div>
        </div>

        <div id="rotTabDD" class="tabPanel" role="tabpanel">
          <div class="row">
            <div>
              <label>回撤控制开关</label>
              <select id="rotDDOn" style="min-width:160px;">
                <option value="false" selected>关闭（默认）</option>
                <option value="true">开启</option>
              </select>
            </div>
            <div>
              <label>触发回撤阈值 X%</label>
              <input id="rotDDThr" value="10" />
            </div>
            <div>
              <label>减仓比例 Y%</label>
              <input id="rotDDReduce" value="100" />
            </div>
            <div>
              <label>休眠天数(交易日)</label>
              <input id="rotDDSleep" value="20" />
            </div>
          </div>
          <div class="muted" style="margin-top:8px">
            说明：以策略净值的峰值回撤为触发条件。触发后从下一交易日起将仓位按 (1 - Y) 缩放（Y=100% 则空仓），并在休眠期内保持上一日持仓（不再产生新的调仓决策），直至休眠结束后的下一次调仓。
            输入支持百分比（如 10 表示 10%）。
          </div>
        </div>

        <div class="row" style="margin-top:12px">
          <button id="runRotation">运行轮动回测</button>
        </div>
      </div>

      <div class="panel two" style="grid-template-columns: 1fr 1fr;">
        <div>
          <h3>净值曲线（轮动 vs 等权同频再平衡）</h3>
          <div id="rotChart" style="width:100%; height:520px;"></div>
          <h3 style="margin-top:12px">回撤对比（轮动 vs 等权）</h3>
          <div id="rotDDCompare" style="width:100%; height:260px;"></div>
        </div>
        <div>
          <h3>超额净值（轮动 / 等权）</h3>
          <div id="rotExcessChart" style="width:100%; height:520px;"></div>
          <h3 style="margin-top:12px">40日收益差（轮动 - 等权）</h3>
          <div id="rot40dDiffChart" style="width:100%; height:260px;"></div>
        </div>
      </div>

      <!-- RSI is overlaid on NAV/EXCESS charts (secondary axis) -->

      <div class="panel two" style="grid-template-columns: 1fr 1fr;">
        <div>
          <h3>轮动策略滚动收益&回撤（1/3/5年）</h3>
          <div id="rotRollingCombo" style="width:100%; height:520px;"></div>
        </div>
        <div>
          <h3>超额滚动收益&回撤（1/3/5年）</h3>
          <div id="rotExcessRollingCombo" style="width:100%; height:520px;"></div>
        </div>
      </div>

      <div class="panel two" style="grid-template-columns: 1fr 1fr;">
        <div>
          <h3>轮动策略指标</h3>
          <table id="rotMetrics"></table>
        </div>
        <div>
          <h3>轮动策略胜率赔率（按调仓周期）</h3>
          <table id="rotWinPayoff"></table>
        </div>
      </div>

      <div class="panel two" style="grid-template-columns: 1fr 1fr; align-items:start;">
        <div>
          <h3>收益贡献（轮动策略，全区间） <button class="helpBtn" data-metric="rot_return_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
          <table id="rotReturnContrib"></table>
        </div>
        <div>
          <h3>风险贡献（轮动策略，全区间） <button class="helpBtn" data-metric="rot_risk_contrib" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></h3>
          <table id="rotRiskContrib"></table>
        </div>
      </div>

      <div class="panel">
        <h3>轮动策略周期收益率（策略 none vs 基准 hfq）</h3>
        <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:8px">
          <div>
            <div class="muted">周度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotWeeklySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotWeeklySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotWeeklyPrev">上一页</button>
              <button id="rotWeeklyNext">下一页</button>
              <span class="muted" id="rotWeeklyPage"></span>
            </div>
            <table id="rotWeekly"></table>
          </div>
          <div>
            <div class="muted">月度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotMonthlySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotMonthlySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotMonthlyPrev">上一页</button>
              <button id="rotMonthlyNext">下一页</button>
              <span class="muted" id="rotMonthlyPage"></span>
            </div>
            <table id="rotMonthly"></table>
          </div>
        </div>
        <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:12px">
          <div>
            <div class="muted">季度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotQuarterlySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotQuarterlySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotQuarterlyPrev">上一页</button>
              <button id="rotQuarterlyNext">下一页</button>
              <span class="muted" id="rotQuarterlyPage"></span>
            </div>
            <table id="rotQuarterly"></table>
          </div>
          <div>
            <div class="muted">年度</div>
            <div class="row" style="gap:8px; margin:6px 0;">
              <select id="rotYearlySortKey" style="min-width:140px;">
                <option value="date">日期</option>
                <option value="strategy">策略收益</option>
                <option value="excess">超额收益</option>
              </select>
              <select id="rotYearlySortDir" style="min-width:120px;">
                <option value="desc">递减</option>
                <option value="asc">递增</option>
              </select>
              <button id="rotYearlyPrev">上一页</button>
              <button id="rotYearlyNext">下一页</button>
              <span class="muted" id="rotYearlyPage"></span>
            </div>
            <table id="rotYearly"></table>
          </div>
        </div>
      </div>

      <div class="panel">
        <h3>逐期对比（轮动 vs 等权）</h3>
        <div class="row" style="gap:8px; margin:6px 0;">
          <select id="rotPeriodSortKey" style="min-width:140px;">
            <option value="start">开始日期</option>
            <option value="end">结束日期</option>
            <option value="excess">超额收益</option>
          </select>
          <select id="rotPeriodSortDir" style="min-width:120px;">
            <option value="desc">递减</option>
            <option value="asc">递增</option>
          </select>
          <button id="rotPeriodPrev">上一页</button>
          <button id="rotPeriodNext">下一页</button>
          <span class="muted" id="rotPeriodPage"></span>
        </div>
        <table id="rotPeriods"></table>
      </div>

      <div class="panel">
        <h3>日历效应研究（轮动策略）</h3>
        <div class="muted">在保持轮动参数不变的前提下，批量回测不同调仓周期下的调仓锚点（周度/月度/季度/年度）与成交价口径（开盘/收盘/OC均价）对策略表现的影响。此处参数与等权研究互不影响。</div>
        <div class="row no-print" style="margin-top:8px; align-items:end;">
          <div>
            <label>开始日期（留空=沿用上方）</label>
            <input id="rotCalStart" placeholder="YYYYMMDD" />
          </div>
          <div>
            <label>结束日期（留空=沿用上方）</label>
            <input id="rotCalEnd" placeholder="YYYYMMDD" />
          </div>
          <div style="min-width:360px;">
            <label id="rotCalAnchorLabel">调仓锚点</label>
            <div id="rotCalAnchorBox"></div>
          </div>
          <div style="min-width:260px;">
            <label>成交价口径</label>
            <div class="row" style="gap:10px; align-items:center;">
              <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="rotCalPx" value="open" checked />开盘</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="rotCalPx" value="close" checked />收盘</label>
              <label style="display:flex; gap:6px; align-items:center; margin:0;"><input type="checkbox" class="rotCalPx" value="oc2" checked />OC均价</label>
            </div>
          </div>
          <button id="runRotCalendar">运行（日历效应 轮动）</button>
        </div>
        <div id="rotCalHeatmap" style="width:100%; height:360px; margin-top:10px;"></div>
        <table id="rotCalTable" style="margin-top:6px;"></table>
        <div id="rotCalRollingChart" style="width:100%; height:360px; margin-top:12px;"></div>
        <table id="rotCalRollingStats" style="margin-top:6px;"></table>
      </div>

    <div class="panel">
        <h3>蒙特卡洛模拟（轮动策略）</h3>
        <div class="row">
          <div class="muted">使用与等权相同的模拟次数/区块长度/种子配置。</div>
          <button id="runMcRot">运行蒙特卡洛（轮动）</button>
        </div>
        <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
          <div>
            <div class="muted">策略本身</div>
            <table id="mcRotTable"></table>
            <div class="row" style="margin-top:8px">
              <label>直方图指标</label>
              <select id="mcRotMetric" style="min-width:220px;">
                <option value="cumulative_return">累积收益</option>
                <option value="annualized_return">年化收益</option>
                <option value="annualized_volatility">年化波动</option>
                <option value="max_drawdown">最大回撤</option>
                <option value="sharpe_ratio">夏普</option>
              </select>
            </div>
            <div id="mcRotHist" style="width:100%; height:420px;"></div>
            <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
              <div>
                <div class="muted">分布拟合结果（按 BIC 排序）</div>
                <table id="mcRotFitTable"></table>
              </div>
              <div>
                <div class="row" style="gap:8px">
                  <label>Q-Q 分布</label>
                  <select id="mcRotDist" style="min-width:180px;"></select>
                </div>
                <div id="mcRotQQ" style="width:100%; height:420px;"></div>
              </div>
            </div>
          </div>
          <div>
            <div class="muted">超额（轮动-等权）</div>
            <table id="mcExcessTable"></table>
            <div class="row" style="margin-top:8px">
              <label>直方图指标</label>
              <select id="mcExcessMetric" style="min-width:220px;">
                <option value="cumulative_return">累积收益</option>
                <option value="annualized_return">年化收益</option>
                <option value="annualized_volatility">年化波动</option>
                <option value="max_drawdown">最大回撤</option>
                <option value="sharpe_ratio">夏普</option>
              </select>
            </div>
            <div id="mcExcessHist" style="width:100%; height:420px;"></div>
            <div class="two" style="grid-template-columns: 1fr 1fr; align-items:start; margin-top:8px">
              <div>
                <div class="muted">分布拟合结果（按 BIC 排序）</div>
                <table id="mcExcessFitTable"></table>
              </div>
              <div>
                <div class="row" style="gap:8px">
                  <label>Q-Q 分布</label>
                  <select id="mcExcessDist" style="min-width:180px;"></select>
                </div>
                <div id="mcExcessQQ" style="width:100%; height:420px;"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>趋势跟踪策略研究（单标的）</h3>
      <div class="muted">
        独立于等权组合与轮动策略。选择一个候选标的，回测常见趋势策略（长/空=长/现金），并与该标的买入持有对比指标与净值。
      </div>
      <div class="row no-print" style="margin-top:8px; align-items:end;">
        <div>
          <label>标的</label>
          <select id="trendCode" style="min-width:180px;"></select>
        </div>
        <div>
          <label>策略</label>
          <select id="trendStrategy" style="min-width:220px;">
            <option value="ma_filter" selected>均线过滤（收盘 &gt; SMA）</option>
            <option value="ema_filter">EMA过滤（收盘 &gt; EMA）</option>
            <option value="ma_cross">双均线交叉（SMA_fast &gt; SMA_slow）</option>
            <option value="donchian">唐奇安突破（入场/退出）</option>
            <option value="tsmom">时间序列动量（lookback收益&gt;0）</option>
            <option value="linreg_slope">回归斜率趋势（log价斜率&gt;0）</option>
            <option value="bias">乖离率趋势（BIAS 上升跟随：入场/过热止盈/过冷止损）</option>
          </select>
        </div>
        <div id="trendSmaBox">
          <label>SMA窗口</label>
          <input id="trendSmaWin" value="200" />
        </div>
        <div id="trendCrossBox">
          <label>快/慢均线</label>
          <div class="row" style="gap:8px; align-items:end;">
            <input id="trendFastWin" value="50" style="min-width:120px" />
            <input id="trendSlowWin" value="200" style="min-width:120px" />
          </div>
        </div>
        <div id="trendDonchianBox">
          <label>入场/退出窗口</label>
          <div class="row" style="gap:8px; align-items:end;">
            <input id="trendDonEntry" value="20" style="min-width:120px" />
            <input id="trendDonExit" value="10" style="min-width:120px" />
          </div>
        </div>
        <div id="trendMomBox">
          <label>动量回看(交易日)</label>
          <input id="trendMomLb" value="252" />
        </div>
        <div id="trendBiasBox">
          <label>乖离率参数</label>
          <div class="row" style="gap:8px; align-items:end;">
            <input id="trendBiasMA" value="20" style="min-width:90px" placeholder="EMA窗口" title="EMA(C,N)窗口(交易日)，用于 BIAS=(LN(C)-LN(EMA))*100" />
            <input id="trendBiasEntry" value="2" style="min-width:80px" placeholder="入场%" title="入场阈值(%)：BIAS > entry" />
            <input id="trendBiasHot" value="10" style="min-width:80px" placeholder="过热%" title="过热止盈阈值(%)：BIAS >= hot" />
            <input id="trendBiasCold" value="-2" style="min-width:80px" placeholder="过冷%" title="过冷止损阈值(%)：BIAS <= cold" />
            <select id="trendBiasPosMode" style="min-width:120px" title="仓位管理模式">
              <option value="binary" selected>0/1仓位</option>
              <option value="continuous">动态仓位</option>
            </select>
          </div>
        </div>
        <div>
          <label>交易成本(bps)</label>
          <input id="trendCost" value="0" />
        </div>
        <button id="runTrend">运行（趋势跟踪）</button>
      </div>
      <div class="two" style="grid-template-columns: 1fr 1fr; margin-top:10px;">
        <div>
          <div class="muted">净值对比（策略 vs 买入持有）</div>
          <div id="trendChart" style="width:100%; height:420px;"></div>
        </div>
        <div>
          <div class="muted">回撤对比</div>
          <div id="trendDD" style="width:100%; height:420px;"></div>
        </div>
      </div>
      <table id="trendMetrics" style="margin-top:8px;"></table>
    </div>

    <div class="panel msg" id="msg"></div>

    <div id="metricModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.45);">
      <div style="max-width:760px; margin:8vh auto; background:#fff; border-radius:10px; padding:16px 16px 12px 16px; box-shadow:0 10px 30px rgba(0,0,0,0.25);">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
          <div>
            <div id="metricModalTitle" style="font-weight:600; font-size:16px;"></div>
            <div id="metricModalSub" class="muted" style="margin-top:4px;"></div>
          </div>
          <button id="metricModalClose" style="padding:6px 10px;">关闭</button>
        </div>
        <div id="metricModalBody" style="margin-top:10px; line-height:1.55;"></div>
      </div>
    </div>

    <script>
      const api = (path, opts) => fetch(`/api${path}`, { headers: { "Content-Type": "application/json" }, ...opts });
      const $ = (id) => document.getElementById(id);
      const esc = (s) => String(s == null ? "" : s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");

      // Surface JS errors on the page (helps debug when charts fail to render due to a runtime exception).
      window.addEventListener("error", (e) => {
        try {
          const msg = `JS错误: ${e.message || e.error || "unknown"}\\n${e.filename || ""}:${e.lineno || ""}:${e.colno || ""}`;
          if ($("msg")) $("msg").textContent = msg;
        } catch { /* ignore */ }
      });
      window.addEventListener("unhandledrejection", (e) => {
        try {
          const msg = `Promise错误: ${String(e.reason || "unknown")}`;
          if ($("msg")) $("msg").textContent = msg;
        } catch { /* ignore */ }
      });

      function fmtPct(x) {
        if (x == null || Number.isNaN(x)) return "-";
        return (x * 100).toFixed(2) + "%";
      }
      function fmtNum(x) {
        if (x == null || Number.isNaN(x)) return "-";
        return Number(x).toFixed(4);
      }

      let pool = [];
      const selected = new Set();
      const ADJUST_USED = "hfq"; // baseline research currently uses hfq only
      const ANN_FACTOR = 252;

      const metricHelp = {
        benchmark_code: {
          title: "基准标的（benchmark_code）",
          sub: "用于信息比率（IR）的对比基准。",
          body: `
            <div><b>含义</b>：把“等权组合”的日收益与基准标的的日收益相减，得到主动收益（active return）。</div>
            <div style="margin-top:8px"><b>口径</b>：当前页面所有收益与指标均使用 <b>${ADJUST_USED}</b>（后复权）价格序列。</div>
          `,
        },
        rebalance: {
          title: "等权再平衡周期（rebalance）",
          sub: "决定等权组合的权重何时重置为等权。",
          body: `
            <div><b>含义</b>：等权组合在每个再平衡点将权重重置为等权（每个标的权重相同）。</div>
            <div style="margin-top:8px"><b>实现</b>：日度=每天重置；周/月/季/年=在对应周期边界重置；不平衡=等权买入持有（不再重置）。</div>
          `,
        },
        risk_free_rate: {
          title: "无风险收益率（risk_free_rate）",
          sub: "用于夏普比率与索诺提比率（年化）。默认 2.5%（长期中国0-1年国债）。",
          body: `
            <div><b>含义</b>：在风险调整收益指标中，从组合收益中扣除无风险收益。</div>
            <div style="margin-top:8px"><b>换算</b>：年化 rf 按日频近似换算为 rf/252。</div>
          `,
        },
        cumulative_return: {
          title: "累积收益率（cumulative_return）",
          sub: "区间内的总收益。",
          body: `
            <div><b>定义</b>：\\(R_{cum} = \\frac{NAV_T}{NAV_0} - 1\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：这里 NAV 为等权组合净值（起点=1）。</div>
          `,
        },
        annualized_return: {
          title: "年化收益率（annualized_return）",
          sub: "把区间收益折算为年化复利。",
          body: `
            <div><b>定义</b>：\\(R_{ann} = (\\frac{NAV_T}{NAV_0})^{\\frac{${ANN_FACTOR}}{N}} - 1\\)，其中 N 为区间交易日数（约）。</div>
            <div style="margin-top:8px"><b>注意</b>：这是基于交易日频率的折算，不等同于自然日年化。</div>
          `,
        },
        annualized_volatility: {
          title: "年化波动率（annualized_volatility）",
          sub: "日收益率标准差的年化。",
          body: `
            <div><b>定义</b>：\\(\\sigma_{ann} = \\sigma_{daily} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：\\(\\sigma_{daily}\\) 为日收益率的样本标准差（ddof=1）。</div>
          `,
        },
        max_drawdown: {
          title: "最大回撤（max_drawdown）",
          sub: "净值从历史峰值到后续低点的最大跌幅。",
          body: `
            <div><b>定义</b>：\\(MDD = \\min_t( \\frac{NAV_t}{\\max_{s\\le t} NAV_s} - 1 )\\)。</div>
            <div style="margin-top:8px"><b>取值</b>：通常为负数，越接近 0 越好。</div>
          `,
        },
        max_drawdown_recovery_days: {
          title: "最大回撤修复时长（max_drawdown_recovery_days）",
          sub: "最大回撤发生后，从峰值开始到再次创出新高的最长天数（用自然日计）。",
          body: `
            <div><b>定义</b>：沿时间轴跟踪“最新峰值日期”，在回撤区间内计算 (当前日期 - 峰值日期) 的最大值。</div>
            <div style="margin-top:8px"><b>说明</b>：这里按日期差（自然日）计算，非交易日数。</div>
          `,
        },
        sharpe_ratio: {
          title: "夏普比率（sharpe_ratio）",
          sub: "单位总波动的超额收益（相对无风险）。",
          body: `
            <div><b>定义（年化）</b>：\\(Sharpe = \\frac{\\mathbb{E}[r - rf/${ANN_FACTOR}]}{\\sigma(r - rf/${ANN_FACTOR})} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：r 为日收益率，rf 为年化无风险收益率。</div>
          `,
        },
        calmar_ratio: {
          title: "卡玛比率（calmar_ratio）",
          sub: "年化收益相对最大回撤（更偏向回撤风险）。",
          body: `
            <div><b>定义</b>：\\(Calmar = \\frac{R_{ann}}{|MDD|}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：当 MDD=0 时该值无意义。</div>
          `,
        },
        sortino_ratio: {
          title: "索诺提比率（sortino_ratio）",
          sub: "只用下行波动衡量风险的超额收益。",
          body: `
            <div><b>定义（年化）</b>：\\(Sortino = \\frac{\\mathbb{E}[r - rf/${ANN_FACTOR}]}{\\sigma(\\min(r - rf/${ANN_FACTOR}, 0))} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：只统计负的（下行）超额收益作为“下行风险”。</div>
          `,
        },
        information_ratio: {
          title: "信息比率（information_ratio）",
          sub: "单位跟踪误差的主动收益（相对基准）。",
          body: `
            <div><b>定义（年化）</b>：\\(IR = \\frac{\\mathbb{E}[r_p - r_b]}{\\sigma(r_p - r_b)} \\cdot \\sqrt{${ANN_FACTOR}}\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：\\(r_p\\) 为组合日收益，\\(r_b\\) 为基准标的日收益。</div>
          `,
        },
        ulcer_index: {
          title: "溃疡指标（ulcer_index, UI）",
          sub: "衡量“持有体验”：惩罚回撤的深度与持续时间（只看水下部分）。",
          body: `
            <div><b>步骤</b>：先算回撤 \\(DD_t = \\frac{NAV_t}{\\max_{s\\le t} NAV_s} - 1\\)（≤0）。</div>
            <div style="margin-top:8px"><b>定义</b>：\\(UI = \\sqrt{\\frac{1}{T}\\sum (100\\cdot \\max(0,-DD_t))^2}\\)。</div>
            <div style="margin-top:8px"><b>单位</b>：当前实现返回“百分比点”的 RMS（例如 5.0 表示平均水下幅度约 5% 的 RMS）。</div>
          `,
        },
        ulcer_performance_index: {
          title: "溃疡绩效指标（ulcer_performance_index, UPI）",
          sub: "类似“收益/痛苦”：用超额年化收益除以 Ulcer Index。",
          body: `
            <div><b>定义</b>：\\(UPI = \\frac{R_{ann} - rf}{UI_{dec}}\\)，其中 \\(UI_{dec}=UI/100\\)。</div>
            <div style="margin-top:8px"><b>说明</b>：rf 为年化无风险收益率；UI 越小、收益越高，UPI 越大。</div>
          `,
        },
        holding_weekly_win_rate: {
          title: "周度绝对胜率（holding_weekly_win_rate）",
          sub: "等权组合按周统计：周收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_week>0) / count(r_week)。</div>`,
        },
        holding_weekly_payoff_ratio: {
          title: "周度绝对赔率（holding_weekly_payoff_ratio）",
          sub: "等权组合按周统计：平均盈利周收益 / 平均亏损周收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_weekly_kelly_fraction: {
          title: "周度绝对凯利比（holding_weekly_kelly_fraction）",
          sub: "基于周度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b，其中 p=胜率，b=赔率。</div>`,
        },
        holding_monthly_win_rate: {
          title: "月度绝对胜率（holding_monthly_win_rate）",
          sub: "等权组合按月统计：月收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_month>0) / count(r_month)。</div>`,
        },
        holding_monthly_payoff_ratio: {
          title: "月度绝对赔率（holding_monthly_payoff_ratio）",
          sub: "等权组合按月统计：平均盈利月收益 / 平均亏损月收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_monthly_kelly_fraction: {
          title: "月度绝对凯利比（holding_monthly_kelly_fraction）",
          sub: "基于月度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。</div>`,
        },
        holding_quarterly_win_rate: {
          title: "季度绝对胜率（holding_quarterly_win_rate）",
          sub: "等权组合按季统计：季度收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_q>0) / count(r_q)。</div>`,
        },
        holding_quarterly_payoff_ratio: {
          title: "季度绝对赔率（holding_quarterly_payoff_ratio）",
          sub: "等权组合按季统计：平均盈利季度收益 / 平均亏损季度收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_quarterly_kelly_fraction: {
          title: "季度绝对凯利比（holding_quarterly_kelly_fraction）",
          sub: "基于季度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。</div>`,
        },
        holding_yearly_win_rate: {
          title: "年度绝对胜率（holding_yearly_win_rate）",
          sub: "等权组合按年统计：年度收益>0 的比例。",
          body: `<div><b>计算</b>：胜率 = count(r_y>0) / count(r_y)。</div>`,
        },
        holding_yearly_payoff_ratio: {
          title: "年度绝对赔率（holding_yearly_payoff_ratio）",
          sub: "等权组合按年统计：平均盈利年度收益 / 平均亏损年度收益(绝对值)。",
          body: `<div><b>计算</b>：payoff = mean(r|r>0) / abs(mean(r|r<0))（算术平均）。</div>`,
        },
        holding_yearly_kelly_fraction: {
          title: "年度绝对凯利比（holding_yearly_kelly_fraction）",
          sub: "基于年度绝对胜率与赔率的二项近似。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。</div>`,
        },
        ew_return_contrib: {
          title: "收益贡献（等权组合）",
          sub: "把组合的总收益按标的拆分的归因结果。",
          body: `<div><b>方法</b>：按日用权重×log(1+r) 做收益归因，并按总收益缩放使各标的贡献之和等于组合总收益。</div><div style="margin-top:8px"><b>说明</b>：这是一个“可加”的近似归因方法，便于比较各标的对长期收益的贡献大小。</div>`,
        },
        ew_risk_contrib: {
          title: "风险贡献（等权组合）",
          sub: "把组合波动风险按标的拆分（方差贡献占比）。",
          body: `<div><b>方法</b>：用收益协方差矩阵 Σ 与平均权重 w̄，计算方差贡献：RC_i = w̄_i·(Σw̄)_i / (w̄'Σw̄)。</div>`,
        },
        rot_return_contrib: {
          title: "收益贡献（轮动策略）",
          sub: "把轮动策略的总收益按标的拆分的归因结果。",
          body: `<div><b>方法</b>：同等权组合，按日权重做 log 归因并缩放到总收益。</div><div style="margin-top:8px"><b>注意</b>：该贡献基于持仓收益（不把交易成本按标的拆分）。策略净值展示为扣成本后的结果。</div>`,
        },
        rot_risk_contrib: {
          title: "风险贡献（轮动策略）",
          sub: "轮动策略风险按标的拆分（方差贡献占比）。",
          body: `<div><b>方法</b>：与等权相同，使用全区间收益协方差与平均权重计算方差贡献占比。</div>`,
        },
        param_rot_rebalance: {
          title: "调仓频率（rebalance）",
          sub: "每隔多长时间重新选择 TopK 并调仓。",
          body: `
            <div><b>含义</b>：在日/周/月/季/年周期末根据动量重新排名，下一交易日开始按新持仓运行。</div>
            <div style="margin-top:8px"><b>用途</b>：控制换手与信号稳定性。频率越高换手越大，越低反应越慢。</div>
            <div style="margin-top:8px"><b>范围</b>：daily / weekly / monthly / quarterly / yearly。</div>
            <div style="margin-top:8px"><b>示例</b>：weekly 表示每周调仓；daily 表示每日调仓。</div>
          `,
        },
        param_rot_topk: {
          title: "TopK",
          sub: "每次调仓持有动量排名前 K 的标的（等权）。",
          body: `
            <div><b>含义</b>：K=1 表示单标的轮动；K>1 表示持有多标的等权组合。</div>
            <div style="margin-top:8px"><b>用途</b>：K 越大分散越强、波动更低，但动量暴露更弱。</div>
            <div style="margin-top:8px"><b>范围</b>：整数 ≥ 1，且不应超过可用标的数量。</div>
            <div style="margin-top:8px"><b>示例</b>：TopK=2 在 4 个标的池里会持有前 2 名等权。</div>
          `,
        },
        param_rot_lookback: {
          title: "动量回看（lookback_days）",
          sub: "动量收益计算的回看窗口（交易日）。",
          body: `
            <div><b>含义</b>：动量分数 = 过去回看窗口内的累计收益（可配合 skip_days 跳过最近段）。</div>
            <div style="margin-top:8px"><b>用途</b>：窗口越长更偏“长期趋势”，越短更偏“短期动量”。</div>
            <div style="margin-top:8px"><b>范围</b>：整数 ≥ 1。常用：63(3M)、126(6M)、252(12M)。</div>
            <div style="margin-top:8px"><b>示例</b>：252 表示约 1 年动量。</div>
          `,
        },
        param_rot_skip: {
          title: "跳过最近（skip_days）",
          sub: "计算动量时跳过最近 N 个交易日（常用于 12-1）。",
          body: `
            <div><b>含义</b>：动量分数用 \\(close_{t-skip}/close_{t-skip-lookback} - 1\\)。</div>
            <div style="margin-top:8px"><b>用途</b>：降低短期反转/噪声影响。</div>
            <div style="margin-top:8px"><b>范围</b>：整数 ≥ 0。常用：21（约 1 个月）。</div>
            <div style="margin-top:8px"><b>示例</b>：lookback=252 且 skip=21 即 12-1 动量。</div>
          `,
        },
        param_rot_cost: {
          title: "交易成本（cost_bps）",
          sub: "按换手率估算的成本（bps）。",
          body: `
            <div><b>含义</b>：每日换手率 \\(turnover=\\frac{1}{2}\\sum |w_t-w_{t-1}|\\)，成本=turnover×(bps/10000)，从当日收益中扣减。</div>
            <div style="margin-top:8px"><b>用途</b>：让回测更接近实盘，抑制过度换手策略。</div>
            <div style="margin-top:8px"><b>范围</b>：≥0。常见取值：2~10 bps（视品种/滑点假设）。</div>
            <div style="margin-top:8px"><b>示例</b>：cost_bps=5 表示每 100% 换手扣 0.05%。</div>
          `,
        },
        param_rot_riskoff: {
          title: "动量阈值开关（risk_off）",
          sub: "当动量不达标时不买入风险资产（进入空仓/现金）。",
          body: `
            <div><b>含义</b>：若当期最优动量 ≤ 动量阈值，则本期不买风险资产，进入<b>空仓(现金)</b>。</div>
            <div style="margin-top:8px"><b>用途</b>：当市场/标的动量不足时降低暴露，减少“下行趋势里硬上车”。</div>
            <div style="margin-top:8px"><b>范围</b>：true/false。</div>
            <div style="margin-top:8px"><b>示例</b>：开启 risk_off，floor=0（动量≤0 就空仓）。</div>
          `,
        },
        param_rot_floor: {
          title: "动量阈值（momentum_floor）",
          sub: "动量阈值触发条件（用动量分数判断）。",
          body: `
            <div><b>含义</b>：若最佳动量分数 ≤ 阈值，则本期进入<b>空仓(现金)</b>。</div>
            <div style="margin-top:8px"><b>用途</b>：控制“什么时候认为风险资产不值得持有/不应买入”。</div>
            <div style="margin-top:8px"><b>范围</b>：实数。常用：0（动量为负就避险）。</div>
            <div style="margin-top:8px"><b>重要</b>：需开启“动量阈值开关”。</div>
            <div style="margin-top:8px"><b>示例</b>：floor=0 表示只在动量为正时才持有风险资产。</div>
          `,
        },
        param_rot_score_method: {
          title: "打分方式（score_method）",
          sub: "决定“动量排序”用什么指标：偏向涨得猛 or 涨得稳。",
          body: `
            <div><b>raw_mom</b>：纯动量，score = close(t-skip)/close(t-skip-lookback) - 1。</div>
            <div style="margin-top:8px"><b>return_over_vol</b>：过去收益 / 过去波动率（年化）。偏向“涨得稳”。</div>
            <div style="margin-top:8px"><b>sharpe_mom</b>：看过去窗口内的 Sharpe（用 rf 作为无风险）。</div>
            <div style="margin-top:8px"><b>sortino_mom</b>：看过去窗口内的 Sortino（只惩罚下行波动）。</div>
            <div style="margin-top:8px"><b>说明</b>：这些打分只影响“排序与选标”，不改变成交价格口径/回测结算逻辑。</div>
          `,
        },
        param_rot_trend: {
          title: "趋势过滤（trend_filter）",
          sub: "用趋势条件决定是否允许进入风险资产（事前风控）。",
          body: `
            <div><b>逐标的</b>：对每个候选标的判断 close(qfq) 是否在 SMA(window) 之上；不满足的标的不会被买入。</div>
            <div style="margin-top:8px"><b>全市场(候选均值)</b>：对“候选池均值价格”做同样判断；若不满足，则本期不买风险资产（进入空仓/现金）。</div>
            <div style="margin-top:8px"><b>目的</b>：在下行趋势中减少错误入场，降低大回撤。</div>
          `,
        },
        param_rot_rsi: {
          title: "RSI过滤（rsi_filter）",
          sub: "用超买超卖指标决定是否允许买入（事前风控）。",
          body: `
            <div><b>含义</b>：RSI 是动量强弱指标（0~100）。</div>
            <div style="margin-top:8px"><b>默认</b>：只屏蔽超买（RSI&gt;70），避免追高；超卖是否屏蔽可扩展。</div>
            <div style="margin-top:8px"><b>目的</b>：减少在极端情绪位置买入导致的回撤风险。</div>
          `,
        },
        param_rot_vol: {
          title: "波动率监控（vol_monitor）",
          sub: "用历史波动率决定买入仓位（事前仓位控制）。",
          body: `
            <div><b>逻辑</b>：对每个买入标的计算年化实现波动率 vol；若 vol&gt;target，则仓位按 target/vol 比例缩小（剩余留现金）。</div>
            <div style="margin-top:8px"><b>硬阈值</b>：若 vol&gt;max，则该标的不买；如果全部都不买，则进入空仓/现金。</div>
            <div style="margin-top:8px"><b>目的</b>：在高波动阶段降低暴露，事前控制回撤。</div>
          `,
        },
        param_rot_chop: {
          title: "震荡过滤（chop_filter）",
          sub: "用 ER / ADX 识别震荡/盘整并过滤标的。",
          body: `
            <div><b>定义</b>：ER = |P_t-P_{t-n}| / Σ|ΔP|，接近 0 表示来回震荡，接近 1 表示更单边趋势。</div>
            <div style="margin-top:8px"><b>规则</b>：ER &lt; 阈值 ⇒ 认为震荡 ⇒ 本期不买该标的（从候选里剔除）。</div>
            <div style="margin-top:8px"><b>ADX</b>：趋势强度指标（0~100）。一般 ADX 越低越偏震荡；可用阈值如 20。</div>
            <div style="margin-top:8px"><b>规则</b>：ADX &lt; 阈值 ⇒ 认为震荡 ⇒ 本期不买该标的（从候选里剔除）。</div>
            <div style="margin-top:8px"><b>口径</b>：使用 <b>qfq（前复权）</b> close 序列计算。</div>
          `,
        },
        rot_cum: {
          title: "策略累积收益",
          sub: "轮动策略净值（none）在回测区间的总收益。",
          body: `<div><b>计算</b>：NAV_T/NAV_0 - 1（已扣换手成本）。</div><div style="margin-top:8px"><b>口径</b>：轮动净值使用 none（不复权）。</div>`,
        },
        rot_ann: {
          title: "策略年化收益",
          sub: "把轮动净值区间收益折算为年化复利。",
          body: `<div><b>计算</b>：与基准分析一致，按交易日近似年化。</div>`,
        },
        rot_vol: {
          title: "策略年化波动",
          sub: "轮动策略日收益波动的年化。",
          body: `<div><b>计算</b>：σ_daily×√252。</div>`,
        },
        rot_mdd: {
          title: "策略最大回撤",
          sub: "轮动策略净值从峰值到低点的最大跌幅。",
          body: `<div><b>计算</b>：min(NAV/peak-1)。</div>`,
        },
        rot_sharpe: {
          title: "策略夏普",
          sub: "基于日收益与无风险收益率的风险调整收益（年化）。",
          body: `<div><b>计算</b>：Sharpe = mean(r-rf/252)/std(r-rf/252)×√252。</div>`,
        },
        rot_sortino: {
          title: "策略索诺提",
          sub: "只用下行波动衡量风险的风险调整收益（年化）。",
          body: `<div><b>计算</b>：Sortino = mean(r-rf/252)/std(min(r-rf/252,0))×√252。</div>`,
        },
        rot_ui: {
          title: "策略溃疡指标(UI)",
          sub: "衡量持有体验：惩罚回撤深度与持续时间。",
          body: `<div><b>计算</b>：回撤水下百分比的 RMS（与基准分析一致）。</div>`,
        },
        rot_upi: {
          title: "策略溃疡绩效(UPI)",
          sub: "收益/痛苦：用(年化收益-rf)除以 UI。",
          body: `<div><b>计算</b>：UPI=(R_ann-rf)/(UI/100)。</div>`,
        },
        rot_turnover: {
          title: "平均日换手",
          sub: "反映交易频率与成本敏感度。",
          body: `<div><b>计算</b>：turnover=0.5×Σ|w_t-w_{t-1}| 的日均值。</div>`,
        },
        rot_excess_cum: {
          title: "超额累积收益",
          sub: "轮动(none,net) 相对 等权(hfq,同频再平衡) 的总超额。",
          body: `<div><b>计算</b>：active_ret = r_rot(none,net) - r_ew(hfq,rebal)；EXCESS 为其累积净值。</div>`,
        },
        rot_excess_ann: {
          title: "超额年化收益",
          sub: "超额净值的年化。",
          body: `<div><b>计算</b>：对 EXCESS 序列做年化收益折算。</div>`,
        },
        rot_ir: {
          title: "超额信息比率(近似)",
          sub: "用主动收益序列的 Sharpe 形式近似信息比率。",
          body: `<div><b>计算</b>：IR ≈ mean(active)/std(active)×√252。</div>`,
        },
        rot_wp_win: {
          title: "胜率",
          sub: "按调仓周期统计，策略超额收益>0 的比例。",
          body: `<div><b>计算</b>：胜率=胜场数/期数；每期超额=期收益(轮动)-期收益(等权)。</div>`,
        },
        rot_wp_payoff: {
          title: "赔率(盈/亏)",
          sub: "平均盈利超额 / 平均亏损超额(绝对值)。",
          body: `<div><b>计算</b>：payoff=mean(excess|>0)/abs(mean(excess|<0))。</div>`,
        },
        rot_wp_avg_win: {
          title: "平均盈利(超额)",
          sub: "所有胜出期（超额>0）的超额收益均值。",
          body: `<div><b>计算</b>：mean(excess_return | excess_return>0)。</div>`,
        },
        rot_wp_avg_loss: {
          title: "平均亏损(超额)",
          sub: "所有亏损期（超额<0）的超额收益均值（为负数）。",
          body: `<div><b>计算</b>：mean(excess_return | excess_return<0)。展示为负值。</div>`,
        },
        rot_wp_kelly: {
          title: "凯利比(近似)",
          sub: "基于胜率 p 与赔率 b 的二项近似最优仓位比例。",
          body: `<div><b>计算</b>：f* = p - (1-p)/b。仅作参考，实盘通常会折扣（如 0.5×凯利）。</div>`,
        },
        rot_abs_win: {
          title: "绝对胜率",
          sub: "按调仓周期统计，策略每期收益>0 的比例（不与基准比较）。",
          body: `<div><b>计算</b>：胜率=期收益(轮动)>0 的期数 / 总期数。</div>`,
        },
        rot_abs_payoff: {
          title: "绝对赔率(盈/亏)",
          sub: "策略自身：平均盈利期收益 / 平均亏损期收益(绝对值)。",
          body: `<div><b>计算</b>：payoff_abs=mean(r|r>0)/abs(mean(r|r<0))。</div>`,
        },
        rot_abs_kelly: {
          title: "绝对凯利比(近似)",
          sub: "基于绝对胜率与绝对赔率的二项近似最优仓位比例。",
          body: `<div><b>计算</b>：f*_abs = p_abs - (1-p_abs)/b_abs。</div>`,
        },
        mc_col_metric: {
          title: "指标",
          sub: "蒙特卡洛模拟输出的指标名称。",
          body: `<div><b>说明</b>：每行对应一个绩效指标（如累积收益、年化收益、最大回撤等）。</div>`,
        },
        mc_col_observed: {
          title: "Observed",
          sub: "原始样本（真实历史序列）计算出的指标值。",
          body: `<div><b>说明</b>：用回测区间内的原始日收益序列直接计算得到的“观测值”。</div>`,
        },
        mc_col_mean: {
          title: "Mean",
          sub: "蒙特卡洛模拟得到的指标均值。",
          body: `<div><b>说明</b>：对多次重采样路径分别计算指标后取平均。</div>`,
        },
        mc_col_p05: {
          title: "P05",
          sub: "指标分布的 5% 分位数。",
          body: `<div><b>说明</b>：有约 5% 的模拟结果低于该值（经验分位数）。</div>`,
        },
        mc_col_p50: {
          title: "P50",
          sub: "指标分布的 50% 分位数（中位数）。",
          body: `<div><b>说明</b>：把所有模拟结果从小到大排序后居中的值。</div>`,
        },
        mc_col_p95: {
          title: "P95",
          sub: "指标分布的 95% 分位数。",
          body: `<div><b>说明</b>：有约 95% 的模拟结果低于该值。</div>`,
        },
        mc_col_p_le_0: {
          title: "P(r≤0)",
          sub: "该指标在模拟下“≤0”的比例（经验概率）。",
          body: `<div><b>说明</b>：统计模拟样本里指标 ≤ 0 的占比。例如对累积收益/年化收益，这可近似理解为“亏损概率”。</div>`,
        },
      };

      function renderMcTable(elId, mc) {
        const el = $(elId);
        const header =
          `<tr>
            <th>指标 <button class="helpBtn" data-metric="mc_col_metric" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>Observed <button class="helpBtn" data-metric="mc_col_observed" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>Mean <button class="helpBtn" data-metric="mc_col_mean" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P05 <button class="helpBtn" data-metric="mc_col_p05" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P50 <button class="helpBtn" data-metric="mc_col_p50" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P95 <button class="helpBtn" data-metric="mc_col_p95" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
            <th>P(r≤0) <button class="helpBtn" data-metric="mc_col_p_le_0" title="查看说明" style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button></th>
          </tr>`;
        if (!mc || !mc.metrics) {
          el.innerHTML = header;
          return;
        }
        const order = ["cumulative_return", "annualized_return", "annualized_volatility", "max_drawdown", "sharpe_ratio"];
        const rows = order.filter(k => mc.metrics[k]).map(k => ({ k, v: mc.metrics[k] }));
        const label = {
          cumulative_return: "累积收益",
          annualized_return: "年化收益",
          annualized_volatility: "年化波动",
          max_drawdown: "最大回撤",
          sharpe_ratio: "夏普",
        };
        const fmt = (k, x) => {
          if (x == null || Number.isNaN(x)) return "-";
          if (k.includes("drawdown")) return fmtPct(Number(x));
          if (k.includes("volatility")) return fmtPct(Number(x));
          if (k.includes("return")) return fmtPct(Number(x));
          return Number(x).toFixed(4);
        };
        el.innerHTML =
          header +
          rows.map(({k, v}) => `<tr><td>${label[k] || k}</td><td>${fmt(k, v.observed)}</td><td>${fmt(k, v.mean)}</td><td>${fmt(k, v.p05)}</td><td>${fmt(k, v.p50)}</td><td>${fmt(k, v.p95)}</td><td>${(v.p_value_le_0==null||Number.isNaN(v.p_value_le_0))? "-" : (Number(v.p_value_le_0)*100).toFixed(2)+"%"}</td></tr>`).join("");
      }

      function plotMcHist(divId, mc, metricKey) {
        const el = $(divId);
        if (!mc || !mc.metrics || !mc.metrics[metricKey] || !mc.metrics[metricKey].hist) {
          el.innerHTML = "<div class='muted'>无直方图数据</div>";
          return;
        }
        const h = mc.metrics[metricKey].hist;
        const edges = h.bin_edges || [];
        const counts = h.counts || [];
        if (edges.length < 2 || counts.length < 1) {
          el.innerHTML = "<div class='muted'>无直方图数据</div>";
          return;
        }
        const x = [];
        for (let i = 0; i < counts.length; i++) x.push((edges[i] + edges[i + 1]) / 2);
        const isPct = metricKey.includes("return") || metricKey.includes("volatility") || metricKey.includes("drawdown");
        const fmtX = isPct ? ".0%" : ".4f";
        Plotly.newPlot(
          divId,
          [{
            x,
            y: counts,
            type: "bar",
            marker: { color: "#4c78a8" },
            hovertemplate: isPct ? "%{x:.2%}<br>count=%{y}<extra></extra>" : "%{x:.4f}<br>count=%{y}<extra></extra>",
          }],
          {
            margin: { t: 20 },
            xaxis: { tickformat: fmtX, title: metricKey },
            yaxis: { title: "count" },
            annotations: [
              {
                xref: "paper",
                yref: "paper",
                x: 0.01,
                y: 0.98,
                showarrow: false,
                text: `under=${h.underflow||0}, over=${h.overflow||0}`,
                font: { size: 12, color: "#666" },
              },
            ],
          },
          { responsive: true }
        );
      }

      function renderFit(prefix, mc, metricKey) {
        const fitTable = $(`mc${prefix}FitTable`);
        const distSel = $(`mc${prefix}Dist`);
        const qqDiv = `mc${prefix}QQ`;
        if (!fitTable || !distSel) return;
        if (!mc || !mc.metrics || !mc.metrics[metricKey] || !mc.metrics[metricKey].fit) {
          fitTable.innerHTML = "<tr><th>分布</th><th>BIC</th><th>AIC</th><th>KS p</th><th>AD</th></tr>";
          distSel.innerHTML = "";
          $(qqDiv).innerHTML = "<div class='muted'>无拟合数据</div>";
          return;
        }
        const fit = mc.metrics[metricKey].fit;
        const cands = fit.candidates || [];
        const rows = [];
        for (const d of cands) {
          const r = (fit.dists && fit.dists[d]) ? fit.dists[d] : null;
          if (!r || !r.ok) continue;
          rows.push({ d, bic: r.bic, aic: r.aic, ksp: r.ks ? r.ks.p_value : null, ad: r.ad ? r.ad.stat : null });
        }
        rows.sort((a,b) => Number(a.bic) - Number(b.bic));
        fitTable.innerHTML =
          "<tr><th>分布</th><th>BIC</th><th>AIC</th><th>KS p</th><th>AD</th></tr>" +
          rows.map(r => `<tr><td>${r.d}</td><td>${Number(r.bic).toFixed(2)}</td><td>${Number(r.aic).toFixed(2)}</td><td>${r.ksp==null? "-" : Number(r.ksp).toFixed(4)}</td><td>${r.ad==null? "-" : Number(r.ad).toFixed(2)}</td></tr>`).join("");

        // dist selector
        distSel.innerHTML = "";
        for (const r of rows) {
          const opt = document.createElement("option");
          opt.value = r.d;
          opt.textContent = r.d + (r.d === fit.best_by_bic ? "（BIC最优）" : "");
          distSel.appendChild(opt);
        }
        if (fit.best_by_bic) distSel.value = fit.best_by_bic;

        const plotQQ = () => {
          const d = distSel.value;
          const qq = fit.qq && fit.qq[d] ? fit.qq[d] : null;
          const el = $(qqDiv);
          if (!qq || !qq.emp || qq.emp.length === 0) {
            el.innerHTML = "<div class='muted'>无 Q-Q 数据</div>";
            return;
          }
          const x = qq.theory;
          const y = qq.emp;
          const minv = Math.min(...x, ...y);
          const maxv = Math.max(...x, ...y);
          Plotly.newPlot(
            qqDiv,
            [
              { x, y, mode: "markers", type: "scatter", name: "Q-Q", marker: { size: 6, color: "#4c78a8" }, hovertemplate: "theory=%{x:.4f}<br>emp=%{y:.4f}<extra></extra>" },
              { x: [minv, maxv], y: [minv, maxv], mode: "lines", name: "y=x", line: { dash: "dot", color: "#999" }, hoverinfo: "skip" },
            ],
            { margin: { t: 20 }, xaxis: { title: "theoretical quantile" }, yaxis: { title: "empirical quantile" } },
            { responsive: true }
          );
        };
        distSel.onchange = plotQQ;
        plotQQ();
      }

      let lastMcEw = null;
      let lastMcRot = null;
      let lastMcExcess = null;
      let lastBaseline = null; // latest baseline analysis payload (for client-side correlation re-slicing)
      let corrRangeKey = "all";

      function openMetricModal(key, metrics) {
        const h = metricHelp[key] || { title: key, sub: "", body: "<div class='muted'>暂无说明。</div>" };
        $("metricModalTitle").textContent = h.title;
        $("metricModalSub").textContent = h.sub || "";
        $("metricModalBody").innerHTML = h.body || "";
        $("metricModal").style.display = "block";
      }

      function closeMetricModal() {
        $("metricModal").style.display = "none";
      }

      function exportPdfReport() {
        // Best-effort resize Plotly charts before printing.
        try {
          const ids = [
            "chart", "rollingReturns", "rollingDD",
            "corrHeatmap",
            "ewCalHeatmap", "ewCalRollingChart",
            "rotCalHeatmap", "rotCalRollingChart",
            "trendChart", "trendDD",
            "rotChart", "rotDDCompare", "rotExcessChart", "rot40dDiffChart",
            "rotRollingCombo", "rotExcessRollingCombo",
            "mcEwHist", "mcEwQQ",
            "mcRotHist", "mcRotQQ",
            "mcExcessHist", "mcExcessQQ",
          ];
          for (const id of ids) {
            const el = $(id);
            if (el && window.Plotly && el.data) {
              try { Plotly.Plots.resize(el); } catch (e) {}
            }
          }
        } catch (e) {}

        const start = ($("start").value || "").trim();
        const end = ($("end").value || "").trim();
        const codes = Array.from(selected).join("-");
        const oldTitle = document.title;
        document.title = `research_${start || "START"}_${end || "END"}_${codes || "codes"}`;
        setTimeout(() => {
          window.print();
          setTimeout(() => { document.title = oldTitle; }, 200);
        }, 150);
      }

      function ymdToNum(s) {
        if (!s || s.length < 8) return null;
        const n = Number(s.slice(0, 8));
        return Number.isFinite(n) ? n : null;
      }

      function numToYmd(n) {
        if (!Number.isFinite(n)) return "";
        return String(Math.trunc(n)).padStart(8, "0");
      }

      function ymdToDate(s) {
        if (!s || s.length < 8) return null;
        const y = Number(s.slice(0, 4));
        const m = Number(s.slice(4, 6));
        const d = Number(s.slice(6, 8));
        if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return null;
        // Use local time; we only care about YYYYMMDD arithmetic.
        return new Date(y, m - 1, d);
      }

      function isoToDate(s) {
        // Expect "YYYY-MM-DD"
        if (!s) return null;
        const dt = new Date(s);
        return Number.isNaN(dt.getTime()) ? null : dt;
      }

      function _shiftMonths(d, months) {
        const x = new Date(d.getTime());
        x.setMonth(x.getMonth() + months);
        return x;
      }

      function _shiftYears(d, years) {
        const x = new Date(d.getTime());
        x.setFullYear(x.getFullYear() + years);
        return x;
      }

      function _corrRangeSpec(key) {
        const m = {
          "1m": { label: "近一月", threshold: (end) => _shiftMonths(end, -1) },
          "3m": { label: "近三月", threshold: (end) => _shiftMonths(end, -3) },
          "6m": { label: "近六月", threshold: (end) => _shiftMonths(end, -6) },
          "1y": { label: "近一年", threshold: (end) => _shiftYears(end, -1) },
          "3y": { label: "近三年", threshold: (end) => _shiftYears(end, -3) },
          "5y": { label: "近五年", threshold: (end) => _shiftYears(end, -5) },
          "10y": { label: "近十年", threshold: (end) => _shiftYears(end, -10) },
          all: { label: "全回测区间", threshold: null },
        };
        return m[key] || m.all;
      }

      function _findStartIndexByThreshold(dates, thresholdDt) {
        if (!thresholdDt) return 0;
        for (let i = 0; i < dates.length; i++) {
          const d = isoToDate(dates[i]);
          if (d && d >= thresholdDt) return i;
        }
        return dates.length; // not found
      }

      function _corrMatrixFromNav({ dates, codes, seriesByCode }, startIdx) {
        const endIdx = dates.length - 1;
        const n = codes.length;
        if (startIdx >= endIdx) {
          return { ok: false, error: "not enough dates" };
        }
        // build daily returns arrays (aligned by index)
        const rets = codes.map((c) => {
          const nav = (seriesByCode[c] || []).slice(startIdx, endIdx + 1);
          const r = [];
          for (let i = 1; i < nav.length; i++) {
            const a = Number(nav[i - 1]);
            const b = Number(nav[i]);
            if (!Number.isFinite(a) || !Number.isFinite(b) || a === 0) r.push(NaN);
            else r.push(b / a - 1.0);
          }
          return r;
        });
        const t = rets[0].length;
        const corr = Array.from({ length: n }, () => Array.from({ length: n }, () => null));

        const corrPair = (x, y) => {
          let nObs = 0;
          let sx = 0, sy = 0;
          for (let i = 0; i < t; i++) {
            const xi = x[i], yi = y[i];
            if (Number.isFinite(xi) && Number.isFinite(yi)) {
              nObs += 1;
              sx += xi;
              sy += yi;
            }
          }
          if (nObs < 3) return { nObs, value: null };
          const mx = sx / nObs;
          const my = sy / nObs;
          let sxx = 0, syy = 0, sxy = 0;
          for (let i = 0; i < t; i++) {
            const xi = x[i], yi = y[i];
            if (Number.isFinite(xi) && Number.isFinite(yi)) {
              const dx = xi - mx;
              const dy = yi - my;
              sxx += dx * dx;
              syy += dy * dy;
              sxy += dx * dy;
            }
          }
          if (sxx <= 0 || syy <= 0) return { nObs, value: null };
          return { nObs, value: sxy / Math.sqrt(sxx * syy) };
        };

        let nObsMin = null;
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (i === j) {
              corr[i][j] = 1.0;
              continue;
            }
            const { nObs, value } = corrPair(rets[i], rets[j]);
            if (nObsMin == null || nObs < nObsMin) nObsMin = nObs;
            corr[i][j] = value;
          }
        }
        return { ok: true, matrix: corr, nObsMin: nObsMin == null ? 0 : nObsMin };
      }

      function refreshCorrelationForRange(key) {
        if (!lastBaseline || !lastBaseline.nav || !lastBaseline.codes) return;
        const codes = lastBaseline.codes;
        const dates = lastBaseline.nav.dates || [];
        const end = isoToDate(dates[dates.length - 1]);
        if (!end) return;
        const spec = _corrRangeSpec(key);
        const threshold = spec.threshold ? spec.threshold(end) : null;
        const startIdx = _findStartIndexByThreshold(dates, threshold);
        if (startIdx >= dates.length) return;

        // Build series-by-code for selected codes only (exclude EW/BENCH series)
        const seriesByCode = {};
        for (const c of codes) seriesByCode[c] = lastBaseline.nav.series[c];

        const calc = _corrMatrixFromNav({ dates, codes, seriesByCode }, startIdx);
        if (!calc.ok) return;

        const startDate = dates[startIdx];
        const endDate = dates[dates.length - 1];
        $("corrRangeTitle").textContent = `· ${spec.label}（${startDate} ~ ${endDate}）`;
        $("corrRangeHint").textContent = `样本数(最小对)：${calc.nObsMin}`;
        plotCorrelation({ method: "pearson", codes, matrix: calc.matrix, n_obs: calc.nObsMin });
      }

      function updateCorrRangeButtons() {
        const btns = [
          ["1m", "corrRange1m"],
          ["3m", "corrRange3m"],
          ["6m", "corrRange6m"],
          ["1y", "corrRange1y"],
          ["3y", "corrRange3y"],
          ["5y", "corrRange5y"],
          ["10y", "corrRange10y"],
          ["all", "corrRangeAll"],
        ];
        if (!lastBaseline || !lastBaseline.nav || !lastBaseline.nav.dates || lastBaseline.nav.dates.length === 0) {
          for (const [, id] of btns) { const el = $(id); if (el) el.disabled = true; }
          return;
        }
        const dates = lastBaseline.nav.dates;
        const first = isoToDate(dates[0]);
        const end = isoToDate(dates[dates.length - 1]);
        for (const [key, id] of btns) {
          const el = $(id);
          if (!el) continue;
          if (key === "all") {
            el.disabled = false;
            continue;
          }
          const spec = _corrRangeSpec(key);
          const thr = spec.threshold ? spec.threshold(end) : null;
          // disable if full backtest shorter than desired window
          el.disabled = (!first || !thr) ? true : (first > thr);
        }
      }

      function dateToYmd(dt) {
        if (!(dt instanceof Date) || Number.isNaN(dt.getTime())) return "";
        const y = dt.getFullYear();
        const m = String(dt.getMonth() + 1).padStart(2, "0");
        const d = String(dt.getDate()).padStart(2, "0");
        return String(y) + m + d;
      }

      function computeAvailableRangeForSelection() {
        const items = pool.filter(x => selected.has(x.code));
        const starts = items.map(x => x.last_data_start_date).filter(Boolean).sort();
        const ends = items.map(x => x.last_data_end_date).filter(Boolean).sort();
        if (!starts.length || !ends.length) return { start: null, end: null };
        return { start: starts[starts.length - 1], end: ends[0] }; // max start, min end
      }

      function renderRangeHint() {
        const el = $("rangeHint");
        if (!el) return;
        const avail = computeAvailableRangeForSelection();
        if (!avail.start || !avail.end) {
          el.textContent = "共同区间：无";
          return;
        }
        el.textContent = `共同区间：${avail.start}~${avail.end}`;
      }

      function applyQuickRange(years) {
        const avail = computeAvailableRangeForSelection();
        if (!avail.start || !avail.end) {
          setMsg("无法计算快捷区间：请先勾选至少一个且已抓取过数据的标的。");
          return;
        }
        const availSn = ymdToNum(avail.start);
        const availEn = ymdToNum(avail.end);
        if (availSn == null || availEn == null) {
          setMsg("无法计算快捷区间：共同区间无效。");
          return;
        }

        let startYmd = avail.start;
        let endYmd = avail.end;
        if (Number.isFinite(years) && years > 0) {
          const endDt = ymdToDate(avail.end);
          if (!endDt) {
            setMsg("无法计算快捷区间：共同结束日期无效。");
            return;
          }
          const startDt = new Date(endDt.getTime());
          startDt.setFullYear(startDt.getFullYear() - Number(years));
          const candidate = dateToYmd(startDt);
          const candN = ymdToNum(candidate);
          if (candN != null) {
            const nextS = Math.max(availSn, candN);
            startYmd = numToYmd(nextS);
          } else {
            startYmd = avail.start;
          }
        }

        // Always clamp within [avail.start, avail.end]
        const nextSn = ymdToNum(startYmd);
        const nextEn = ymdToNum(endYmd);
        if (nextSn == null || nextEn == null || nextSn > nextEn) {
          startYmd = avail.start;
          endYmd = avail.end;
        }
        $("start").value = startYmd;
        $("end").value = endYmd;
      }

      function maybeAdjustBacktestRange() {
        const avail = computeAvailableRangeForSelection();
        if (!avail.start || !avail.end) return;
        const curS = ($("start").value || "").trim();
        const curE = ($("end").value || "").trim();
        const curSn = ymdToNum(curS);
        const curEn = ymdToNum(curE);
        const availSn = ymdToNum(avail.start);
        const availEn = ymdToNum(avail.end);
        if (curSn == null || curEn == null) {
          // if user hasn't set a valid range yet, initialize to available
          $("start").value = avail.start;
          $("end").value = avail.end;
          return;
        }
        // Only adjust if available interval is smaller than current specified interval (i.e. doesn't cover it)
        if (curSn < availSn || curEn > availEn) {
          const nextS = Math.max(curSn, availSn);
          const nextE = Math.min(curEn, availEn);
          if (nextS > nextE) {
            // no overlap -> fall back to full available interval
            $("start").value = avail.start;
            $("end").value = avail.end;
          } else {
            $("start").value = numToYmd(nextS);
            $("end").value = numToYmd(nextE);
          }
        }
      }

      function renderCodeList() {
        const box = $("codes");
        box.innerHTML = "";
        for (const it of pool) {
          const div = document.createElement("div");
          const checked = selected.has(it.code) ? "checked" : "";
          div.innerHTML = `<label style="display:flex; gap:8px; align-items:center;">
            <input type="checkbox" data-code="${it.code}" ${checked}/>
            <span>${it.code} ${it.name} <span class="muted">(${(it.last_data_start_date && it.last_data_end_date) ? (it.last_data_start_date + "~" + it.last_data_end_date) : "没有"})</span></span>
          </label>`;
          box.appendChild(div);
        }
        box.querySelectorAll("input[type=checkbox]").forEach(cb => {
          cb.addEventListener("change", () => {
            const c = cb.getAttribute("data-code");
            if (cb.checked) selected.add(c); else selected.delete(c);
            renderBenchmarkSelect();
            renderTrendCodeSelect();
            maybeAdjustBacktestRange();
            renderRangeHint();
          });
        });
      }

      function renderBenchmarkSelect() {
        const sel = $("benchmark");
        const codes = Array.from(selected);
        sel.innerHTML = "";
        for (const c of codes) {
          const opt = document.createElement("option");
          opt.value = c;
          opt.textContent = c;
          sel.appendChild(opt);
        }
        if (codes.includes("510300")) sel.value = "510300";
      }

      function renderTrendCodeSelect() {
        const sel = $("trendCode");
        if (!sel) return;
        const codes = Array.from(selected);
        const prev = sel.value || "";
        sel.innerHTML = "";
        for (const c of codes) {
          const opt = document.createElement("option");
          opt.value = c;
          opt.textContent = c;
          sel.appendChild(opt);
        }
        if (codes.includes(prev)) sel.value = prev;
      }

      async function loadPool() {
        const resp = await api(`/etf?adjust=${encodeURIComponent(ADJUST_USED)}`, { method: "GET" });
        pool = await resp.json();
        // default select all
        for (const it of pool) selected.add(it.code);
        renderCodeList();
        renderBenchmarkSelect();
        renderTrendCodeSelect();
        // default defensive ETF: keep empty as requested
        // Initialize or clamp backtest range to available intersection (only if needed)
        maybeAdjustBacktestRange();
        renderRangeHint();
      }

      function setMsg(t) { $("msg").textContent = t || ""; }

      function renderMetrics(metrics) {
        const rows = [
          { key: "benchmark_code", label: "基准标的", value: metrics.benchmark_code },
          { key: "rebalance", label: "再平衡周期", value: metrics.rebalance || "-" },
          { key: "risk_free_rate", label: "无风险收益率(年化)", value: metrics.risk_free_rate != null ? fmtPct(metrics.risk_free_rate) : "-" },
          { key: "cumulative_return", label: "累积收益率", value: fmtPct(metrics.cumulative_return) },
          { key: "annualized_return", label: "年化收益率", value: fmtPct(metrics.annualized_return) },
          { key: "annualized_volatility", label: "年化波动率", value: fmtPct(metrics.annualized_volatility) },
          { key: "max_drawdown", label: "最大回撤", value: fmtPct(metrics.max_drawdown) },
          { key: "max_drawdown_recovery_days", label: "最大回撤修复时长(天)", value: metrics.max_drawdown_recovery_days },
          { key: "sharpe_ratio", label: "夏普比率", value: fmtNum(metrics.sharpe_ratio) },
          { key: "calmar_ratio", label: "卡玛比率", value: fmtNum(metrics.calmar_ratio) },
          { key: "sortino_ratio", label: "索诺提比率", value: fmtNum(metrics.sortino_ratio) },
          { key: "information_ratio", label: "信息比率", value: fmtNum(metrics.information_ratio) },
          { key: "ulcer_index", label: "溃疡指标(UI)", value: fmtNum(metrics.ulcer_index) },
          { key: "ulcer_performance_index", label: "溃疡绩效(UPI)", value: fmtNum(metrics.ulcer_performance_index) },
          { key: "holding_weekly_win_rate", label: "周度绝对胜率", value: fmtPct(metrics.holding_weekly_win_rate) },
          { key: "holding_weekly_payoff_ratio", label: "周度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_weekly_payoff_ratio) },
          { key: "holding_weekly_kelly_fraction", label: "周度绝对凯利比(近似)", value: fmtPct(metrics.holding_weekly_kelly_fraction) },
          { key: "holding_monthly_win_rate", label: "月度绝对胜率", value: fmtPct(metrics.holding_monthly_win_rate) },
          { key: "holding_monthly_payoff_ratio", label: "月度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_monthly_payoff_ratio) },
          { key: "holding_monthly_kelly_fraction", label: "月度绝对凯利比(近似)", value: fmtPct(metrics.holding_monthly_kelly_fraction) },
          { key: "holding_quarterly_win_rate", label: "季度绝对胜率", value: fmtPct(metrics.holding_quarterly_win_rate) },
          { key: "holding_quarterly_payoff_ratio", label: "季度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_quarterly_payoff_ratio) },
          { key: "holding_quarterly_kelly_fraction", label: "季度绝对凯利比(近似)", value: fmtPct(metrics.holding_quarterly_kelly_fraction) },
          { key: "holding_yearly_win_rate", label: "年度绝对胜率", value: fmtPct(metrics.holding_yearly_win_rate) },
          { key: "holding_yearly_payoff_ratio", label: "年度绝对赔率(盈/亏)", value: fmtNum(metrics.holding_yearly_payoff_ratio) },
          { key: "holding_yearly_kelly_fraction", label: "年度绝对凯利比(近似)", value: fmtPct(metrics.holding_yearly_kelly_fraction) },
        ];
        const t = $("metrics");
        t.innerHTML =
          `<tr><th>指标</th><th>值</th></tr>` +
          rows
            .map(
              (r) => `
                <tr>
                  <td>
                    <span>${r.label}</span>
                    <button class="helpBtn" data-metric="${r.key}" title="查看说明"
                      style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">
                      ?
                    </button>
                  </td>
                  <td>${r.value}</td>
                </tr>
              `
            )
            .join("");
      }

      function renderContributionTables(kind, attribution) {
        const nameByCode = new Map((pool || []).map(x => [x.code, x.name]));
        const retEl = $(kind === "ew" ? "ewReturnContrib" : "rotReturnContrib");
        const riskEl = $(kind === "ew" ? "ewRiskContrib" : "rotRiskContrib");
        if (!retEl || !riskEl) return;

        if (!attribution || !attribution.return || !attribution.risk) {
          retEl.innerHTML = "<tr><th>标的</th><th>总收益贡献</th><th>贡献占比</th></tr>";
          riskEl.innerHTML = "<tr><th>标的</th><th>风险贡献占比</th></tr>";
          return;
        }

        const rrows = (attribution.return.by_code || []).slice();
        rrows.sort((a, b) => (Number(b.return_contribution || 0) - Number(a.return_contribution || 0)));
        retEl.innerHTML =
          `<tr><th>标的</th><th>总收益贡献</th><th>贡献占比</th></tr>` +
          rrows
            .map((x) => {
              const c = x.code;
              const nm = nameByCode.get(c) || "";
              const label = `${c}${nm ? " " + nm : ""}`;
              const contrib = (x.return_contribution == null) ? "-" : fmtPct(Number(x.return_contribution));
              const share = (x.return_share == null) ? "-" : (Number(x.return_share) * 100).toFixed(2) + "%";
              return `<tr><td>${label}</td><td>${contrib}</td><td>${share}</td></tr>`;
            })
            .join("");

        const kRisk = (attribution.risk.by_code || []).slice();
        kRisk.sort((a, b) => (Number(b.risk_share || 0) - Number(a.risk_share || 0)));
        riskEl.innerHTML =
          `<tr><th>标的</th><th>风险贡献占比</th></tr>` +
          kRisk
            .map((x) => {
              const c = x.code;
              const nm = nameByCode.get(c) || "";
              const label = `${c}${nm ? " " + nm : ""}`;
              const share = (x.risk_share == null) ? "-" : (Number(x.risk_share) * 100).toFixed(2) + "%";
              return `<tr><td>${label}</td><td>${share}</td></tr>`;
            })
            .join("");
      }

      const pageSize = 12;
      const periodState = {
        weekly: { page: 1, data: [] },
        monthly: { page: 1, data: [] },
        quarterly: { page: 1, data: [] },
        yearly: { page: 1, data: [] },
      };

      function _sortedPeriodRows(rows, sortKey, sortDir) {
        const arr = (rows || []).slice();
        const key = sortKey === "return" ? "return" : "period_end";
        arr.sort((a, b) => {
          const av = key === "return" ? Number(a.return) : String(a.period_end);
          const bv = key === "return" ? Number(b.return) : String(b.period_end);
          if (av < bv) return -1;
          if (av > bv) return 1;
          return 0;
        });
        if (sortDir === "desc") arr.reverse();
        return arr;
      }

      function renderPeriodPaged(kind) {
        const st = periodState[kind];
        const sortKey = $(`${kind}SortKey`).value;
        const sortDir = $(`${kind}SortDir`).value;
        const rows = _sortedPeriodRows(st.data, sortKey, sortDir);
        const total = rows.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        st.page = Math.min(Math.max(1, st.page), totalPages);
        const startIdx = (st.page - 1) * pageSize;
        const pageRows = rows.slice(startIdx, startIdx + pageSize);
        const t = $(kind);
        t.innerHTML = `<tr><th>期末</th><th>收益</th></tr>` + pageRows.map(x => `<tr><td>${x.period_end}</td><td>${fmtPct(x.return)}</td></tr>`).join("");
        $(`${kind}Page`).textContent = `${st.page}/${totalPages} · 共${total}条 · 每页${pageSize}条`;
      }

      function wirePeriodControls(kind) {
        $(`${kind}SortKey`).addEventListener("change", () => { periodState[kind].page = 1; renderPeriodPaged(kind); });
        $(`${kind}SortDir`).addEventListener("change", () => { periodState[kind].page = 1; renderPeriodPaged(kind); });
        $(`${kind}Prev`).addEventListener("click", () => { periodState[kind].page -= 1; renderPeriodPaged(kind); });
        $(`${kind}Next`).addEventListener("click", () => { periodState[kind].page += 1; renderPeriodPaged(kind); });
      }

      function plotNav(nav) {
        const dates = nav.dates;
        const series = nav.series;
        const traces = Object.keys(series).map(name => ({
          x: dates,
          y: series[name],
          mode: "lines",
          name,
          hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>",
        }));
        // RSI overlay (fixed windows: 6/12/24) on EW + benchmark only
        const rsiWins = [6, 12, 24];
        const _rsiWilder = (arr, window) => {
          const w = Math.max(1, Number(window || 1));
          const out = new Array(arr.length).fill(null);
          if (arr.length < w + 1) return out;
          // Wilder smoothing: alpha=1/w
          let avgGain = null;
          let avgLoss = null;
          for (let i = 1; i < arr.length; i++) {
            const prev = Number(arr[i - 1]);
            const cur = Number(arr[i]);
            if (!Number.isFinite(prev) || !Number.isFinite(cur) || prev <= 0 || cur <= 0) continue;
            const chg = cur - prev;
            const gain = Math.max(0, chg);
            const loss = Math.max(0, -chg);
            if (i <= w) {
              // seed with SMA of first w diffs
              // accumulate via temp sums
              if (avgGain == null) { avgGain = 0.0; avgLoss = 0.0; }
              avgGain += gain;
              avgLoss += loss;
              if (i === w) {
                avgGain = avgGain / w;
                avgLoss = avgLoss / w;
              }
            } else {
              avgGain = ((avgGain * (w - 1)) + gain) / w;
              avgLoss = ((avgLoss * (w - 1)) + loss) / w;
            }
            if (i >= w && avgGain != null && avgLoss != null) {
              let rsi = null;
              if (avgLoss === 0 && avgGain === 0) rsi = 50.0;
              else if (avgLoss === 0) rsi = 100.0;
              else if (avgGain === 0) rsi = 0.0;
              else {
                const rs = avgGain / avgLoss;
                rsi = 100.0 - (100.0 / (1.0 + rs));
              }
              out[i] = rsi;
            }
          }
          return out;
        };
        const addRsiFor = (key, labelPrefix, dash) => {
          if (!key || !series[key]) return;
          const navArr = series[key];
          for (const w of rsiWins) {
            traces.push({
              x: dates,
              y: _rsiWilder(navArr, w),
              mode: "lines",
              name: `${labelPrefix}RSI${w}`,
              yaxis: "y2",
              line: { dash: dash || "dot", width: 1.1 },
              hovertemplate: "%{x}<br>%{y:.1f}<extra></extra>",
            });
          }
        };
        // Only show EW RSI (no benchmark RSI)
        addRsiFor("EW", "", "solid");
        Plotly.newPlot(
          "chart",
          traces,
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: {
              type: "log",
              tick0: 0,
              // Coarser ticks to avoid dense labels; roughly 1,2,4,8...
              dtick: Math.log10(2.0),
              tickformat: ".0f",
              showgrid: true,
              gridcolor: "#eee",
              domain: [0.32, 1.0],
            },
            yaxis2: {
              title: "RSI",
              range: [0, 100],
              showgrid: false,
              zeroline: false,
              domain: [0.0, 0.25],
            },
            shapes: [
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 30, y1: 30, line: { color: "#999", width: 1, dash: "dot" } },
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 70, y1: 70, line: { color: "#999", width: 1, dash: "dot" } },
            ],
          },
          { responsive: true }
        );
      }

      function plotRolling(id, title, rollingMap, yTickFormat) {
        const traces = [];
        for (const k of Object.keys(rollingMap || {})) {
          const isPct = yTickFormat === ".0%";
          traces.push({
            x: rollingMap[k].dates,
            y: rollingMap[k].values,
            mode: "lines",
            name: k,
            // Keep axis at 0-decimal percent as requested, but show more precision on hover
            // so long windows (1y/3y) don't look like "steps" due to rounding.
            hovertemplate: isPct ? "%{x}<br>%{y:.2%}<extra></extra>" : "%{x}<br>%{y:.4f}<extra></extra>",
          });
        }
        Plotly.newPlot(
          id,
          traces,
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: yTickFormat ? { tickformat: yTickFormat } : undefined,
          },
          { responsive: true }
        );
      }

      // plotNavRsi removed: RSI is overlaid on NAV charts

      function renderFft(fft) {
        const tbl = $("fftTable");
        const sum = $("fftSummary");
        if (!tbl) return;
        if (!fft || fft.ok === false) {
          if (sum) sum.textContent = fft && fft.reason ? `FFT不可用：${fft.reason}` : "FFT不可用。";
          tbl.innerHTML = "";
          return;
        }
        const windows = fft.windows || [];
        const winLabels = ["full"].concat(windows.map(w => `last_${w}`));
        const fmtPct = (x) => (x == null || !Number.isFinite(Number(x)) ? "-" : (Number(x) * 100).toFixed(1) + "%");
        const fmtNum = (x) => (x == null || !Number.isFinite(Number(x)) ? "-" : Number(x).toFixed(2));
        const fmtPeaks = (peaks) => {
          if (!Array.isArray(peaks) || peaks.length === 0) return "-";
          return peaks
            .slice(0, 3)
            .map((p) => {
              const d = p && Number.isFinite(Number(p.period_days)) ? Math.round(Number(p.period_days)) : null;
              const s = p && Number.isFinite(Number(p.power_share)) ? (Number(p.power_share) * 100).toFixed(1) + "%" : null;
              return d == null ? "-" : `${d}d(${s || "-"})`;
            })
            .join(", ");
        };

        const rows = [];
        const addRowsFor = (label, obj) => {
          for (const w of winLabels) {
            const one = (obj && obj[w]) ? obj[w] : null;
            const ok = one && one.ok;
            rows.push({
              code: label,
              window: w,
              n: one ? one.n : null,
              peaks: ok ? fmtPeaks(one.peaks) : (one && one.reason ? `- (${one.reason})` : "-"),
              low: ok ? fmtPct(one.band_energy && one.band_energy.low) : "-",
              mid: ok ? fmtPct(one.band_energy && one.band_energy.mid) : "-",
              high: ok ? fmtPct(one.band_energy && one.band_energy.high) : "-",
              ent: ok ? fmtNum(one.spectral_entropy) : "-",
            });
          }
        };

        addRowsFor("EW(等权)", fft.ew || {});
        const per = fft.per_code || {};
        for (const code of Object.keys(per)) addRowsFor(code, per[code]);

        if (sum) {
          const nCodes = Object.keys(per).length;
          sum.textContent = `共 ${nCodes} 个标的 + EW(等权)；FFT方法=${fft.method || "-"}。`;
        }

        tbl.innerHTML =
          `<tr><th>标的</th><th>窗口</th><th>样本数</th><th>主导周期(Top3)</th><th>低频能量</th><th>中频能量</th><th>高频能量</th><th>谱熵</th></tr>` +
          rows
            .map(
              (r) =>
                `<tr>` +
                `<td>${esc(r.code)}</td>` +
                `<td>${esc(r.window)}</td>` +
                `<td>${esc(r.n == null ? "-" : String(r.n))}</td>` +
                `<td>${esc(r.peaks)}</td>` +
                `<td>${esc(r.low)}</td>` +
                `<td>${esc(r.mid)}</td>` +
                `<td>${esc(r.high)}</td>` +
                `<td>${esc(r.ent)}</td>` +
                `</tr>`
            )
            .join("");
      }

      function renderFftRoll(fftRoll) {
        const boxEnt = $("fftRollEntropy");
        const boxHigh = $("fftRollHigh");
        if (!boxEnt || !boxHigh) return;
        if (!fftRoll || !fftRoll.ew) {
          boxEnt.innerHTML = "<div class='muted'>无滚动FFT数据</div>";
          boxHigh.innerHTML = "<div class='muted'>无滚动FFT数据</div>";
          return;
        }
        const ew = fftRoll.ew;
        if (ew.ok === false) {
          const reason = ew.reason ? `：${esc(ew.reason)}` : "";
          boxEnt.innerHTML = `<div class='muted'>滚动FFT不可用${reason}</div>`;
          boxHigh.innerHTML = `<div class='muted'>滚动FFT不可用${reason}</div>`;
          return;
        }
        const series = ew.series || {};
        const keys = Object.keys(series);
        if (keys.length === 0) {
          boxEnt.innerHTML = "<div class='muted'>滚动FFT暂无数据（可能样本不足）</div>";
          boxHigh.innerHTML = "<div class='muted'>滚动FFT暂无数据（可能样本不足）</div>";
          return;
        }

        // Entropy chart
        const entTraces = [];
        for (const k of keys) {
          const s = series[k];
          if (!s || s.ok === false) continue;
          entTraces.push({
            x: s.dates,
            y: s.spectral_entropy,
            mode: "lines",
            name: k,
            hovertemplate: "%{x}<br>entropy=%{y:.3f}<extra></extra>",
          });
        }
        Plotly.newPlot(
          "fftRollEntropy",
          entTraces,
          { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { title: "谱熵(0-1)" } },
          { responsive: true }
        );

        // High-band energy chart
        const highTraces = [];
        for (const k of keys) {
          const s = series[k];
          if (!s || s.ok === false) continue;
          highTraces.push({
            x: s.dates,
            y: s.high_band_energy,
            mode: "lines",
            name: k,
            hovertemplate: "%{x}<br>high_energy=%{y:.2%}<extra></extra>",
          });
        }
        Plotly.newPlot(
          "fftRollHigh",
          highTraces,
          { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { title: "高频能量占比", tickformat: ".0%" } },
          { responsive: true }
        );
      }

      function plotCorrelation(corr) {
        const el = $("corrHeatmap");
        if (!corr || !corr.codes || !corr.matrix) {
          el.innerHTML = "<div class='muted'>无相关性数据</div>";
          return;
        }
        const codes = corr.codes;
        const z = corr.matrix;
        const n = codes.length;
        const idx = Array.from({ length: n }, (_, i) => String(i + 1));
        const text = z.map(row => row.map(v => (v == null || Number.isNaN(v)) ? "" : Number(v).toFixed(2)));

        // legend: 1..N -> code + name
        const nameByCode = new Map((pool || []).map(x => [x.code, x.name]));
        const lines = codes.map((c, i) => `${i + 1}. ${c} ${nameByCode.get(c) || ""}`.trim());
        $("corrLegend").textContent = lines.join("    ");

        Plotly.newPlot(
          "corrHeatmap",
          [{
            type: "heatmap",
            x: idx,
            y: idx,
            z,
            zmin: -1,
            zmax: 1,
            colorscale: [
              [0.0, "#2ca02c"],  // green for -1
              [0.5, "#ffffff"],  // white for 0
              [1.0, "#d62728"],  // red for +1
            ],
            text,
            texttemplate: "%{text}",
            textfont: { color: "#000000" },
            hovertemplate: "编号 %{y} × %{x}<br>ρ=%{z:.3f}<extra></extra>",
            showscale: false,
          }],
          {
            margin: { t: 20, l: 60, r: 20, b: 60 },
            xaxis: { tickmode: "array", tickvals: idx, ticktext: idx, side: "top" },
            yaxis: { tickmode: "array", tickvals: idx, ticktext: idx, autorange: "reversed", scaleanchor: "x", scaleratio: 1 },
          },
          { responsive: true }
        );
      }

      function plotRotation(result) {
        const dates = result.nav.dates;
        const s = result.nav.series;
        const rsiWins = [6, 12, 24];
        const _rsiWilder = (arr, window) => {
          const w = Math.max(1, Number(window || 1));
          const out = new Array(arr.length).fill(null);
          if (arr.length < w + 1) return out;
          let avgGain = null;
          let avgLoss = null;
          for (let i = 1; i < arr.length; i++) {
            const prev = Number(arr[i - 1]);
            const cur = Number(arr[i]);
            if (!Number.isFinite(prev) || !Number.isFinite(cur) || prev <= 0 || cur <= 0) continue;
            const chg = cur - prev;
            const gain = Math.max(0, chg);
            const loss = Math.max(0, -chg);
            if (i <= w) {
              if (avgGain == null) { avgGain = 0.0; avgLoss = 0.0; }
              avgGain += gain;
              avgLoss += loss;
              if (i === w) {
                avgGain = avgGain / w;
                avgLoss = avgLoss / w;
              }
            } else {
              avgGain = ((avgGain * (w - 1)) + gain) / w;
              avgLoss = ((avgLoss * (w - 1)) + loss) / w;
            }
            if (i >= w && avgGain != null && avgLoss != null) {
              let rsi = null;
              if (avgLoss === 0 && avgGain === 0) rsi = 50.0;
              else if (avgLoss === 0) rsi = 100.0;
              else if (avgGain === 0) rsi = 0.0;
              else {
                const rs = avgGain / avgLoss;
                rsi = 100.0 - (100.0 / (1.0 + rs));
              }
              out[i] = rsi;
            }
          }
          return out;
        };
        const _drawdownFromNav = (nav) => {
          let peak = -Infinity;
          const out = [];
          for (const v of nav) {
            const x = Number(v);
            if (!Number.isFinite(x) || x <= 0) { out.push(null); continue; }
            peak = Math.max(peak, x);
            out.push(peak > 0 ? (x / peak - 1.0) : null);
          }
          return out;
        };
        const _rollingReturn = (nav, window) => {
          const w = Math.max(1, Number(window || 1));
          const out = new Array(nav.length).fill(null);
          for (let i = w; i < nav.length; i++) {
            const a = Number(nav[i - w]);
            const b = Number(nav[i]);
            if (!Number.isFinite(a) || !Number.isFinite(b) || a <= 0) continue;
            out[i] = (b / a) - 1.0;
          }
          return out;
        };
        const _rollingMaxDrawdown = (nav, window) => {
          const w = Math.max(2, Number(window || 2));
          const out = new Array(nav.length).fill(null);
          for (let i = w - 1; i < nav.length; i++) {
            const start = i - w + 1;
            let peak = -Infinity;
            let mdd = 0.0;
            let ok = true;
            for (let j = start; j <= i; j++) {
              const x = Number(nav[j]);
              if (!Number.isFinite(x) || x <= 0) { ok = false; break; }
              peak = Math.max(peak, x);
              const dd = (peak > 0) ? (x / peak - 1.0) : 0.0;
              if (dd < mdd) mdd = dd;
            }
            out[i] = ok ? mdd : null;
          }
          return out;
        };
        const _rollingMeanStd = (arr, window) => {
          const w = Math.max(2, Number(window || 2));
          const mean = new Array(arr.length).fill(null);
          const std = new Array(arr.length).fill(null);
          let sum = 0.0;
          let sumsq = 0.0;
          let cnt = 0;
          const q = [];
          for (let i = 0; i < arr.length; i++) {
            const x = Number(arr[i]);
            q.push(x);
            if (Number.isFinite(x)) {
              sum += x;
              sumsq += x * x;
              cnt += 1;
            }
            if (q.length > w) {
              const y = Number(q.shift());
              if (Number.isFinite(y)) {
                sum -= y;
                sumsq -= y * y;
                cnt -= 1;
              }
            }
            if (q.length === w && cnt === w) {
              const m = sum / w;
              const v = Math.max(0.0, (sumsq / w) - (m * m));
              mean[i] = m;
              std[i] = Math.sqrt(v);
            }
          }
          return { mean, std };
        };
        const _rollingMean = (arr, window) => _rollingMeanStd(arr, window).mean;
        const traces = [
          { x: dates, y: s.ROTATION, mode: "lines", name: "ROTATION", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
          { x: dates, y: s.EW_REBAL, mode: "lines", name: "EW_REBAL", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
        ];
        // RSI (strategy only) below NAV (same figure, separate panel)
        for (const w of rsiWins) {
          traces.push({ x: dates, y: _rsiWilder(s.ROTATION || [], w), mode: "lines", name: `RSI${w}`, yaxis: "y2", line: { width: 1.1 }, hovertemplate: "%{x}<br>%{y:.1f}<extra></extra>" });
        }
        Plotly.newPlot(
          "rotChart",
          traces,
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: { type: "log", tick0: 0, dtick: Math.log10(2.0), tickformat: ".0f", gridcolor: "#eee", domain: [0.32, 1.0] },
            yaxis2: { title: "RSI", range: [0, 100], showgrid: false, zeroline: false, domain: [0.0, 0.25] },
            shapes: [
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 30, y1: 30, line: { color: "#999", width: 1, dash: "dot" } },
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 70, y1: 70, line: { color: "#999", width: 1, dash: "dot" } },
            ],
          },
          { responsive: true }
        );
        Plotly.newPlot(
          "rotDDCompare",
          [
            { x: dates, y: _drawdownFromNav(s.ROTATION), mode: "lines", name: "ROTATION DD", hovertemplate: "%{x}<br>%{y:.2%}<extra></extra>" },
            { x: dates, y: _drawdownFromNav(s.EW_REBAL), mode: "lines", name: "EW_REBAL DD", hovertemplate: "%{x}<br>%{y:.2%}<extra></extra>" },
          ],
          {
            margin: { t: 10, b: 30 },
            legend: { orientation: "h" },
            yaxis: { tickformat: ".0%", rangemode: "tozero", gridcolor: "#eee" },
          },
          { responsive: true }
        );
        Plotly.newPlot(
          "rotExcessChart",
          (() => {
            const ex = s.EXCESS || [];
            const ms250 = _rollingMeanStd(ex, 250);
            const ma250 = ms250.mean;
            const sd250 = ms250.std;
            const upper = ma250.map((m, i) => (m == null || sd250[i] == null ? null : (m + 2.0 * sd250[i])));
            const lower = ma250.map((m, i) => (m == null || sd250[i] == null ? null : (m - 2.0 * sd250[i])));
            const out = [
              { x: dates, y: ex, mode: "lines", name: "EXCESS", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
              // Bollinger band (lower -> upper fill)
              { x: dates, y: lower, mode: "lines", name: "BB Lower(250)", line: { color: "rgba(31,119,180,0.25)", width: 1 }, hoverinfo: "skip" },
              { x: dates, y: upper, mode: "lines", name: "BB Upper(250)", line: { color: "rgba(31,119,180,0.25)", width: 1 }, fill: "tonexty", fillcolor: "rgba(31,119,180,0.10)", hoverinfo: "skip" },
              { x: dates, y: ma250, mode: "lines", name: "MA250", line: { color: "rgba(31,119,180,0.85)", width: 1.5 }, hovertemplate: "%{x}<br>MA250=%{y:.4f}<extra></extra>" },
            ];
            // RSI on EXCESS below chart (same figure, separate panel)
            for (const w of rsiWins) {
              out.push({ x: dates, y: _rsiWilder(ex, w), mode: "lines", name: `RSI${w}`, yaxis: "y2", line: { width: 1.1 }, hovertemplate: "%{x}<br>%{y:.1f}<extra></extra>" });
            }
            return out;
          })(),
          {
            margin: { t: 20 },
            legend: { orientation: "h" },
            yaxis: { type: "log", tick0: 0, dtick: Math.log10(2.0), tickformat: ".0f", gridcolor: "#eee", domain: [0.32, 1.0] },
            yaxis2: { title: "RSI", range: [0, 100], showgrid: false, zeroline: false, domain: [0.0, 0.25] },
            shapes: [
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 30, y1: 30, line: { color: "#999", width: 1, dash: "dot" } },
              { type: "line", xref: "paper", x0: 0, x1: 1, yref: "y2", y0: 70, y1: 70, line: { color: "#999", width: 1, dash: "dot" } },
            ],
          },
          { responsive: true }
        );

        // 40-day rolling return difference: ROTATION - EW_REBAL
        const rot40 = _rollingReturn(s.ROTATION || [], 40);
        const ew40 = _rollingReturn(s.EW_REBAL || [], 40);
        const diff40 = rot40.map((x, i) => {
          const a = Number(x);
          const b = Number(ew40[i]);
          if (!Number.isFinite(a) || !Number.isFinite(b)) return null;
          return a - b;
        });
        const diff40Ma250 = _rollingMean(diff40, 250);
        Plotly.newPlot(
          "rot40dDiffChart",
          [
            { x: dates, y: diff40, mode: "lines", name: "40D Δ", line: { color: "rgba(214,39,40,0.85)", width: 1.5 }, hovertemplate: "%{x}<br>Δ=%{y:.2%}<extra></extra>" },
            { x: dates, y: diff40Ma250, mode: "lines", name: "MA250(Δ)", line: { color: "rgba(214,39,40,0.45)", width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>MA250(Δ)=%{y:.2%}<extra></extra>" },
          ],
          {
            margin: { t: 10, b: 30 },
            legend: { orientation: "h" },
            yaxis: { tickformat: ".0%", zeroline: true, zerolinecolor: "#bbb", gridcolor: "#eee" },
          },
          { responsive: true }
        );

        // Rolling (1/3/5y) return & max drawdown for ROTATION and EXCESS.
        const w1 = 252, w3 = 252 * 3, w5 = 252 * 5;
        const _plotRollingCombo = (divId, nav, titlePrefix) => {
          const r1 = _rollingReturn(nav, w1), r3 = _rollingReturn(nav, w3), r5 = _rollingReturn(nav, w5);
          const d1 = _rollingMaxDrawdown(nav, w1), d3 = _rollingMaxDrawdown(nav, w3), d5 = _rollingMaxDrawdown(nav, w5);
          const c1 = "rgba(31,119,180,0.90)";
          const c3 = "rgba(44,160,44,0.90)";
          const c5 = "rgba(255,127,14,0.90)";
          const ddMin = (() => {
            let m = 0.0;
            for (const arr of [d1, d3, d5]) {
              for (const v of arr) {
                const x = Number(v);
                if (!Number.isFinite(x)) continue;
                if (x < m) m = x;
              }
            }
            // pad slightly for readability
            return Math.min(-0.01, m - 0.02);
          })();
          Plotly.newPlot(
            divId,
            [
              // returns (top panel)
              { x: dates, y: r1, mode: "lines", name: `${titlePrefix} R(1y)`, xaxis: "x2", yaxis: "y", line: { color: c1, width: 1.4 }, hovertemplate: "%{x}<br>R1Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: r3, mode: "lines", name: `${titlePrefix} R(3y)`, xaxis: "x2", yaxis: "y", line: { color: c3, width: 1.4 }, hovertemplate: "%{x}<br>R3Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: r5, mode: "lines", name: `${titlePrefix} R(5y)`, xaxis: "x2", yaxis: "y", line: { color: c5, width: 1.4 }, hovertemplate: "%{x}<br>R5Y=%{y:.1%}<extra></extra>" },
              // drawdowns (bottom panel)
              { x: dates, y: d1, mode: "lines", name: `${titlePrefix} DD(1y)`, xaxis: "x", yaxis: "y2", line: { color: c1, width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>DD1Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: d3, mode: "lines", name: `${titlePrefix} DD(3y)`, xaxis: "x", yaxis: "y2", line: { color: c3, width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>DD3Y=%{y:.1%}<extra></extra>" },
              { x: dates, y: d5, mode: "lines", name: `${titlePrefix} DD(5y)`, xaxis: "x", yaxis: "y2", line: { color: c5, width: 1.2, dash: "dot" }, hovertemplate: "%{x}<br>DD5Y=%{y:.1%}<extra></extra>" },
            ],
            {
              margin: { t: 10, b: 30 },
              legend: { orientation: "h" },
              // bottom x-axis
              xaxis: { domain: [0, 1], anchor: "y2" },
              // top x-axis (hidden ticks, match zoom)
              xaxis2: { domain: [0, 1], anchor: "y", matches: "x", showticklabels: false },
              // top panel: returns
              yaxis: { title: "Rolling Return", tickformat: ".0%", domain: [0.55, 1.0], zeroline: true, zerolinecolor: "#bbb", gridcolor: "#eee" },
              // bottom panel: drawdowns
              yaxis2: { title: "Rolling MDD", tickformat: ".0%", domain: [0.0, 0.45], range: [ddMin, 0], zeroline: true, zerolinecolor: "#bbb", gridcolor: "#eee" },
            },
            { responsive: true }
          );
        };
        _plotRollingCombo("rotRollingCombo", s.ROTATION || [], "ROT");
        _plotRollingCombo("rotExcessRollingCombo", s.EXCESS || [], "EX");
      }

      function renderRotationMetrics(m) {
        const s = m.strategy || {};
        const ex = m.excess_vs_equal_weight || {};
        const rows = [
          { key: "rot_cum", label: "策略累积收益", value: fmtPct(s.cumulative_return) },
          { key: "rot_ann", label: "策略年化收益", value: fmtPct(s.annualized_return) },
          { key: "rot_vol", label: "策略年化波动", value: fmtPct(s.annualized_volatility) },
          { key: "rot_mdd", label: "策略最大回撤", value: fmtPct(s.max_drawdown) },
          { key: "rot_sharpe", label: "策略夏普", value: fmtNum(s.sharpe_ratio) },
          { key: "rot_sortino", label: "策略索诺提", value: fmtNum(s.sortino_ratio) },
          { key: "rot_ui", label: "溃疡指标(UI)", value: fmtNum(s.ulcer_index) },
          { key: "rot_upi", label: "溃疡绩效(UPI)", value: fmtNum(s.ulcer_performance_index) },
          { key: "rot_turnover", label: "平均日换手", value: fmtPct(s.avg_daily_turnover) },
          { key: "rot_excess_cum", label: "超额累积收益", value: fmtPct(ex.cumulative_return) },
          { key: "rot_excess_ann", label: "超额年化收益", value: fmtPct(ex.annualized_return) },
          { key: "rot_ir", label: "超额信息比率(近似)", value: fmtNum(ex.information_ratio) },
        ];
        $("rotMetrics").innerHTML =
          `<tr><th>指标</th><th>值</th></tr>` +
          rows
            .map(
              (r) => `
                <tr>
                  <td>
                    <span>${r.label}</span>
                    <button class="helpBtn" data-metric="${r.key}" title="查看说明"
                      style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">
                      ?
                    </button>
                  </td>
                  <td>${r.value}</td>
                </tr>
              `
            )
            .join("");
      }

      function renderWinPayoff(wp) {
        const rows = [
          { key: null, label: "调仓频率", value: wp.rebalance || "-" },
          { key: null, label: "期数", value: wp.periods != null ? wp.periods : "-" },
          { key: "rot_wp_win", label: "胜率(超额>0)", value: wp.win_rate != null ? fmtPct(wp.win_rate) : "-" },
          { key: "rot_wp_avg_win", label: "平均盈利(超额)", value: wp.avg_win_excess != null ? fmtPct(wp.avg_win_excess) : "-" },
          { key: "rot_wp_avg_loss", label: "平均亏损(超额)", value: wp.avg_loss_excess != null ? fmtPct(wp.avg_loss_excess) : "-" },
          { key: "rot_wp_payoff", label: "赔率(盈/亏)", value: wp.payoff_ratio != null ? fmtNum(wp.payoff_ratio) : "-" },
          { key: "rot_wp_kelly", label: "凯利比(近似)", value: wp.kelly_fraction != null ? fmtPct(wp.kelly_fraction) : "-" },
          { key: "rot_abs_win", label: "绝对胜率(期收益>0)", value: wp.abs_win_rate != null ? fmtPct(wp.abs_win_rate) : "-" },
          { key: null, label: "绝对平均盈利", value: wp.abs_avg_win != null ? fmtPct(wp.abs_avg_win) : "-" },
          { key: null, label: "绝对平均亏损", value: wp.abs_avg_loss != null ? fmtPct(wp.abs_avg_loss) : "-" },
          { key: "rot_abs_payoff", label: "绝对赔率(盈/亏)", value: wp.abs_payoff_ratio != null ? fmtNum(wp.abs_payoff_ratio) : "-" },
          { key: "rot_abs_kelly", label: "绝对凯利比(近似)", value: wp.abs_kelly_fraction != null ? fmtPct(wp.abs_kelly_fraction) : "-" },
        ];
        $("rotWinPayoff").innerHTML =
          `<tr><th>指标</th><th>值</th></tr>` +
          rows
            .map(
              (r) => `
                <tr>
                  <td>
                    <span>${r.label}</span>
                    ${
                      r.key
                        ? `<button class="helpBtn" data-metric="${r.key}" title="查看说明"
                          style="margin-left:6px; width:18px; height:18px; border-radius:50%; border:1px solid #bbb; background:#fff; font-size:12px; line-height:16px; padding:0; cursor:pointer;">?</button>`
                        : ""
                    }
                  </td>
                  <td>${r.value}</td>
                </tr>
              `
            )
            .join("");
      }

      const rotState = { page: 1, rows: [] };
      function _sortedRotRows(rows, key, dir) {
        const arr = (rows || []).slice();
        const k = key === "excess" ? "excess_return" : (key === "end" ? "end_date" : "start_date");
        arr.sort((a, b) => {
          const av = k === "excess_return" ? Number(a[k]) : String(a[k]);
          const bv = k === "excess_return" ? Number(b[k]) : String(b[k]);
          if (av < bv) return -1;
          if (av > bv) return 1;
          return 0;
        });
        if (dir === "desc") arr.reverse();
        return arr;
      }
      function renderRotPeriods() {
        const key = $("rotPeriodSortKey").value;
        const dir = $("rotPeriodSortDir").value;
        const rows = _sortedRotRows(rotState.rows, key, dir);
        const total = rows.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        rotState.page = Math.min(Math.max(1, rotState.page), totalPages);
        const startIdx = (rotState.page - 1) * pageSize;
        const pageRows = rows.slice(startIdx, startIdx + pageSize);
        const fmtLegBuy = (xs) => (xs || []).map(x => `${x.code}:${fmtPct(x.delta_weight)}`).join(" ");
        const fmtLegSell = (xs) => (xs || []).map(x => `${x.code}:${fmtPct(Math.abs(x.delta_weight))}`).join(" ");
        $("rotPeriods").innerHTML =
          `<tr><th>开始</th><th>结束</th><th>轮动收益</th><th>等权收益</th><th>超额</th><th>胜</th><th>调入(Δw)</th><th>调出(Δw)</th></tr>` +
          pageRows.map(r => `<tr><td>${r.start_date}</td><td>${r.end_date}</td><td>${fmtPct(r.strategy_return)}</td><td>${fmtPct(r.equal_weight_return)}</td><td>${fmtPct(r.excess_return)}</td><td>${r.win ? "是" : "否"}</td><td>${fmtLegBuy(r.buys)}</td><td>${fmtLegSell(r.sells)}</td></tr>`).join("");
        $("rotPeriodPage").textContent = `${rotState.page}/${totalPages} · 共${total}条 · 每页${pageSize}条`;
      }

      const rotPeriodTableState = {
        weekly: { page: 1, rows: [] },
        monthly: { page: 1, rows: [] },
        quarterly: { page: 1, rows: [] },
        yearly: { page: 1, rows: [] },
      };
      function _sortedRotPeriodRows(rows, sortKey, sortDir) {
        const arr = (rows || []).slice();
        let k = "period_end";
        if (sortKey === "strategy") k = "strategy_return";
        if (sortKey === "excess") k = "excess_return";
        arr.sort((a, b) => {
          const av = k === "period_end" ? String(a[k]) : Number(a[k]);
          const bv = k === "period_end" ? String(b[k]) : Number(b[k]);
          if (av < bv) return -1;
          if (av > bv) return 1;
          return 0;
        });
        if (sortDir === "desc") arr.reverse();
        return arr;
      }
      function renderRotPeriodTable(kind) {
        const st = rotPeriodTableState[kind];
        const sortKey = $(`rot${kind[0].toUpperCase() + kind.slice(1)}SortKey`).value;
        const sortDir = $(`rot${kind[0].toUpperCase() + kind.slice(1)}SortDir`).value;
        const rows = _sortedRotPeriodRows(st.rows, sortKey, sortDir);
        const total = rows.length;
        const totalPages = Math.max(1, Math.ceil(total / pageSize));
        st.page = Math.min(Math.max(1, st.page), totalPages);
        const startIdx = (st.page - 1) * pageSize;
        const pageRows = rows.slice(startIdx, startIdx + pageSize);
        $( `rot${kind[0].toUpperCase() + kind.slice(1)}` ).innerHTML =
          `<tr><th>期末</th><th>策略</th><th>基准</th><th>超额</th></tr>` +
          pageRows.map(r => `<tr><td>${r.period_end}</td><td>${fmtPct(r.strategy_return)}</td><td>${fmtPct(r.benchmark_return)}</td><td>${fmtPct(r.excess_return)}</td></tr>`).join("");
        $(`rot${kind[0].toUpperCase() + kind.slice(1)}Page`).textContent = `${st.page}/${totalPages} · 共${total}条 · 每页${pageSize}条`;
      }
      function wireRotPeriodControls(kind) {
        const cap = kind[0].toUpperCase() + kind.slice(1);
        $(`rot${cap}SortKey`).addEventListener("change", () => { rotPeriodTableState[kind].page = 1; renderRotPeriodTable(kind); });
        $(`rot${cap}SortDir`).addEventListener("change", () => { rotPeriodTableState[kind].page = 1; renderRotPeriodTable(kind); });
        $(`rot${cap}Prev`).addEventListener("click", () => { rotPeriodTableState[kind].page -= 1; renderRotPeriodTable(kind); });
        $(`rot${cap}Next`).addEventListener("click", () => { rotPeriodTableState[kind].page += 1; renderRotPeriodTable(kind); });
      }

      function _checkedValues(sel) {
        return Array.from(document.querySelectorAll(sel)).filter(x => x && x.checked).map(x => x.value);
      }

      function renderCalendarAnchorBox(prefix, rebalance) {
        const box = $(`${prefix}CalAnchorBox`);
        const label = $(`${prefix}CalAnchorLabel`);
        if (!box || !label) return;
        const r = String(rebalance || "weekly").toLowerCase();
        box.innerHTML = "";
        const mkCb = (cls, val, text, checked=true) =>
          `<label style="display:flex; gap:6px; align-items:center; margin:0;">
            <input type="checkbox" class="${cls}" value="${val}" ${checked ? "checked" : ""} />${text}
          </label>`;
        const mkCsv = (id, val, placeholder) =>
          `<input id="${id}" value="${esc(val)}" placeholder="${esc(placeholder)}" style="min-width:280px;" />
           <div class="muted" style="margin-top:4px;">输入逗号分隔整数，例如 1,5,10（表示当期第1/5/10个交易日）。</div>`;

        if (r === "weekly") {
          label.textContent = "调仓日（周度）";
          const cls = `${prefix}CalAnchor`;
          box.innerHTML = `<div class="row" style="gap:10px; align-items:center; flex-wrap:wrap;">
            ${mkCb(cls, 0, "周一")}
            ${mkCb(cls, 1, "周二")}
            ${mkCb(cls, 2, "周三")}
            ${mkCb(cls, 3, "周四")}
            ${mkCb(cls, 4, "周五")}
          </div>`;
          return;
        }
        if (r === "monthly") {
          label.textContent = "调仓日（月度，日历日 1~28）";
          const cls = `${prefix}CalAnchor`;
          const items = Array.from({length: 28}, (_, i) => i + 1)
            .map((d) => mkCb(cls, d, `${d}号`, d === 1))
            .join("");
          box.innerHTML = `<div class="row" style="gap:10px; align-items:center; flex-wrap:wrap; max-height:140px; overflow:auto; border:1px solid #ddd; padding:8px; border-radius:8px;">${items}</div>`;
          return;
        }
        if (r === "quarterly") {
          label.textContent = "调仓日（季度，第N个交易日）";
          box.innerHTML = mkCsv(`${prefix}CalAnchorCsv`, "1,5,10,20,40,60", "例如 1,5,10,20,40,60");
          return;
        }
        if (r === "yearly") {
          label.textContent = "调仓日（年度，第N个交易日）";
          box.innerHTML = mkCsv(`${prefix}CalAnchorCsv`, "1,5,10,20,60,120,180,240", "例如 1,5,10,20,60,120,180,240");
          return;
        }
        label.textContent = "调仓锚点";
        box.innerHTML = `<div class="muted">当前调仓周期不支持日历锚点研究（仅支持 weekly/monthly/quarterly/yearly）。</div>`;
      }

      function parseCalendarAnchors(prefix, rebalance) {
        const r = String(rebalance || "weekly").toLowerCase();
        const cls = `${prefix}CalAnchor`;
        if (r === "weekly" || r === "monthly") {
          const xs = _checkedValues(`input.${cls}`).map((x) => Number(x)).filter((x) => Number.isFinite(x));
          if (xs.length === 0) return { ok: false, reason: "请至少选择一个调仓锚点" };
          return { ok: true, anchors: xs };
        }
        if (r === "quarterly" || r === "yearly") {
          const el = $(`${prefix}CalAnchorCsv`);
          const raw = (el && el.value ? el.value : "").trim();
          const xs = raw.split(",").map(x => x.trim()).filter(Boolean).map(Number).map(x => Math.floor(x)).filter(x => Number.isFinite(x));
          const ys = xs.filter(x => x >= 1);
          if (ys.length === 0) return { ok: false, reason: "请输入至少一个 >=1 的整数锚点（逗号分隔）" };
          const maxN = (r === "quarterly") ? 90 : 300;
          const bad = ys.find(x => x > maxN);
          if (bad != null) return { ok: false, reason: `锚点 N 过大：${bad}（${r === "quarterly" ? "季度" : "年度"}建议 <= ${maxN}）` };
          return { ok: true, anchors: ys };
        }
        return { ok: false, reason: "当前调仓周期不支持日历锚点研究（仅支持 weekly/monthly/quarterly/yearly）" };
      }

      function _renderCalendarTable(tableId, data) {
        const el = $(tableId);
        if (!el) return;
        const grid = (data && data.grid) ? data.grid : [];
        const reb = (data && data.meta && data.meta.rebalance) ? String(data.meta.rebalance) : "weekly";
        const pxMap = (data && data.exec_price_map) ? data.exec_price_map : {};
        const rolling = (data && data.rolling) ? data.rolling : null;
        const rollingStats = (data && data.rolling_stats) ? data.rolling_stats : null;
        const rollYears = (data && data.meta && Array.isArray(data.meta.rolling_years)) ? data.meta.rolling_years : [1, 3, 5];
        const anchorLabel = (a) => {
          const n = Number(a);
          if (reb === "weekly") {
            const m = {0:"周一",1:"周二",2:"周三",3:"周四",4:"周五"};
            return m[n] || String(a);
          }
          if (reb === "monthly") return `${n}号`;
          if (reb === "quarterly") return `季度第${n}个交易日`;
          if (reb === "yearly") return `年度第${n}个交易日`;
          return String(a);
        };
        const keyLabel = (key) => {
          const parts = String(key).split("|");
          const a = parts[0];
          const px = parts[1] || "";
          return `${anchorLabel(a)} · ${(pxMap[px] || px)}`;
        };
        const rows = grid.slice().sort((a, b) => {
          if (a.anchor !== b.anchor) return Number(a.anchor) - Number(b.anchor);
          return String(a.exec_price).localeCompare(String(b.exec_price));
        });
        el.innerHTML =
          `<tr><th>调仓锚点</th><th>成交价</th><th>年化收益</th><th>夏普</th><th>卡玛</th><th>索诺提</th><th>溃疡(UI)</th><th>UPI</th><th>信息比率</th><th>最大回撤</th><th>平均日换手</th><th>状态</th></tr>` +
          rows.map((r) => {
            const ok = !!r.ok;
            const m = ok ? (r.metrics || {}) : {};
            const ann = ok ? fmtPct(m.annualized_return) : "-";
            const sr = ok ? fmtNum(m.sharpe_ratio) : "-";
            const calmar = ok ? fmtNum(m.calmar_ratio) : "-";
            const sortino = ok ? fmtNum(m.sortino_ratio) : "-";
            const ui = ok ? fmtNum(m.ulcer_index) : "-";
            const upi = ok ? fmtNum(m.ulcer_performance_index) : "-";
            const ir = ok ? fmtNum(m.information_ratio) : "-";
            const mdd = ok ? fmtPct(m.max_drawdown) : "-";
            const to = ok ? fmtPct(m.avg_daily_turnover) : "-";
            const status = ok ? "OK" : (esc(r.reason || "ERR"));
            return `<tr><td>${anchorLabel(r.anchor)}</td><td>${pxMap[r.exec_price] || r.exec_price}</td><td>${ann}</td><td>${sr}</td><td>${calmar}</td><td>${sortino}</td><td>${ui}</td><td>${upi}</td><td>${ir}</td><td>${mdd}</td><td>${to}</td><td>${status}</td></tr>`;
          }).join("");

        // Heatmap (annualized_return)
        const divId = (tableId === "ewCalTable") ? "ewCalHeatmap" : "rotCalHeatmap";
        const okRows = rows.filter(x => x.ok && x.metrics && Number.isFinite(Number(x.metrics.annualized_return)));
        if (!$(divId)) return;
        if (okRows.length === 0) { Plotly.purge(divId); return; }
        const uniqWk = Array.from(new Set(rows.map(x => Number(x.anchor)))).sort((a, b) => a - b);
        const uniqPx = Array.from(new Set(rows.map(x => String(x.exec_price)))).sort();
        const z = uniqWk.map(wd => uniqPx.map(px => {
          const one = rows.find(x => Number(x.anchor) === wd && String(x.exec_price) === px && x.ok);
          if (!one) return null;
          const v = one.metrics ? Number(one.metrics.annualized_return) : NaN;
          return Number.isFinite(v) ? v * 100.0 : null; // percent
        }));
        const y = uniqWk.map(wd => anchorLabel(wd));
        const x = uniqPx.map(px => pxMap[px] || px);
        Plotly.newPlot(divId, [{
          type: "heatmap",
          x,
          y,
          z,
          colorscale: "RdYlGn",
          colorbar: { title: "年化收益(%)" },
          hovertemplate: "%{y} · %{x}<br>%{z:.2f}%<extra></extra>",
        }], {
          title: (tableId === "ewCalTable") ? "等权：年化收益热力图（%）" : "轮动：年化收益热力图（%）",
          margin: { l: 60, r: 20, t: 50, b: 60 },
        }, { displayModeBar: false });

        // Rolling N-year return curves (1/3/5y) + summary stats table (stability).
        const chartId = (tableId === "ewCalTable") ? "ewCalRollingChart" : "rotCalRollingChart";
        const statId = (tableId === "ewCalTable") ? "ewCalRollingStats" : "rotCalRollingStats";
        const chartEl = $(chartId);
        const statEl = $(statId);
        if (chartEl && rolling && rolling.dates && rolling.series) {
          const rdates = rolling.dates;
          const series = rolling.series;
          const keys = Object.keys(series);
          const years = rollYears.map(x => Number(x)).filter(x => Number.isFinite(x));
          const yearKeys = years.map(y => `${y}y`);
          const buildTraces = (yk) => keys.map((k) => ({
            x: rdates,
            y: (series[k] && series[k][yk]) ? series[k][yk] : [],
            mode: "lines",
            name: keyLabel(k),
            line: { width: 1.2 },
            hovertemplate: "%{x}<br>%{y:.1%}<extra></extra>",
          }));
          const tracesAll = [];
          const vis = [];
          for (const yk of yearKeys) {
            const ts = buildTraces(yk);
            for (const t of ts) { tracesAll.push(t); vis.push(false); }
          }
          // default: 1y visible
          const nKeys = keys.length;
          for (let i = 0; i < nKeys; i++) vis[i] = true;
          tracesAll.forEach((t, i) => { t.visible = vis[i]; });
          const buttons = yearKeys.map((yk, idx) => {
            const v = new Array(tracesAll.length).fill(false);
            const base = idx * nKeys;
            for (let i = 0; i < nKeys; i++) v[base + i] = true;
            return { label: yk.toUpperCase(), method: "update", args: [{ visible: v }, { title: `${tableId === "ewCalTable" ? "等权" : "轮动"}：滚动收益率（${yk.toUpperCase()}）` }] };
          });
          Plotly.newPlot(chartId, tracesAll, {
            title: `${tableId === "ewCalTable" ? "等权" : "轮动"}：滚动收益率（1Y/3Y/5Y）`,
            margin: { t: 50, b: 40, l: 60, r: 20 },
            legend: { orientation: "h" },
            yaxis: { tickformat: ".0%", gridcolor: "#eee", zeroline: true, zerolinecolor: "#bbb" },
            updatemenus: [{ type: "buttons", direction: "right", x: 0.0, y: 1.18, showactive: true, buttons }],
          }, { responsive: true, displayModeBar: false });
        }
        if (statEl && rollingStats) {
          const keys = Object.keys(rollingStats);
          const years = rollYears.map(x => Number(x)).filter(x => Number.isFinite(x));
          const yearKeys = years.map(y => `${y}y`);
          const rows2 = [];
          for (const k of keys.sort()) {
            for (const yk of yearKeys) {
              const st = (rollingStats[k] && rollingStats[k][yk]) ? rollingStats[k][yk] : {};
              rows2.push({
                key: k,
                yk,
                count: st.count,
                mean: st.mean,
                std: st.std,
                p10: st.p10,
                p50: st.p50,
                p90: st.p90,
                pos: st.pos_ratio,
                min: st.min,
                max: st.max,
              });
            }
          }
          statEl.innerHTML =
            `<tr><th>方案</th><th>窗口</th><th>样本数</th><th>均值</th><th>Std</th><th>P10</th><th>P50</th><th>P90</th><th>正收益占比</th><th>最小</th><th>最大</th></tr>` +
            rows2.map(r => {
              const f = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : fmtPct(Number(x));
              const n = (x) => (x == null || Number.isNaN(Number(x))) ? "-" : String(x);
              const label = keyLabel(r.key);
              return `<tr><td>${label}</td><td>${r.yk.toUpperCase()}</td><td>${n(r.count)}</td><td>${f(r.mean)}</td><td>${f(r.std)}</td><td>${f(r.p10)}</td><td>${f(r.p50)}</td><td>${f(r.p90)}</td><td>${f(r.pos)}</td><td>${f(r.min)}</td><td>${f(r.max)}</td></tr>`;
            }).join("");
        }
      }

      async function runRotation() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const rebalance = $("rotRebalance").value;
        const top_k = Number(($("rotTopK").value || "1").trim());
        const lookback_days = Number(($("rotLookback").value || "252").trim());
        const skip_days = Number(($("rotSkip").value || "0").trim());
        const cost_bps = Number(($("rotCost").value || "0").trim());
        const risk_off = ($("rotRiskOff").value === "true");
        const momentum_floor = Number(($("rotFloor").value || "0").trim());
        const score_method = $("rotScoreMethod").value;
        const tp_sl_mode = ($("rotTpSlMode").value || "none");
        const atrWindowRaw = ($("rotAtrWindow").value || "").trim();
        const atr_window = atrWindowRaw === "" ? null : Number(atrWindowRaw);
        if (atr_window != null && (!Number.isFinite(atr_window) || atr_window < 2)) return setMsg("ATR窗口必须>=2（或留空表示同步动量回看）");
        const atr_mult = Number(($("rotAtrMult").value || "2.0").trim());
        if (!Number.isFinite(atr_mult) || atr_mult <= 0) return setMsg("ATR倍数必须>0，例如 2");
        const atr_step = Number(($("rotAtrStep").value || "0.5").trim());
        if (!Number.isFinite(atr_step) || atr_step <= 0) return setMsg("渐进步长必须>0，例如 0.5");
        const atr_min_mult = Number(($("rotAtrMinMult").value || "0.5").trim());
        if (!Number.isFinite(atr_min_mult) || atr_min_mult <= 0) return setMsg("最小倍数必须>0，例如 0.5");
        const trend_filter = ($("rotTrendOn").value === "true");
        const trend_mode = $("rotTrendMode").value;
        const trend_sma_window = Number(($("rotTrendSma").value || "200").trim());
        const rsi_filter = ($("rotRsiOn").value === "true");
        const rsi_window = Number(($("rotRsiWin").value || "14").trim());
        const rsi_overbought = Number(($("rotRsiOver").value || "70").trim());
        const rsi_oversold = Number(($("rotRsiUnder").value || "30").trim());
        const vol_monitor = ($("rotVolOn").value === "true");
        const vol_window = Number(($("rotVolWin").value || "20").trim());
        const vol_target_ann = Number(($("rotVolTarget").value || "0.20").trim());
        const vol_max_ann = Number(($("rotVolMax").value || "0.60").trim());
        const chop_filter = ($("rotChopOn").value === "true");
        const chop_mode = ($("rotChopMode").value || "er");
        const chop_window = Number(($("rotChopWin").value || "20").trim());
        const chop_er_threshold = Number(($("rotChopThr").value || "0.25").trim());
        const chop_adx_window = Number(($("rotChopAdxWin").value || "20").trim());
        const chop_adx_threshold = Number(($("rotChopAdxThr").value || "20").trim());
        const corr_filter = ($("rotCorrOn").value === "true");
        const corrWinRaw = ($("rotCorrWindow").value || "").trim();
        const corr_window = corrWinRaw === "" ? null : Number(corrWinRaw);
        if (corr_filter && corr_window != null && (!Number.isFinite(corr_window) || corr_window < 2)) return setMsg("相关性回看窗口必须>=2（或留空表示同步动量回看）");
        const corr_threshold = Number(($("rotCorrThr").value || "0.5").trim());
        if (corr_filter && (!Number.isFinite(corr_threshold) || corr_threshold < -1 || corr_threshold > 1)) return setMsg("相关性阈值需在 [-1,1]，例如 0.5");
        const rr_sizing = ($("rotRROn").value === "true");
        const rrYearsRaw = ($("rotRRYears").value || "3").trim();
        const rr_years = Number(rrYearsRaw);
        if (rr_sizing && (!Number.isFinite(rr_years) || rr_years <= 0)) return setMsg("滚动收益率窗口年数 N 必须>0，例如 3");
        const thrRaw = ($("rotRRThr").value || "").trim();
        const wtsRaw = ($("rotRRWts").value || "").trim();
        const parseCsvNums = (s) => s.split(",").map(x => x.trim()).filter(Boolean).map(Number);
        let rr_thresholds = null;
        let rr_weights = null;
        if (rr_sizing) {
          rr_thresholds = parseCsvNums(thrRaw);
          rr_weights = parseCsvNums(wtsRaw);
          if (rr_thresholds.length === 0 || rr_thresholds.length > 5) return setMsg("收益率阈值必须为 1~5 个逗号分隔数字，例如 50,100,150,200,250");
          if (rr_weights.length !== rr_thresholds.length + 1) return setMsg("仓位档位数量必须 = 阈值数量 + 1，例如 6 档对应 5 个阈值");
          // normalize percent-like inputs
          rr_thresholds = rr_thresholds.map(x => (x > 1.0 ? x / 100.0 : x));
          rr_weights = rr_weights.map(x => (x > 1.0 ? x / 100.0 : x));
          for (const x of rr_thresholds) if (!Number.isFinite(x)) return setMsg("收益率阈值必须是数字");
          for (const x of rr_weights) if (!Number.isFinite(x)) return setMsg("仓位必须是数字");
          for (let i = 0; i + 1 < rr_thresholds.length; i++) if (!(rr_thresholds[i] < rr_thresholds[i + 1])) return setMsg("收益率阈值必须严格递增");
          for (const x of rr_weights) if (x < 0 || x > 1) return setMsg("仓位必须在 0~100%（或 0~1）");
        }
        const dd_control = ($("rotDDOn").value === "true");
        let dd_threshold = Number(($("rotDDThr").value || "10").trim());
        if (dd_control && (!Number.isFinite(dd_threshold) || dd_threshold <= 0)) return setMsg("回撤阈值 X 必须>0，例如 10 或 0.10");
        if (dd_threshold > 1.0) dd_threshold = dd_threshold / 100.0;
        if (dd_control && (dd_threshold <= 0 || dd_threshold >= 1.0)) return setMsg("回撤阈值 X 需在 (0,100%)，例如 10");
        let dd_reduce = Number(($("rotDDReduce").value || "100").trim());
        if (dd_control && (!Number.isFinite(dd_reduce) || dd_reduce < 0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        if (dd_reduce > 1.0) dd_reduce = dd_reduce / 100.0;
        if (dd_control && (dd_reduce < 0 || dd_reduce > 1.0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        const dd_sleep_days = Number(($("rotDDSleep").value || "20").trim());
        if (dd_control && (!Number.isFinite(dd_sleep_days) || dd_sleep_days < 1)) return setMsg("休眠天数必须>=1，例如 20");
        const timing_rsi_gate = ($("rotTimingOn").value === "true");
        const timing_rsi_window = Number(($("rotTimingRsiWin").value || "24").trim());
        if (timing_rsi_gate && (!Number.isFinite(timing_rsi_window) || timing_rsi_window < 2)) return setMsg("择时 RSI 窗口必须>=2");
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        if (trend_filter && (!Number.isFinite(trend_sma_window) || trend_sma_window <= 0)) return setMsg("趋势 SMA 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_window) || rsi_window <= 0)) return setMsg("RSI 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_overbought) || rsi_overbought < 0 || rsi_overbought > 100)) return setMsg("RSI 超买阈值需在 0~100");
        if (rsi_filter && (!Number.isFinite(rsi_oversold) || rsi_oversold < 0 || rsi_oversold > 100)) return setMsg("RSI 超卖阈值需在 0~100");
        if (vol_monitor && (!Number.isFinite(vol_window) || vol_window <= 0)) return setMsg("Vol 窗口必须是正整数");
        if (vol_monitor && (!Number.isFinite(vol_target_ann) || vol_target_ann <= 0)) return setMsg("目标年化Vol必须>0，例如 0.20");
        if (vol_monitor && (!Number.isFinite(vol_max_ann) || vol_max_ann <= 0)) return setMsg("最大年化Vol必须>0，例如 0.60");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_window) || chop_window <= 1)) return setMsg("ER窗口必须>=2");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_er_threshold) || chop_er_threshold <= 0)) return setMsg("ER阈值必须>0，例如 0.25");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_window) || chop_adx_window <= 1)) return setMsg("ADX窗口必须>=2");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_threshold) || chop_adx_threshold <= 0)) return setMsg("ADX阈值必须>0，例如 20");
        $("status").textContent = "回测中...";
        setMsg("");
        const resp = await api("/analysis/rotation", {
          method: "POST",
          body: JSON.stringify({
            codes, start, end, rebalance, top_k, lookback_days, skip_days, cost_bps,
            risk_off, momentum_floor, risk_free_rate,
            score_method,
            tp_sl_mode,
            atr_window, atr_mult, atr_step, atr_min_mult,
            corr_filter, corr_window, corr_threshold,
            rr_sizing, rr_years, rr_thresholds, rr_weights,
            dd_control, dd_threshold, dd_reduce, dd_sleep_days,
            timing_rsi_gate, timing_rsi_window,
            trend_filter, trend_mode, trend_sma_window,
            rsi_filter, rsi_window, rsi_overbought, rsi_oversold,
            vol_monitor, vol_window, vol_target_ann, vol_max_ann,
            chop_filter, chop_mode, chop_window, chop_er_threshold, chop_adx_window, chop_adx_threshold,
          }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        plotRotation(data);
        renderRotationMetrics(data.metrics || {});
        renderWinPayoff(data.win_payoff || {});
        renderContributionTables("rot", data.attribution);
        rotState.rows = data.period_details || [];
        rotState.page = 1;
        renderRotPeriods();
        // periodic returns tables
        rotPeriodTableState.weekly.rows = (data.period_returns && data.period_returns.weekly) ? data.period_returns.weekly : [];
        rotPeriodTableState.monthly.rows = (data.period_returns && data.period_returns.monthly) ? data.period_returns.monthly : [];
        rotPeriodTableState.quarterly.rows = (data.period_returns && data.period_returns.quarterly) ? data.period_returns.quarterly : [];
        rotPeriodTableState.yearly.rows = (data.period_returns && data.period_returns.yearly) ? data.period_returns.yearly : [];
        rotPeriodTableState.weekly.page = 1;
        rotPeriodTableState.monthly.page = 1;
        rotPeriodTableState.quarterly.page = 1;
        rotPeriodTableState.yearly.page = 1;
        renderRotPeriodTable("weekly");
        renderRotPeriodTable("monthly");
        renderRotPeriodTable("quarterly");
        renderRotPeriodTable("yearly");
      }

      async function runEwCalendarEffect() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = (($("ewCalStart").value || "").trim()) || $("start").value.trim();
        const end = (($("ewCalEnd").value || "").trim()) || $("end").value.trim();
        const adjust = $("ewCalAdjust").value || ADJUST_USED;
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        const rebalance = $("rebalance").value || "weekly";
        const parsed = parseCalendarAnchors("ew", rebalance);
        if (!parsed.ok) return setMsg(parsed.reason);
        const anchors = parsed.anchors;
        const exec_prices = _checkedValues("input.ewCalPx");
        if (anchors.length === 0) return setMsg("请至少选择一个调仓锚点");
        if (exec_prices.length === 0) return setMsg("请至少选择一个成交价口径（开盘/收盘/OC均价）");
        $("status").textContent = "计算日历效应（等权）...";
        setMsg("");
        const resp = await api("/analysis/baseline/calendar-effect", {
          method: "POST",
          body: JSON.stringify({ codes, start, end, adjust, risk_free_rate, rebalance, anchors, exec_prices }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        _renderCalendarTable("ewCalTable", data);
      }

      async function runRotCalendarEffect() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = (($("rotCalStart").value || "").trim()) || $("start").value.trim();
        const end = (($("rotCalEnd").value || "").trim()) || $("end").value.trim();
        const rebalance = $("rotRebalance").value;
        const top_k = Number(($("rotTopK").value || "1").trim());
        const lookback_days = Number(($("rotLookback").value || "252").trim());
        const skip_days = Number(($("rotSkip").value || "0").trim());
        const cost_bps = Number(($("rotCost").value || "0").trim());
        const risk_off = ($("rotRiskOff").value === "true");
        const momentum_floor = Number(($("rotFloor").value || "0").trim());
        const score_method = $("rotScoreMethod").value;
        const tp_sl_mode = ($("rotTpSlMode").value || "none");
        const atrWindowRaw = ($("rotAtrWindow").value || "").trim();
        const atr_window = atrWindowRaw === "" ? null : Number(atrWindowRaw);
        if (atr_window != null && (!Number.isFinite(atr_window) || atr_window < 2)) return setMsg("ATR窗口必须>=2（或留空表示同步动量回看）");
        const atr_mult = Number(($("rotAtrMult").value || "2.0").trim());
        if (!Number.isFinite(atr_mult) || atr_mult <= 0) return setMsg("ATR倍数必须>0，例如 2");
        const atr_step = Number(($("rotAtrStep").value || "0.5").trim());
        if (!Number.isFinite(atr_step) || atr_step <= 0) return setMsg("渐进步长必须>0，例如 0.5");
        const atr_min_mult = Number(($("rotAtrMinMult").value || "0.5").trim());
        if (!Number.isFinite(atr_min_mult) || atr_min_mult <= 0) return setMsg("最小倍数必须>0，例如 0.5");
        const trend_filter = ($("rotTrendOn").value === "true");
        const trend_mode = $("rotTrendMode").value;
        const trend_sma_window = Number(($("rotTrendSma").value || "200").trim());
        const rsi_filter = ($("rotRsiOn").value === "true");
        const rsi_window = Number(($("rotRsiWin").value || "14").trim());
        const rsi_overbought = Number(($("rotRsiOver").value || "70").trim());
        const rsi_oversold = Number(($("rotRsiUnder").value || "30").trim());
        const vol_monitor = ($("rotVolOn").value === "true");
        const vol_window = Number(($("rotVolWin").value || "20").trim());
        const vol_target_ann = Number(($("rotVolTarget").value || "0.20").trim());
        const vol_max_ann = Number(($("rotVolMax").value || "0.60").trim());
        const chop_filter = ($("rotChopOn").value === "true");
        const chop_mode = ($("rotChopMode").value || "er");
        const chop_window = Number(($("rotChopWin").value || "20").trim());
        const chop_er_threshold = Number(($("rotChopThr").value || "0.25").trim());
        const chop_adx_window = Number(($("rotChopAdxWin").value || "20").trim());
        const chop_adx_threshold = Number(($("rotChopAdxThr").value || "20").trim());
        const corr_filter = ($("rotCorrOn").value === "true");
        const corrWinRaw = ($("rotCorrWindow").value || "").trim();
        const corr_window = corrWinRaw === "" ? null : Number(corrWinRaw);
        if (corr_filter && corr_window != null && (!Number.isFinite(corr_window) || corr_window < 2)) return setMsg("相关性回看窗口必须>=2（或留空表示同步动量回看）");
        const corr_threshold = Number(($("rotCorrThr").value || "0.5").trim());
        if (corr_filter && (!Number.isFinite(corr_threshold) || corr_threshold < -1 || corr_threshold > 1)) return setMsg("相关性阈值需在 [-1,1]，例如 0.5");
        const rr_sizing = ($("rotRROn").value === "true");
        const rrYearsRaw = ($("rotRRYears").value || "3").trim();
        const rr_years = Number(rrYearsRaw);
        if (rr_sizing && (!Number.isFinite(rr_years) || rr_years <= 0)) return setMsg("滚动收益率窗口年数 N 必须>0，例如 3");
        const thrRaw = ($("rotRRThr").value || "").trim();
        const wtsRaw = ($("rotRRWts").value || "").trim();
        const parseCsvNums = (s) => s.split(",").map(x => x.trim()).filter(Boolean).map(Number);
        let rr_thresholds = null;
        let rr_weights = null;
        if (rr_sizing) {
          rr_thresholds = parseCsvNums(thrRaw);
          rr_weights = parseCsvNums(wtsRaw);
          if (rr_thresholds.length === 0 || rr_thresholds.length > 5) return setMsg("收益率阈值必须为 1~5 个逗号分隔数字，例如 50,100,150,200,250");
          if (rr_weights.length !== rr_thresholds.length + 1) return setMsg("仓位档位数量必须 = 阈值数量 + 1，例如 6 档对应 5 个阈值");
          rr_thresholds = rr_thresholds.map(x => (x > 1.0 ? x / 100.0 : x));
          rr_weights = rr_weights.map(x => (x > 1.0 ? x / 100.0 : x));
          for (const x of rr_thresholds) if (!Number.isFinite(x)) return setMsg("收益率阈值必须是数字");
          for (const x of rr_weights) if (!Number.isFinite(x)) return setMsg("仓位必须是数字");
          for (let i = 0; i + 1 < rr_thresholds.length; i++) if (!(rr_thresholds[i] < rr_thresholds[i + 1])) return setMsg("收益率阈值必须严格递增");
          for (const x of rr_weights) if (x < 0 || x > 1) return setMsg("仓位必须在 0~100%（或 0~1）");
        }
        const dd_control = ($("rotDDOn").value === "true");
        let dd_threshold = Number(($("rotDDThr").value || "10").trim());
        if (dd_control && (!Number.isFinite(dd_threshold) || dd_threshold <= 0)) return setMsg("回撤阈值 X 必须>0，例如 10 或 0.10");
        if (dd_threshold > 1.0) dd_threshold = dd_threshold / 100.0;
        if (dd_control && (dd_threshold <= 0 || dd_threshold >= 1.0)) return setMsg("回撤阈值 X 需在 (0,100%)，例如 10");
        let dd_reduce = Number(($("rotDDReduce").value || "100").trim());
        if (dd_control && (!Number.isFinite(dd_reduce) || dd_reduce < 0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        if (dd_reduce > 1.0) dd_reduce = dd_reduce / 100.0;
        if (dd_control && (dd_reduce < 0 || dd_reduce > 1.0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        const dd_sleep_days = Number(($("rotDDSleep").value || "20").trim());
        if (dd_control && (!Number.isFinite(dd_sleep_days) || dd_sleep_days < 1)) return setMsg("休眠天数必须>=1，例如 20");
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        if (trend_filter && (!Number.isFinite(trend_sma_window) || trend_sma_window <= 0)) return setMsg("趋势 SMA 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_window) || rsi_window <= 0)) return setMsg("RSI 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_overbought) || rsi_overbought < 0 || rsi_overbought > 100)) return setMsg("RSI 超买阈值需在 0~100");
        if (rsi_filter && (!Number.isFinite(rsi_oversold) || rsi_oversold < 0 || rsi_oversold > 100)) return setMsg("RSI 超卖阈值需在 0~100");
        if (vol_monitor && (!Number.isFinite(vol_window) || vol_window <= 0)) return setMsg("Vol 窗口必须是正整数");
        if (vol_monitor && (!Number.isFinite(vol_target_ann) || vol_target_ann <= 0)) return setMsg("目标年化Vol必须>0，例如 0.20");
        if (vol_monitor && (!Number.isFinite(vol_max_ann) || vol_max_ann <= 0)) return setMsg("最大年化Vol必须>0，例如 0.60");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_window) || chop_window <= 1)) return setMsg("ER窗口必须>=2");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_er_threshold) || chop_er_threshold <= 0)) return setMsg("ER阈值必须>0，例如 0.25");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_window) || chop_adx_window <= 1)) return setMsg("ADX窗口必须>=2");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_threshold) || chop_adx_threshold <= 0)) return setMsg("ADX阈值必须>0，例如 20");
        const parsed = parseCalendarAnchors("rot", rebalance);
        if (!parsed.ok) return setMsg(parsed.reason);
        const anchors = parsed.anchors;
        const exec_prices = _checkedValues("input.rotCalPx");
        if (anchors.length === 0) return setMsg("请至少选择一个调仓锚点");
        if (exec_prices.length === 0) return setMsg("请至少选择一个成交价口径（开盘/收盘/OC均价）");

        $("status").textContent = "计算日历效应（轮动）...";
        setMsg("");
        const resp = await api("/analysis/rotation/calendar-effect", {
          method: "POST",
          body: JSON.stringify({
            codes, start, end, rebalance, top_k, lookback_days, skip_days, cost_bps,
            risk_off, momentum_floor, risk_free_rate,
            score_method,
            tp_sl_mode,
            atr_window, atr_mult, atr_step, atr_min_mult,
            corr_filter, corr_window, corr_threshold,
            rr_sizing, rr_years, rr_thresholds, rr_weights,
            dd_control, dd_threshold, dd_reduce, dd_sleep_days,
            trend_filter, trend_mode, trend_sma_window,
            rsi_filter, rsi_window, rsi_overbought, rsi_oversold,
            vol_monitor, vol_window, vol_target_ann, vol_max_ann,
            chop_filter, chop_mode, chop_window, chop_er_threshold, chop_adx_window, chop_adx_threshold,
            anchors, exec_prices,
          }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        _renderCalendarTable("rotCalTable", data);
      }

      async function runAnalysis() {
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const benchmark_code = $("benchmark").value || null;
        const rebalance = $("rebalance").value || "yearly";
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 0.02");
        // allow percent input like "2.5" to mean 2.5%
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        const fftWindowsRaw = (($("fftWindows") && $("fftWindows").value) ? $("fftWindows").value : "252,126").trim();
        const fft_windows = fftWindowsRaw
          .split(",")
          .map((x) => x.trim())
          .filter(Boolean)
          .map((x) => Number(x))
          .filter((x) => Number.isFinite(x))
          .map((x) => Math.floor(x))
          .filter((x) => x >= 8);
        if (fft_windows.length === 0) return setMsg("FFT滚动窗口必须至少包含一个 >=8 的交易日整数，例如 252,126");
        const fft_roll = ($("fftRollOn").value === "true");
        const fft_roll_step = Math.max(1, Math.floor(Number(($("fftRollStep").value || "5").trim())));
        if (!Number.isFinite(fft_roll_step) || fft_roll_step < 1) return setMsg("滚动FFT步长必须是正整数，例如 5");
        $("status").textContent = "计算中...";
        setMsg("");
        const resp = await api("/analysis/baseline", { method: "POST", body: JSON.stringify({ codes, start, end, benchmark_code, adjust: ADJUST_USED, rebalance, risk_free_rate, fft_windows, fft_roll, fft_roll_step }) });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);
        lastBaseline = data;
        corrRangeKey = "all";
        plotNav(data.nav);
        renderMetrics(data.metrics);
        renderContributionTables("ew", data.attribution);
        periodState.weekly.data = data.period_returns.weekly || [];
        periodState.monthly.data = data.period_returns.monthly || [];
        periodState.quarterly.data = data.period_returns.quarterly || [];
        periodState.yearly.data = data.period_returns.yearly || [];
        periodState.weekly.page = 1;
        periodState.monthly.page = 1;
        periodState.quarterly.page = 1;
        periodState.yearly.page = 1;
        renderPeriodPaged("weekly");
        renderPeriodPaged("monthly");
        renderPeriodPaged("quarterly");
        renderPeriodPaged("yearly");
        updateCorrRangeButtons();
        // default: full backtest range (client-side recompute for consistency)
        refreshCorrelationForRange("all");
        // show percent with 0 decimals
        plotRolling("rollingReturns", "Rolling Returns", data.rolling.returns, ".0%");
        plotRolling("rollingDD", "Rolling Max Drawdown", data.rolling.max_drawdown, ".0%");
        renderFft(data.fft);
        renderFftRoll(data.fft_roll);
      }

      function initTabs(containerId) {
        const root = $(containerId);
        if (!root) return;
        const buttons = Array.from(root.querySelectorAll(".tabBtn[data-tab]"));
        const panels = buttons.map(b => $(b.dataset.tab)).filter(Boolean);
        const setActive = (tabId) => {
          buttons.forEach((b) => {
            const on = (b.dataset.tab === tabId);
            b.classList.toggle("active", on);
            b.setAttribute("aria-selected", on ? "true" : "false");
          });
          panels.forEach((p) => p.classList.toggle("active", p.id === tabId));
        };
        buttons.forEach((b) => b.addEventListener("click", () => setActive(b.dataset.tab)));
        const first = buttons[0] && buttons[0].dataset ? buttons[0].dataset.tab : null;
        if (first) setActive(first);
      }
      initTabs("rotTabs");

      function setBoxVisible(boxId, on) {
        const el = $(boxId);
        if (!el) return;
        el.style.display = on ? "" : "none";
        const inputs = Array.from(el.querySelectorAll("input, select"));
        inputs.forEach((x) => { x.disabled = !on; });
      }
      function updateChopModeUI() {
        const chopOn = ($("rotChopOn").value === "true");
        const mode = ($("rotChopMode").value || "er");
        const showEr = chopOn && mode === "er";
        const showAdx = chopOn && mode === "adx";
        setBoxVisible("rotChopErBox", showEr);
        setBoxVisible("rotChopErThrBox", showEr);
        setBoxVisible("rotChopAdxBox", showAdx);
        setBoxVisible("rotChopAdxThrBox", showAdx);
      }
      $("rotChopOn").addEventListener("change", updateChopModeUI);
      $("rotChopMode").addEventListener("change", updateChopModeUI);
      updateChopModeUI();

      function updateTrendUi() {
        const mode = ($("trendStrategy") && $("trendStrategy").value) ? $("trendStrategy").value : "ma_filter";
        setBoxVisible("trendSmaBox", mode === "ma_filter" || mode === "ema_filter" || mode === "linreg_slope");
        setBoxVisible("trendCrossBox", mode === "ma_cross");
        setBoxVisible("trendDonchianBox", mode === "donchian");
        setBoxVisible("trendMomBox", mode === "tsmom");
        setBoxVisible("trendBiasBox", mode === "bias");
      }
      if ($("trendStrategy")) $("trendStrategy").addEventListener("change", updateTrendUi);
      updateTrendUi();

      $("run").addEventListener("click", runAnalysis);
      $("runRotation").addEventListener("click", runRotation);
      async function runTrend() {
        const code = ($("trendCode") && $("trendCode").value) ? $("trendCode").value : "";
        if (!code) return setMsg("请先选择一个标的。");
        const start = ($("start").value || "").trim();
        const end = ($("end").value || "").trim();
        const strategy = ($("trendStrategy").value || "ma_filter");
        const sma_window = Number(($("trendSmaWin").value || "200").trim());
        const fast_window = Number(($("trendFastWin").value || "50").trim());
        const slow_window = Number(($("trendSlowWin").value || "200").trim());
        const donchian_entry = Number(($("trendDonEntry").value || "20").trim());
        const donchian_exit = Number(($("trendDonExit").value || "10").trim());
        const mom_lookback = Number(($("trendMomLb").value || "252").trim());
        const bias_ma_window = Number(($("trendBiasMA") && $("trendBiasMA").value ? $("trendBiasMA").value : "20").trim());
        const bias_entry_raw = Number(($("trendBiasEntry") && $("trendBiasEntry").value ? $("trendBiasEntry").value : "2").trim());
        const bias_hot_raw = Number(($("trendBiasHot") && $("trendBiasHot").value ? $("trendBiasHot").value : "10").trim());
        const bias_cold_raw = Number(($("trendBiasCold") && $("trendBiasCold").value ? $("trendBiasCold").value : "-2").trim());
        const bias_pos_mode = ($("trendBiasPosMode") && $("trendBiasPosMode").value) ? $("trendBiasPosMode").value : "binary";
        const cost_bps = Number(($("trendCost").value || "0").trim());
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;

        if (!Number.isFinite(cost_bps) || cost_bps < 0) return setMsg("交易成本(bps)必须>=0");
        if ((strategy === "ma_filter" || strategy === "ema_filter" || strategy === "linreg_slope") && (!Number.isFinite(sma_window) || sma_window < 2)) return setMsg("窗口必须>=2");
        if (strategy === "ma_cross") {
          if (!Number.isFinite(fast_window) || fast_window < 2) return setMsg("快均线窗口必须>=2");
          if (!Number.isFinite(slow_window) || slow_window < 2) return setMsg("慢均线窗口必须>=2");
          if (!(fast_window < slow_window)) return setMsg("快均线窗口必须小于慢均线窗口");
        }
        if (strategy === "donchian") {
          if (!Number.isFinite(donchian_entry) || donchian_entry < 2) return setMsg("入场窗口必须>=2");
          if (!Number.isFinite(donchian_exit) || donchian_exit < 2) return setMsg("退出窗口必须>=2");
        }
        if (strategy === "tsmom" && (!Number.isFinite(mom_lookback) || mom_lookback < 2)) return setMsg("动量回看必须>=2");
        if (strategy === "bias") {
          if (!Number.isFinite(bias_ma_window) || bias_ma_window < 2) return setMsg("BIAS MA窗口必须>=2");
          if (!Number.isFinite(bias_entry_raw)) return setMsg("入场阈值(%)必须是数字");
          if (!Number.isFinite(bias_hot_raw)) return setMsg("过热阈值(%)必须是数字");
          if (!Number.isFinite(bias_cold_raw)) return setMsg("过冷阈值(%)必须是数字");
          if (!(bias_cold_raw < bias_entry_raw && bias_entry_raw < bias_hot_raw)) return setMsg("阈值必须满足：过冷 < 入场 < 过热");
          if (!(bias_pos_mode === "binary" || bias_pos_mode === "continuous")) return setMsg("仓位模式必须是 0/1仓位 或 动态仓位");
        }

        $("status").textContent = "回测趋势策略中...";
        setMsg("");
        const resp = await api("/analysis/trend", {
          method: "POST",
          body: JSON.stringify({
            code, start, end,
            risk_free_rate,
            cost_bps,
            strategy,
            sma_window, fast_window, slow_window,
            donchian_entry, donchian_exit,
            mom_lookback,
            bias_ma_window,
            bias_entry: bias_entry_raw,
            bias_hot: bias_hot_raw,
            bias_cold: bias_cold_raw,
            bias_pos_mode,
          }),
        });
        const text = await resp.text();
        $("status").textContent = "";
        if (!resp.ok) return setMsg(text);
        const data = JSON.parse(text);

        // plots
        const dates = data.nav.dates;
        const s = data.nav.series;
        const dd = (nav) => {
          let peak = -Infinity;
          const out = [];
          for (const v of nav) {
            const x = Number(v);
            if (!Number.isFinite(x) || x <= 0) { out.push(null); continue; }
            peak = Math.max(peak, x);
            out.push(peak > 0 ? (x / peak - 1.0) : null);
          }
          return out;
        };
        Plotly.newPlot("trendChart", [
          { x: dates, y: s.STRAT, mode: "lines", name: "STRAT", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
          { x: dates, y: s.BUY_HOLD, mode: "lines", name: "BUY_HOLD", hovertemplate: "%{x}<br>%{y:.4f}<extra></extra>" },
        ], { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { type: "log", dtick: Math.log10(2.0), tickformat: ".0f", gridcolor: "#eee" } }, { responsive: true });
        Plotly.newPlot("trendDD", [
          { x: dates, y: dd(s.STRAT), mode: "lines", name: "STRAT DD", hovertemplate: "%{x}<br>%{y:.1%}<extra></extra>" },
          { x: dates, y: dd(s.BUY_HOLD), mode: "lines", name: "BH DD", hovertemplate: "%{x}<br>%{y:.1%}<extra></extra>" },
        ], { margin: { t: 20 }, legend: { orientation: "h" }, yaxis: { tickformat: ".0%", gridcolor: "#eee", zeroline: true, zerolinecolor: "#bbb" } }, { responsive: true });

        // metrics table
        const ms = (data.metrics && data.metrics.strategy) ? data.metrics.strategy : {};
        const mb = (data.metrics && data.metrics.benchmark) ? data.metrics.benchmark : {};
        const ex = (data.metrics && data.metrics.excess) ? data.metrics.excess : {};
        const rows = [
          ["策略累积收益", fmtPct(ms.cumulative_return), "买入持有累积收益", fmtPct(mb.cumulative_return)],
          ["策略年化收益", fmtPct(ms.annualized_return), "买入持有年化收益", fmtPct(mb.annualized_return)],
          ["策略年化波动", fmtPct(ms.annualized_volatility), "买入持有年化波动", fmtPct(mb.annualized_volatility)],
          ["策略最大回撤", fmtPct(ms.max_drawdown), "买入持有最大回撤", fmtPct(mb.max_drawdown)],
          ["策略夏普", fmtNum(ms.sharpe_ratio), "买入持有夏普", fmtNum(mb.sharpe_ratio)],
          ["策略索诺提", fmtNum(ms.sortino_ratio), "买入持有索诺提", fmtNum(mb.sortino_ratio)],
          ["策略溃疡(UI)", fmtNum(ms.ulcer_index), "买入持有溃疡(UI)", fmtNum(mb.ulcer_index)],
          ["平均日换手", fmtPct(ms.avg_daily_turnover), "超额年化收益", fmtPct(ex.annualized_return)],
          ["超额累积收益", fmtPct(ex.cumulative_return), "信息比率(近似)", fmtNum(ex.information_ratio)],
        ];
        $("trendMetrics").innerHTML =
          `<tr><th colspan="2">策略</th><th colspan="2">基准/超额</th></tr>` +
          rows.map(r => `<tr><td>${r[0]}</td><td>${r[1]}</td><td>${r[2]}</td><td>${r[3]}</td></tr>`).join("");
      }
      $("runTrend").addEventListener("click", runTrend);
      $("runEwCalendar").addEventListener("click", runEwCalendarEffect);
      $("runRotCalendar").addEventListener("click", runRotCalendarEffect);
      $("exportPdf").addEventListener("click", exportPdfReport);

      // dynamic anchor options for calendar-effect panels (EW uses top rebalance; rotation uses rotRebalance)
      const updateEwAnchorUI = () => renderCalendarAnchorBox("ew", $("rebalance").value || "weekly");
      const updateRotAnchorUI = () => renderCalendarAnchorBox("rot", $("rotRebalance").value || "weekly");
      $("rebalance").addEventListener("change", updateEwAnchorUI);
      $("rotRebalance").addEventListener("change", updateRotAnchorUI);
      updateEwAnchorUI();
      updateRotAnchorUI();

      async function runMcEw() {
        const btn = $("runMcEw");
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const benchmark_code = $("benchmark").value || null;
        const rebalance = $("rebalance").value || "weekly";
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        const n_sims = Number(($("mcN").value || "2000").trim());
        const block_size = Number(($("mcBlock").value || "5").trim());
        const winRaw = ($("mcWindow").value || "").trim();
        const sample_window_days = winRaw === "" ? null : Number(winRaw);
        if (sample_window_days != null && !Number.isFinite(sample_window_days)) return setMsg("滚动窗口必须是整数交易日，例如 2520");
        const seedRaw = ($("mcSeed").value || "").trim();
        const seed = seedRaw === "" ? null : Number(seedRaw);
        const oldTxt = btn.textContent;
        btn.disabled = true;
        btn.textContent = "计算中...";
        $("status").textContent = "蒙特卡洛模拟中...";
        setMsg("");
        try {
          const resp = await api("/analysis/baseline/montecarlo", {
            method: "POST",
            body: JSON.stringify({ codes, start, end, benchmark_code, adjust: ADJUST_USED, rebalance, risk_free_rate, n_sims, block_size, seed, sample_window_days }),
          });
          const text = await resp.text();
          if (!resp.ok) return setMsg(text);
          const data = JSON.parse(text);
          lastMcEw = data.mc;
          renderMcTable("mcEwTable", data.mc);
          plotMcHist("mcEwHist", data.mc, $("mcEwMetric").value);
          renderFit("Ew", data.mc, $("mcEwMetric").value);
        } finally {
          $("status").textContent = "";
          btn.disabled = false;
          btn.textContent = oldTxt;
        }
      }

      async function runMcRot() {
        const btn = $("runMcRot");
        const codes = Array.from(selected);
        if (codes.length === 0) return setMsg("未选择任何标的。");
        const start = $("start").value.trim();
        const end = $("end").value.trim();
        const rebalance = $("rotRebalance").value;
        const top_k = Number(($("rotTopK").value || "1").trim());
        const lookback_days = Number(($("rotLookback").value || "20").trim());
        const skip_days = Number(($("rotSkip").value || "0").trim());
        const cost_bps = Number(($("rotCost").value || "0").trim());
        const risk_off = ($("rotRiskOff").value === "true");
        const momentum_floor = Number(($("rotFloor").value || "0").trim());
        const score_method = $("rotScoreMethod").value;
        const tp_sl_mode = ($("rotTpSlMode").value || "none");
        const atrWindowRaw = ($("rotAtrWindow").value || "").trim();
        const atr_window = atrWindowRaw === "" ? null : Number(atrWindowRaw);
        if (atr_window != null && (!Number.isFinite(atr_window) || atr_window < 2)) return setMsg("ATR窗口必须>=2（或留空表示同步动量回看）");
        const atr_mult = Number(($("rotAtrMult").value || "2.0").trim());
        if (!Number.isFinite(atr_mult) || atr_mult <= 0) return setMsg("ATR倍数必须>0，例如 2");
        const atr_step = Number(($("rotAtrStep").value || "0.5").trim());
        if (!Number.isFinite(atr_step) || atr_step <= 0) return setMsg("渐进步长必须>0，例如 0.5");
        const atr_min_mult = Number(($("rotAtrMinMult").value || "0.5").trim());
        if (!Number.isFinite(atr_min_mult) || atr_min_mult <= 0) return setMsg("最小倍数必须>0，例如 0.5");
        const trend_filter = ($("rotTrendOn").value === "true");
        const trend_mode = $("rotTrendMode").value;
        const trend_sma_window = Number(($("rotTrendSma").value || "200").trim());
        const rsi_filter = ($("rotRsiOn").value === "true");
        const rsi_window = Number(($("rotRsiWin").value || "14").trim());
        const rsi_overbought = Number(($("rotRsiOver").value || "70").trim());
        const rsi_oversold = Number(($("rotRsiUnder").value || "30").trim());
        const vol_monitor = ($("rotVolOn").value === "true");
        const vol_window = Number(($("rotVolWin").value || "20").trim());
        const vol_target_ann = Number(($("rotVolTarget").value || "0.20").trim());
        const vol_max_ann = Number(($("rotVolMax").value || "0.60").trim());
        const chop_filter = ($("rotChopOn").value === "true");
        const chop_mode = ($("rotChopMode").value || "er");
        const chop_window = Number(($("rotChopWin").value || "20").trim());
        const chop_er_threshold = Number(($("rotChopThr").value || "0.25").trim());
        const chop_adx_window = Number(($("rotChopAdxWin").value || "20").trim());
        const chop_adx_threshold = Number(($("rotChopAdxThr").value || "20").trim());
        const corr_filter = ($("rotCorrOn").value === "true");
        const corrWinRaw = ($("rotCorrWindow").value || "").trim();
        const corr_window = corrWinRaw === "" ? null : Number(corrWinRaw);
        if (corr_filter && corr_window != null && (!Number.isFinite(corr_window) || corr_window < 2)) return setMsg("相关性回看窗口必须>=2（或留空表示同步动量回看）");
        const corr_threshold = Number(($("rotCorrThr").value || "0.5").trim());
        if (corr_filter && (!Number.isFinite(corr_threshold) || corr_threshold < -1 || corr_threshold > 1)) return setMsg("相关性阈值需在 [-1,1]，例如 0.5");
        const rr_sizing = ($("rotRROn").value === "true");
        const rrYearsRaw = ($("rotRRYears").value || "3").trim();
        const rr_years = Number(rrYearsRaw);
        if (rr_sizing && (!Number.isFinite(rr_years) || rr_years <= 0)) return setMsg("滚动收益率窗口年数 N 必须>0，例如 3");
        const thrRaw = ($("rotRRThr").value || "").trim();
        const wtsRaw = ($("rotRRWts").value || "").trim();
        const parseCsvNums = (s) => s.split(",").map(x => x.trim()).filter(Boolean).map(Number);
        let rr_thresholds = null;
        let rr_weights = null;
        if (rr_sizing) {
          rr_thresholds = parseCsvNums(thrRaw);
          rr_weights = parseCsvNums(wtsRaw);
          if (rr_thresholds.length === 0 || rr_thresholds.length > 5) return setMsg("收益率阈值必须为 1~5 个逗号分隔数字，例如 50,100,150,200,250");
          if (rr_weights.length !== rr_thresholds.length + 1) return setMsg("仓位档位数量必须 = 阈值数量 + 1，例如 6 档对应 5 个阈值");
          rr_thresholds = rr_thresholds.map(x => (x > 1.0 ? x / 100.0 : x));
          rr_weights = rr_weights.map(x => (x > 1.0 ? x / 100.0 : x));
          for (const x of rr_thresholds) if (!Number.isFinite(x)) return setMsg("收益率阈值必须是数字");
          for (const x of rr_weights) if (!Number.isFinite(x)) return setMsg("仓位必须是数字");
          for (let i = 0; i + 1 < rr_thresholds.length; i++) if (!(rr_thresholds[i] < rr_thresholds[i + 1])) return setMsg("收益率阈值必须严格递增");
          for (const x of rr_weights) if (x < 0 || x > 1) return setMsg("仓位必须在 0~100%（或 0~1）");
        }
        const dd_control = ($("rotDDOn").value === "true");
        let dd_threshold = Number(($("rotDDThr").value || "10").trim());
        if (dd_control && (!Number.isFinite(dd_threshold) || dd_threshold <= 0)) return setMsg("回撤阈值 X 必须>0，例如 10 或 0.10");
        if (dd_threshold > 1.0) dd_threshold = dd_threshold / 100.0;
        if (dd_control && (dd_threshold <= 0 || dd_threshold >= 1.0)) return setMsg("回撤阈值 X 需在 (0,100%)，例如 10");
        let dd_reduce = Number(($("rotDDReduce").value || "100").trim());
        if (dd_control && (!Number.isFinite(dd_reduce) || dd_reduce < 0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        if (dd_reduce > 1.0) dd_reduce = dd_reduce / 100.0;
        if (dd_control && (dd_reduce < 0 || dd_reduce > 1.0)) return setMsg("减仓比例 Y 需在 0~100%，例如 100");
        const dd_sleep_days = Number(($("rotDDSleep").value || "20").trim());
        if (dd_control && (!Number.isFinite(dd_sleep_days) || dd_sleep_days < 1)) return setMsg("休眠天数必须>=1，例如 20");
        const rfRaw = ($("rf").value || "").trim();
        let risk_free_rate = rfRaw === "" ? 0.025 : Number(rfRaw);
        if (!Number.isFinite(risk_free_rate)) return setMsg("无风险收益率必须是数字，例如 2.5 或 0.025");
        if (risk_free_rate > 1.0) risk_free_rate = risk_free_rate / 100.0;
        if (trend_filter && (!Number.isFinite(trend_sma_window) || trend_sma_window <= 0)) return setMsg("趋势 SMA 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_window) || rsi_window <= 0)) return setMsg("RSI 窗口必须是正整数");
        if (rsi_filter && (!Number.isFinite(rsi_overbought) || rsi_overbought < 0 || rsi_overbought > 100)) return setMsg("RSI 超买阈值需在 0~100");
        if (rsi_filter && (!Number.isFinite(rsi_oversold) || rsi_oversold < 0 || rsi_oversold > 100)) return setMsg("RSI 超卖阈值需在 0~100");
        if (vol_monitor && (!Number.isFinite(vol_window) || vol_window <= 0)) return setMsg("Vol 窗口必须是正整数");
        if (vol_monitor && (!Number.isFinite(vol_target_ann) || vol_target_ann <= 0)) return setMsg("目标年化Vol必须>0，例如 0.20");
        if (vol_monitor && (!Number.isFinite(vol_max_ann) || vol_max_ann <= 0)) return setMsg("最大年化Vol必须>0，例如 0.60");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_window) || chop_window <= 1)) return setMsg("ER窗口必须>=2");
        if (chop_filter && chop_mode === "er" && (!Number.isFinite(chop_er_threshold) || chop_er_threshold <= 0)) return setMsg("ER阈值必须>0，例如 0.25");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_window) || chop_adx_window <= 1)) return setMsg("ADX窗口必须>=2");
        if (chop_filter && chop_mode === "adx" && (!Number.isFinite(chop_adx_threshold) || chop_adx_threshold <= 0)) return setMsg("ADX阈值必须>0，例如 20");
        const n_sims = Number(($("mcN").value || "2000").trim());
        const block_size = Number(($("mcBlock").value || "5").trim());
        const winRaw = ($("mcWindow").value || "").trim();
        const sample_window_days = winRaw === "" ? null : Number(winRaw);
        if (sample_window_days != null && !Number.isFinite(sample_window_days)) return setMsg("滚动窗口必须是整数交易日，例如 2520");
        const seedRaw = ($("mcSeed").value || "").trim();
        const seed = seedRaw === "" ? null : Number(seedRaw);
        const oldTxt = btn.textContent;
        btn.disabled = true;
        btn.textContent = "计算中...";
        $("status").textContent = "蒙特卡洛模拟中...";
        setMsg("");
        try {
          const resp = await api("/analysis/rotation/montecarlo", {
            method: "POST",
            body: JSON.stringify({
              codes, start, end, rebalance, top_k, lookback_days, skip_days, cost_bps,
              risk_off, momentum_floor, risk_free_rate,
              score_method,
              tp_sl_mode,
              atr_window, atr_mult, atr_step, atr_min_mult,
              corr_filter, corr_window, corr_threshold,
              rr_sizing, rr_years, rr_thresholds, rr_weights,
              dd_control, dd_threshold, dd_reduce, dd_sleep_days,
              trend_filter, trend_mode, trend_sma_window,
              rsi_filter, rsi_window, rsi_overbought, rsi_oversold,
              vol_monitor, vol_window, vol_target_ann, vol_max_ann,
              chop_filter, chop_mode, chop_window, chop_er_threshold, chop_adx_window, chop_adx_threshold,
              n_sims, block_size, seed, sample_window_days
            }),
          });
          const text = await resp.text();
          if (!resp.ok) return setMsg(text);
          const data = JSON.parse(text);
          lastMcRot = data.mc.strategy;
          lastMcExcess = data.mc.excess;
          renderMcTable("mcRotTable", data.mc.strategy);
          renderMcTable("mcExcessTable", data.mc.excess);
          plotMcHist("mcRotHist", data.mc.strategy, $("mcRotMetric").value);
          plotMcHist("mcExcessHist", data.mc.excess, $("mcExcessMetric").value);
          renderFit("Rot", data.mc.strategy, $("mcRotMetric").value);
          renderFit("Excess", data.mc.excess, $("mcExcessMetric").value);
        } finally {
          $("status").textContent = "";
          btn.disabled = false;
          btn.textContent = oldTxt;
        }
      }

      $("runMcEw").addEventListener("click", runMcEw);
      $("runMcRot").addEventListener("click", runMcRot);

      // Correlation range buttons (default full range; disable unavailable based on current backtest).
      const wireCorrBtn = (key, id) => {
        const el = $(id);
        if (!el) return;
        el.addEventListener("click", () => {
          corrRangeKey = key;
          refreshCorrelationForRange(key);
        });
      };
      wireCorrBtn("1m", "corrRange1m");
      wireCorrBtn("3m", "corrRange3m");
      wireCorrBtn("6m", "corrRange6m");
      wireCorrBtn("1y", "corrRange1y");
      wireCorrBtn("3y", "corrRange3y");
      wireCorrBtn("5y", "corrRange5y");
      wireCorrBtn("10y", "corrRange10y");
      wireCorrBtn("all", "corrRangeAll");

      function updateAtrUi() {
        const mode = ($("rotTpSlMode").value || "none");
        const isAtr = (mode === "atr_chandelier_fixed" || mode === "atr_chandelier_progressive");
        const prog = (mode === "atr_chandelier_progressive");
        $("rotAtrWindow").disabled = !isAtr;
        $("rotAtrMult").disabled = !isAtr;
        $("rotAtrStepBox").style.display = prog ? "" : "none";
        $("rotAtrMinMultBox").style.display = prog ? "" : "none";
        $("rotAtrStep").disabled = !prog;
        $("rotAtrMinMult").disabled = !prog;
      }
      $("rotTpSlMode").addEventListener("change", updateAtrUi);
      updateAtrUi();

      // Re-plot histograms when metric selection changes (if mc already rendered)
      $("mcEwMetric").addEventListener("change", () => {
        if (!lastMcEw) return;
        plotMcHist("mcEwHist", lastMcEw, $("mcEwMetric").value);
        renderFit("Ew", lastMcEw, $("mcEwMetric").value);
      });
      $("mcRotMetric").addEventListener("change", () => {
        if (!lastMcRot) return;
        plotMcHist("mcRotHist", lastMcRot, $("mcRotMetric").value);
        renderFit("Rot", lastMcRot, $("mcRotMetric").value);
      });
      $("mcExcessMetric").addEventListener("change", () => {
        if (!lastMcExcess) return;
        plotMcHist("mcExcessHist", lastMcExcess, $("mcExcessMetric").value);
        renderFit("Excess", lastMcExcess, $("mcExcessMetric").value);
      });
      $("metricModalClose").addEventListener("click", closeMetricModal);
      $("metricModal").addEventListener("click", (e) => {
        if (e.target && e.target.id === "metricModal") closeMetricModal();
      });
      // Global delegation for all help buttons (metrics + parameters)
      document.addEventListener("click", (e) => {
        const btn = e.target && e.target.closest ? e.target.closest("button.helpBtn") : null;
        if (!btn) return;
        const key = btn.getAttribute("data-metric");
        if (!key) return;
        openMetricModal(key, {});
      });
      wirePeriodControls("weekly");
      wirePeriodControls("monthly");
      wirePeriodControls("quarterly");
      wirePeriodControls("yearly");

      $("rotPeriodSortKey").addEventListener("change", () => { rotState.page = 1; renderRotPeriods(); });
      $("rotPeriodSortDir").addEventListener("change", () => { rotState.page = 1; renderRotPeriods(); });
      $("rotPeriodPrev").addEventListener("click", () => { rotState.page -= 1; renderRotPeriods(); });
      $("rotPeriodNext").addEventListener("click", () => { rotState.page += 1; renderRotPeriods(); });
      wireRotPeriodControls("weekly");
      wireRotPeriodControls("monthly");
      wireRotPeriodControls("quarterly");
      wireRotPeriodControls("yearly");
      $("selAll").addEventListener("click", () => { pool.forEach(x => selected.add(x.code)); renderCodeList(); renderBenchmarkSelect(); });
      $("selAll").addEventListener("click", () => { maybeAdjustBacktestRange(); renderRangeHint(); });
      $("selNone").addEventListener("click", () => { selected.clear(); renderCodeList(); renderBenchmarkSelect(); maybeAdjustBacktestRange(); renderRangeHint(); });
      $("selInvert").addEventListener("click", () => {
        const next = new Set();
        for (const it of pool) if (!selected.has(it.code)) next.add(it.code);
        selected.clear(); for (const c of next) selected.add(c);
        renderCodeList(); renderBenchmarkSelect(); maybeAdjustBacktestRange(); renderRangeHint();
      });

      $("range1y").addEventListener("click", () => { setMsg(""); applyQuickRange(1); });
      $("range3y").addEventListener("click", () => { setMsg(""); applyQuickRange(3); });
      $("range5y").addEventListener("click", () => { setMsg(""); applyQuickRange(5); });
      $("range10y").addEventListener("click", () => { setMsg(""); applyQuickRange(10); });
      $("rangeAll").addEventListener("click", () => { setMsg(""); applyQuickRange(null); });

      loadPool().catch(e => setMsg(String(e)));
    </script>
  </body>
</html>

